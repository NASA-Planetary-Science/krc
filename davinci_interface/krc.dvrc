krc_version=1.07
#This file contains all the functions pertaining to the davinci KRC interface
#
#
# krc
# process_bin52
# krc_process_input
# krc_get_key_value
# krc_evalN1
# krc_evalN2
# krc_stability_flag
# porb
# generic_porb
# exo_porb
# porb_type
# krc_cond_gas
# krc_eclipse
# krc_planetary_flux_porb
# krc_planetary_flux_table
# CROCUS
# mssdI
# mdsdI


#Part of this work was performed at the Jet Propulsion Laboratory, California Institute of Technology
#under a contract with NASA.
#Government support acknowledged.
#Copyright 2018. All Rights reserved.
#This work was supported for part by: PDART grant #15-PDART15_2-0023
#                                     JPL Lew Allen Award grant #01STCR, Task R.18.022.087
#                                     the 2001 Mars Odyssey Thermal Emission Imaging System (THEMIS) project
#
#C.S. Edwards (1) and S. Piqueux (2)
#
#1: Northern Arizona University
#   Dept. of Physics & Astronomy
#   PO BOX 6010
#   Flagstaff, AZ 86011
#   USA
#
#2: Jet Propulsion Laboratory
#   California Institute of Technology
#   4800 Oak Grove Dr.
#   183-301
#   Pasadena, CA 91001
#   USA
#
#Citation: Improving Thermal Model Capability for the Planetary Science Community,
#          S. Piqueux, C. S. Edwards, R. L. Fergason, J. Laura, A. Weintraub, P. R. Christensen, H. H. Kieffer
#          49th Lunar and Planetary Science Conference (2018), Abstract #1027
#

verbose=0

#load the default files to make things faster
krc_INERTIA=read($DV_SCRIPT_FILES+"/krc_support/ti_map2ppd_v4.vicar")
krc_ALBEDO=read($DV_SCRIPT_FILES+"/krc_support/albedo_2ppd.vicar")
krc_ELEV=read($DV_SCRIPT_FILES+"/krc_support/mola_2ppd.vicar")/1000.
krc_standish=read_lines($DV_SCRIPT_FILES+"/krc_support/standish.tab")
krc_spinaxis=read_lines($DV_SCRIPT_FILES+"/krc_support/spinaxis.tab")
krc_otherparams=load_csv($DV_SCRIPT_FILES+"/krc_support/planetary_params3.csv",header=1,sep=',')
krc_smallbodies=read($DV_SCRIPT_FILES+"/krc_support/small_bodies.hdf")
krc_comets=read($DV_SCRIPT_FILES+"/krc_support/comets.hdf")
krc_porb_master=read($DV_SCRIPT_FILES+"/krc_support/porb_master.hdf")
krc_var_header=read_lines($DV_SCRIPT_FILES+"/krc_support/var_header.ascii")
krc_porb_defaults=cat("Mercury","Venus","Earth","Mars","Jupiter","Saturn","Uranus","Neptune","Pluto","Phobos","Deimos","Europa","Ganymede","Io","Callisto","101955_Bennu","1_Ceres","4_Vesta","2_Pallas","3_Juno","25143_Itokawa","5535_Annefrank","21_Lutetia","2867_Steins","9969_Braille","253_Mathilde","951_Gaspra","1P-Halley","9P-Tempel_1","10P-Tempel_2","81P-Wild_2","22P-Kopff","21P-Giacobini-Zinner","19P-Borrelly","103P-Hartley_2","67P-Churyumov-Gerasimenko",axis=y)

#NOTE krc_process_input is run at the end of this file to properly process the file one time

#convert to global variables
global(krc_INERTIA)
global(krc_ALBEDO)
global(krc_ELEV)
global(krc_standish)
global(krc_spinaxis)
global(krc_otherparams)
global(krc_smallbodies)
global(krc_comets)
global(krc_porb_master)
global(krc_porb_defaults)
global(krc_var_header)
verbose=oldverbose

F="F"
T="T"

define krc(T_Tol,k_style,WRITE,LMST,GD,JD,KEEP,COND,ffout,ffin,lbound,TUN8,thick,bodyforce,body,TPREDICT,T,adv_usage,stability,anc,v,lat,lon,ELEV,type,hour,ls,DELLS,Mat1,Mat2,Por1,Por2,INERTIA2,MAXN1,MAXN2,PFlux,BT_Avg,BT_Max,BT_Min,Dis_AU,Geom_alb,Mut_Period,Orb_Radius,Radius,Lon_Hr,IR,Vis,Eclipse,Eclipser,Ecl_Cent_Hr,Eclipse_Style,Sun_Dis,Eclipser_Rad,CM,Eclipsed_Rad,Per_Mut,Bias,Date,T_user,TI_Guess,TI_Guess_PCT,KRC_MASTER_INP_VARS_AFTER_HERE,ALBEDO,EMISS,INERTIA,COND2,DENS2,PERIOD,SPEC_HEAT,DENSITY,CABR,AMW,SatPrA,PTOTAL,FANON,TATM,TDEEP,SpHeat2,TAUD,DUSTA,TAURAT,TWILI,ARC2_G0,ARC3_Safe,SLOPE,SLOAZI,TFROST,CFROST,AFROST,FEMIS,AF1,AF2,FROEXT,SatPrB,RLAY,FLAY,CONVF,DEPTH,DRSET,PhotoFunc,GGT,DTMAX,DJUL,DELJUL,SOLARDEC,DAU,LsubS,SOLCON,GRAV,Atm_Cp,ConUp0,ConUp1,ConUp2,ConUp3,ConLo0,ConLo1,ConLo2,ConLo3,SphUp0,SphUp1,SphUp2,SphUp3,SphLo0,SphLo1,SphLo2,SphLo3,N1,N2,N3,N4,N5,N24,IIB,IC2,NRSET,NMHA,NRUN,JDISK,IDOWN,FlxP14,TUN_Flx15,KPREF,K4OUT,JBARE,Notif,IDISK2,end,LP1,LP2,LP3,LP4,LP5,LP6,LPGLOB,LVFA,LVFT,LKofT,LPORB,LKEY,LSC,LZONE,LOCAL,Prt76,LPTAVE,Prt78,Prt79,L_ONE){


	#determine the criteria for usage
  if(HasValue(lat)==0) {
		usage=1
	} else {
		usage=0
	}
	if(HasValue(adv_usage)) {
		usage=0
	} else {
		adv_usage="none"
	}

  if(usage==1) {
    printf("\n")
    printf("This runs the full krc binary mode with the following inputs.\n\n")
		printf("IMPORTANT: This interface supports only KRC > v3.5.6\n")
    printf("\n")
    printf("lat       = latitude **Required**\n")
    printf("lon       = east longitude (Default = 0)\n")
    printf("body      = name of the body (Default = \"Mars\")\n")
		printf("body      \"Bennu\",\"Phobos\",\"Halley\"\n")
    printf("hour      = LTST for data to return (Default=-32768, all hours)\n")
		printf("LMST      = LMST axis for data to return (Default=\"F\")\n")
		printf("LKEY      = use Ls DJUL input rather than Julian date (Default =\"T\")\n")
		printf("JDISK     = start \"season\" to output (Default = 721)\n")
		printf("N5        = number of \"seasons\" to run (Default = 1080)\n")
		printf("      NOTE: Dates can be provided as ls (Solar Longitude, Default), JD (Julian Date), or GD (Gregorian Date)\n")
    printf("ls        = the Heliocentric Longitude (Default=-32768, returns all seasons)\n")
		printf("JD        = the Julian Date ranging from 2451544.5 (1990-Jan-01) to 2462502.5 (2040-Jan-01)\n")
		printf("GD        = the Gregorian Date, ranging from 1990-Jan-01 to 2040-Jan-01 \n")
		printf("            format: ????-Mmm-DD, with Mmm:Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec\n")
		printf("DJUL      = if LKEY=\"T\", starting Ls (Default = 0.1)\n")
		printf("            or start julian date offset from J2000\n")
    printf("INERTIA   = thermal inertia of upper layers @ T_user (Default from 2ppd TES)\n")
    printf("T_user    = Temperature at which thermal inertia is defined \n")
    printf("Mat1      = material of upper layers, sets COND, DENSITY, SPEC_HEAT (Default=\"basalt\")\n")
    printf("Por1      = porosity of upper layers, affects DENSITY (Default=0.4)\n")
    printf("INERTIA2  = thermal inertia of lower layers (Default from 2ppd TES)\n")
    printf("Mat2      = material of lower layers, sets COND2, DENS2, SpHeat2 (Default=\"Mat1\")\n")
    printf("Por2      = porosity of lower layers, affects DENS2 (Default=Por1)\n")
    printf("thick     = top material thickness (Default=0, uniform material properties)\n")
    printf("              > 0 => 2 material regolith characterized by INERTIA and INERTIA 2, thick is the top material thickness \[m\]\n")
		printf("              = 0 => single material regolith characterized by INERTIA \[m\]\n")
		printf("              < 0 => exponential trend, abs(thick) is the H parameter\n")
		printf("k_style   = thermal conductivity trend vs. temperature when LKofT = \"T\"\n")
		printf("              \"Moon\" for T^3 trend from Hayne et al. 2017\n")
		printf("              \"Mars\" for sqrt\(T\) trend from Morgan et al. 2018\n")
    printf("lbound    = lower boundary condition options (lbound=Option//Value)\n")
		printf("              Set bottom layer temperature (K); lbound=-1.//TDEEP (Default = -1.//180.)\n")
		printf("              Set all layers to a temperature (K), then bottom fixed @ TDEEP; lbound=-2.//TDEEP\n")
		printf("              Set insulating bottom layer; lbound=0\n")
		printf("              Set geothermal heat flux (mW); lbound>0\n")
		printf("PhotoFunc = choose the photometric model (Default = 2)\n")
    printf("             -1<=x<0 for Minnaert->abs(Minnaert)\n")
    printf("              0<x<1 for Lunar Like (Keim=0.25, Vasavada=0.375)\n")
    printf("              2 for Lambert \n")
    printf("              3 for Lommel-Seeliger \n")
		printf("JBARE     = force frost free at specified season (Default JBARE=0, no forcing)\n")
    printf("LVFT      = enable condensable gas parameters (Default=\"F\")\n")
    printf("SLOPE     = surface slope in degrees (Default = 0)\n")
    printf("ALBEDO    = albedo (Default from lat,lon 2ppd TES)\n")
    printf("TAUD      = dust visible opacity (Default TAUD= 0.30)\n")
    printf("ELEV      = elevation km (Default from lat,lon 2ppd MOLA)\n")
    printf("SLOAZI    = slope azimuth in degrees east from north (Default = 0)\n")
    printf("DELLS     = ~delta Ls desired (sets DELJUL automatically, Default = 1)\n")
    printf("DELJUL    = delta julian date to increment by (Default = 1.9083)\n")
		printf("TUN8      = output temperature w/ depth (Default = 101), or atm parameters (102)\n")
    printf("N24       = number of outputs per day (Default = 96)\n")
    printf("LKofT     = use temperature dependent properties (Default = \"T\")\n")
		printf("TPREDICT  = use forward prediction of temperatures for speed (Default =\"T\")\n")
		printf("stability = check for model stability (Default = 0)\n\n")
    printf("KRC-ONE like option:\n")
    printf("T            = sets a one-point like mode where a TI is returned\n")
    printf("               for the specified conditions. This can be an array.\n")
    printf("TI_Guess     = For the one-point like mode, if the solution is guessed \n")
    printf("               a smaller lookup table is created. Can be RISKY but is ~x8 faster\n")
    printf("TI_Guess_PCT = Defines the acceptable tolerance on TI compared to TI_Guess, expressed as a fraction\n")
    printf("               If TI is not within TI_Guess_PCT*TI_Guess, a flagged value (-100) is retuned\n")
		printf("T_Tol        = Defines the temperature tolerance near the local frost point in the one point mode\n")
    printf("               If temperatures in the lookup Table are within T_Tol of the frost point,\n")
		printf("               they are treated like frosted surfaces\n")
    printf("\n")
		printf("NOTE: Many advanced features exist and are documented. Use the adv_usage argument for help\n")
		printf("adv_usage = Provide advanced usage options (\"eclipse\",\"output\",\"model_notes\",\"params\",\"generic_porb\",\"porb\")\n")
#Not currently usable--available for testing but not ready for production use
#		printf("ffout     = path to write a far-field file\n")
#		printf("ffin      = path to a far-field file saved from a previous run\n\n")
    printf("\nC.Edwards + S.Piqueux \n")
		return(null)
	}

	if(adv_usage!="none") {
		if(adv_usage!="eclipse" && adv_usage!="output" && adv_usage!="model_notes" && adv_usage!="params" && adv_usage!="generic_porb" && adv_usage!="porb") {
			printf("Invalid advanced usage parameter\n\n")
			return(null)
		}
	}

	#generic porb help
	if(adv_usage=="generic_porb"){
		printf("Use the generic_porb function to define custom orbital parameters\n")
		printf("Forces a PORB run on every krc function call\n\n")
		generic_porb(usage=1)
		return(null)
	}

	#porb help
	if(adv_usage=="porb"){
		printf("\nThe krc interface uses the porb function to calculate an orbital transformation matrix\n\n")
		printf("Pre-computed PORB defaults for a select set of bodies are preferentially used for speed\n")
		printf("bodyforce=1 will force a PORB run on every interface run\n\n")
		porb()
		return(null)
	}

	#ourput format help
  if(adv_usage=="output"){
		printf("\n")
		printf("The Full KRC mode for this interface outputs a combination of Bin52 files\n")
		printf("and support files that are used to create the structure detailed below:\n\n")
		process_bin52(usage=1)
		printf("\n")
		printf("The One-Point Mode outputs a TI (SI) for an array of input temperatures with the given parameters\n")
		printf("It can output various values that indicate why a TI was not derived for failure cases:\n")
		printf("\t-500: No value was derived or returned. KRC might have failed to run all together\n")
		printf("\t-400: TI value lower than look up table \(~15 SI\), possibly negative \(non-sensical\)\n")
		printf("\t-300: TI value higher than look up table \(~2200 SI\) and extrapolation is not permitted\n")
		printf("\t-200: Returned TI value doesn't meet proximity criterion (TI_Guess_PCT)\n")
		printf("\t-100: Bad TI_Guess / TI_Guess_PCT combination.  This is most likely a user error\n")
    return(null)
  }

	#eclipse help
	if(adv_usage=="eclipse") {
		printf("\nKRC supports Eclipses but requires the following parameters\n")
    printf("PFlux = forces a planetary flux on a orbiting body (Default = \"F\") \n")
		printf("    Needs the following Parameters (Default Provided for common bodies)\n")
		printf("            BT_Avg     : Average Brightness Temperature [K] \n")
		printf("            BT_Min     : Min Brightness Temperature, if diurnal cycle [K] \n")
		printf("            BT_Max     : Max Brightness Temperature [K] \n")
		printf("            Dis_AU     : Distance form Sun in AU \n")
		printf("            Geom_alb   : Geometric Albedo [1]\n")
		printf("            Mut_Period : Mutual Period [?]\n")
		printf("            Orb_Radius : Orbiting Radius [km] \n")
		printf("            Radius     : Radius of the Orbiting body [km] \n")
		printf("            Lon_Hr     : Longitude Hour of the surface point \n")
    printf("    OR: \n")
		printf("            IR         : A 2 x n x 1 array with IR flux (1st col.) vs. LTST (2nd col.) \n")
		printf("            Vis        : A 2 x n x 1 array with Vis flux (1st col.) vs. LTST (2nd col.) \n")
    printf("Eclipse = forces an eclipse (Default = \"F\") \n")
		printf("            Eclipser      : Eclipser name, for Example \"Mars\" or \"Phobos\" \n")
		printf("            Eclipsed      : Should be the same as \"body\", for Example \"Mars\" or \"Phobos\" \n")
    printf("            Eclipse_Style : Eclipse Style (1=Rare,2=Daily), default is daily \n")
    printf("            Sun_Dis       : Distance from the Sun in AU \n")
    printf("            Eclipser_Rad  : Eclipser radius [km] \n")
    printf("            CM            : Mutual center-of-mass orbit radius [km] if not from porb \n")
    printf("            Eclipsed_Rad  : Eclipsed radius [km] \n")
    printf("            Per_Mut       : Mutual orbit period [Days] Assumed same as diurnal PERIOD \n")
    printf("            Bias          : Eclipse Bias \n")
    printf("            Date          : Rare Eclipse: J2000 date, assumed to be on the last \season \n")
    printf("            Ecl_Cent_Hr   : Eclipse central hour [???] \n\n")
		return(null)
	}

  #Advanced model parameters
  if(adv_usage=="model_notes") {
		printf("\nAdditional options that are provided as defaults.  Briefly explains the model time steps\n\n")
    printf("K4OUT = 52.  This interface only supports bin52 output which encapsulates most of the other file formats\n")
    printf("NOTE: Recommended parameter changes are listed in the first section.\n")
    printf("Please use these parameters with caution. They are meant for advanced users.\n\n")
    printf("N1 (the number of layers, Default=29) is calculated in the function krc_evalN1\n")
    printf("\tThis function relies on various parameters including FLAY, RLAY, length of the year \n")
    printf("\tto calculate the minimum number of layers required to reach seasonal skin depth stability\n")
    printf("N2 (the number of calculations per day, Default=288) is calculated in the function krc_evalN2\n")
    printf("\tThis function relies various parameters including FLAY, N24, PERIOD\n")
    printf("\n")
    printf("The default model iterates for 2 years before\n")
    printf("outputting a full year (N5-JDISK) of data at 1/360th year intervals (DELJUL),\n")
    printf("starting at DJUL=0 (in Ls), JDISK=721, DELJUL=1.9083\n")
    printf("from 24.0/N24 to 24 by 24.0/N24 (15 minutes with N24=96).\n\n")
    printf("First layer is set at FLAY=0.18 skin depths.\n")
    printf("Each successive layer is increased by a factor of RLAY=1.2.\n\n")
    printf("ALBEDO and TAUD can be dynamic if input as \n")
    printf("2 x n x 1 arrays. Ls = column 1 and ALBEDO/TAUD = column 2\n\n")
    return(null)
  }

	#display all the parameters
  if(adv_usage=="params") {
    printf("\nThese values are from the standard KRC input file. Defaults defined in the general help\n")
    printf("or those calculated in the interface are used in place of the master.inp file values.\n\n")
    printf("See the helplist distributed with KRC for variable meanings and default values.\n\n")

	}

  #handle the verbsity settings
  if(HasValue(v)==0) {
    v=0
  } else {
    v=1
  }

  #setup ancillary data and Resampling defaults
  if(HasValue(body)==0)       body="Mars"
	if(HasValue(bodyforce)==0)  bodyforce=0

  verbose=0
  porb=porb(body,force=bodyforce)
	bodytype = porb.type.body_type


	if(type(porb)!="STRUCT") {
		printf("\nPORB Error encountered...\n")
		printf("KRC is aborting\n\n")
		verbose=3
		return(null)
	}

  #Assign default input values if not provided##################################
	if(HasValue(EMISS)==0)      EMISS=1.
  if(HasValue(WRITE)==0)      WRITE="F"
  if(HasValue(LMST)==0)       LMST="F"
  if(HasValue(ls)==0)         ls=-32768
	if(HasValue(N5)==0)         N5=1080
	if(HasValue(JDISK)==0)      JDISK=721
	if(HasValue(DJUL)==0)       DJUL=0.1
	if(HasValue(LKEY)==0)       LKEY="T"
  if(HasValue(Eclipse)==0)    Eclipse="F"
	if(HasValue(Lon_Hr)==0)     Lon_Hr=12.
	if(HasValue(PFlux)==0)      PFlux="F"
	if(HasValue(MAXN1)==0)      MAXN1=1000
	if(HasValue(MAXN2)==0)      MAXN2=86400
	if(HasValue(N4)==0)         N4=1
  if(HasValue(SLOPE)==0)      SLOPE=0
  if(HasValue(SLOAZI)==0)     SLOAZI=0
	if(HasValue(JBARE)==1)      JBARE2=JBARE                                      #For some reason, JBARE is reset on the terminal too, so here I rename it JBARE2 so JBARE in the termnal remain unchanged
  if(HasValue(JBARE)==0)      JBARE2=0
  if(JBARE2 != 0)              JBARE2=krc_ls(JBARE2)+JDISK                      #Trick to allow user to define JBARE2 as a Ls (whereas KRC defines it as a function of JDISK)
  if(HasValue(TAUD)==0)       TAUD=0.30                                         #####CHECK THAT this doesn't force an atmosphere when we have airless bodies
	if(HasValue(thick)==0)      thick=0
	if(HasValue(lat) == 0)      lat = 0
  if(HasValue(lon) == 0)      lon = 0
	if(HasValue(anc)==0)        anc=0
	if(HasValue(GD)==1)         JD=GD2JD(GD) #ls=Date2Ls(GD,body)
  if(HasValue(hour)==0)       hour=-32768
  if(HasValue(stability)==0)  stability=0
	if(HasValue(LKofT)==0)      LKofT="T"
	if(HasValue(lon) == 0)      lon=0
	if(HasValue(PhotoFunc)==0)  PhotoFunc=0                                       #Default photometric function is Lambertian
  if(HasValue(LVFT)==0)       LVFT="F"
  if(HasValue(ffout)==0)      ffout=""
  if(HasValue(ffin)==0)       ffin=""
	if(HasValue(KEEP)==0)       KEEP="F"
	if(HasValue(N24)==0)        N24=porb.krc.N24
	if(HasValue(PERIOD)==0)     PERIOD=porb.krc.PERIOD
	if(HasValue(PTOTAL)==0)     PTOTAL=porb.krc.PTOTAL
	if(HasValue(DUSTA)==0)      DUSTA=porb.krc.DUSTA
	if(HasValue(GRAV)==0)       GRAV=porb.krc.GRAV
	if(HasValue(TAURAT)==0)     TAURAT=porb.krc.TAURAT
	if(HasValue(ARC2_G0)==0)    ARC2_G0=porb.krc.ARC2_G0
	if(HasValue(DELJUL)==0 && HasValue(DELLS)==0) {
		                          DELJUL=porb.krc.DELJUL
	} else if(HasValue(DELJUL==0) && HasValue(DELLS)) {
		                          DELJUL=porb.krc.PERIOD/360.*DELLS
	} else if(HasValue(DELJUL) && HasValue(DELLS)==0) {
		                          DELJUL=DELJUL
	} else {
		                          printf("\n")
	}
	if(LVFT=="T") {                                                               #Sets frost behavior
		if((body=="Mars")||(body=="Titan")||(body=="Pluto")){
			gas_properties=krc_cond_gas(body)
			gas_properties_keys=get_struct_key(gas_properties)
			for(i=1;i<=length(gas_properties_keys);i+=1) {
				add_struct(porb.krc,get_struct(gas_properties,gas_properties_keys[,i]),name=gas_properties_keys[,i])
			}
		}
	} else {
		  if(type(body) != "STRUCT"){                                               #Avoid warning with Generic
			  if(body=="Mars") {
				  porb.krc.KPREF=1
			  }
			}
	}
	if(HasValue(TUN8)==0)       TUN_Flx15=TUN8=0                                  #By Default, temperature with depth is not provided
	#make TUN8 the name for the TUN_Flx15 which enables the 101 (return all the temperatures with depth output)
	if(type(TUN8)=="STRING"){
		if(TUN8=="F"){
			TUN8=0
		} else {
			TUN8=101
		}
	}
	TUN_Flx15=TUN8
################################################################################

	#check for double precision KRC or not
	if(fexists($DV_KRC_HOME+"/src/krcd")) {
		krcprog="krcd"
	} else {
		krcprog="krc"
	}

	#process the input file
	if(adv_usage=="params") {
  	master=krc_process_input($DV_KRC_HOME+"/run/master.inp",usage=1)
		return(null)
	} else {
		global(krc_master)
		master=krc_master
	}

  #Determine the date
	#Default Case returns all the Ls
  #Determine Julian Date if user provides a Gregorian Date
	#if(HasValue(GD)==1){                                                          #User provided a specific Gregorian Date to output
  #  JD=GD2JD(GD)
	#}                                                                             ###REMOVE ALL OTHER SEASONS SOMEWHERE
  #Determine DJUL for the specified Julian date to output
  if(HasValue(JD)==1){                                                          #User provided a specific Julian Date (or Gregorian Date) to output
    LKEY="F"
		DJUL=(JD-2451545)-DELJUL*(1+N5-JDISK)*(JDISK-1)/(N5-JDISK+1)
	}                                                                             ###REMOVE ALL OTHER SEASONS SOMEWHERE
#	if(HasValue(JD)==0){                                                          #Needed to eliminate unnecessary seasons in output structure
#		JD=0
#	}                                                                             ###REMOVE ALL OTHER SEASONS SOMEWHERE


	#get the good porb stuff
	verbose=0

	#if we have a satellite, we need to return the planetary flux values and the satellite values
	if((bodytype=="Satellite")&&(PFlux == "T")) {
    porb_Planet = porb(porb.type.parent_body,force=bodyforce)

		#run the planetary_flux_table if an array is provided
    if(HasValue(IR) == 1){
      printf("Customized Planetary Flux, IR and VIS provided\n")
			Planetary_Flux=krc_planetary_flux_table(IR,Vis,Lon_Hr)
	  }

		#run the default planetary_flux_table if an array is not provided
		if((HasValue(IR) == 0)&&(HasValue(BT_Avg) == 0)) {
			printf("Default Planetary Flux\n")
			Planetary_Flux=krc_planetary_flux_porb(porb,porb_Planet,Lon_Hr)
		}

		#run the customized planetary_flux_table if an array is not provided
		if((HasValue(IR) != 1)&&(HasValue(BT_Avg) != 0)) {                          #Assumes that if BT_Avg provided,BT_Min,BT_Max,Dis_AU,Geom_alb,Mut_Period,Orb_Radius,Radius,Lon_Hr also provided
			printf("Customized Planetary Flux, all parameters provided\n")
			if(HasValue(BT_Avg)!=0)     porb_Planet.planet_flux.BT_Avg=BT_Avg
			if(HasValue(BT_Max)!=0)     porb_Planet.planet_flux.BT_Max=BT_Max
			if(HasValue(BT_Min)!=0)     porb_Planet.planet_flux.BT_Min=BT_Min
			if(HasValue(Geom_alb)!=0)   porb_Planet.planet_flux.Geom_alb=Geom_alb
			if(HasValue(Radius)!=0)     porb_Planet.planet_flux.Radius=Radius
			if(HasValue(Dis_AU)!=0)     porb_Planet.planet_flux.Dis_AU=Dis_AU
			if(HasValue(Dis_AU)!=0)     porb.planet_flux.Dis_AU=Dis_AU
			if(HasValue(Mut_Period)!=0) porb.planet_flux.Mut_Period=Mut_Period
			if(HasValue(Orb_Radius)!=0) porb.planet_flux.Orb_Radius=Orb_Radius
			Planetary_Flux=krc_planetary_flux_porb(porb,porb_Planet,Lon_Hr)
		}
	}

	#if we have an eclipse, generate the eclipse line here
   if(Eclipse == "T"){
	   if(HasValue(Eclipser) == 0 )     Eclipser=porb.type.parent_body                                                            #By default, the Eclipser is a parent body (for satellites)
	   Eclipser_porb=porb(Eclipser)
		 if(HasValue(Eclipse_Style) == 0) Eclipse_Style=1.                                                                          #By Default, Eclipses occur daily
	 	 if(HasValue(Sun_Dis) == 0 )      Sun_Dis=max(cat(Eclipser_porb.planet_flux.Dis_AU,porb.planet_flux.Dis_AU,axis=x))         #Distance to sun, AU (used to get Sun angular diameter)
	 	 if(HasValue(Eclipser_Rad) == 0 ) Eclipser_Rad=Eclipser_porb.planet_flux.Radius                                             #Occulting body (OB) radius, km
	 	 if(HasValue(CM) == 0 )           CM=max(cat(Eclipser_porb.planet_flux.Orb_Radius,porb.planet_flux.Orb_Radius,axis=x))      #Mutual center-of-mass orbit radius, km = M
	 	 if(HasValue(Eclipsed_Rad) == 0 ) Eclipsed_Rad=porb.planet_flux.Radius                                                      #Eclipsed body (EB) surface radius, km
	 	 if(HasValue(Per_Mut) == 0 )      Per_Mut=max(cat(Eclipser_porb.planet_flux.Mut_Period,porb.planet_flux.Mut_Period,axis=x)) #Mutual orbit period, days ] Assumed same as diurnal PERIOD
	   if(HasValue(Date) == 0 )         Date=5000.
		 if(HasValue(Bias) == 0)          Bias=0.
		 if(HasValue(Ecl_Cent_Hr) == 0)   Ecl_Cent_Hr=12.
		 Eclipse_line = sprintf("14 %.0i %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f 3 0. 0. / Eclipse",Eclipse_Style,Sun_Dis,Eclipser_Rad,CM,Eclipsed_Rad,Per_Mut,Bias,Date,Ecl_Cent_Hr)
   }
	verbose=3

##########################################################################################

	#porb default values
	porbkeys=get_struct_key(porb.krc)
	for(i=1;i<=length(porb.krc);i+=1) {
		if(eval("HasValue("+porbkeys[,i]+")")==0) {
			if(HasValue(DELLS) && porbkeys[,i]=="DELJUL") {
				if(v==1) printf("Skipping %s from PORB because DELLS is set\n",porbkeys[,i])
			} else {
				if(v==1) printf("Setting %s from PORB\n",porbkeys[,i])
				eval(sprintf("%s=porb.krc.%s",porbkeys[,i],porbkeys[,i]))
			}
		}
	}

	#replace the master.input file orbital elements matrix
	#with the appropriate one from porb
	master.inp.part6=porb.rot

	#print a warning for the usage of depth
	if(HasValue(DEPTH)) {
		printf("\nWARNING: DEPTH is a special davinci variable that controls\n")
		printf("how many structure elements are shown\n")
		printf("Make sure you reset to DEPTH=2 if unexpect results occur\n\n")
	}

	if(HasValue(IC2)) {
		if(IC2!=999 && IC2<3) {
			printf("IC2 must be either 999 or >=3\n")
			printf("The first layer is atmosphere and you can't change the material properties at the first surface layer\n")
			printf("Please reset IC2 and try again\n\n")
			return(null)
		}
	}

  #split the output of krc_process_input()
  inp=master.inp
  key=master.key

  #Get elevation, albedo and ti from maps if the user didn't specify
  #Construct latitude and elevation line, as they are handled differently than everything else
	if(lat>90 || lat<-90) {
		printf("\nERROR\n")
		printf("Please enter a valid latitude range (-90:90 degrees)\n\n")
		return(null)
	}
	if(lon>360 || lon<0) {
		printf("\nERROR\n")
		printf("Please enter a valid longitude range (0:360 degrees)\n\n")
		return(null)
	}

  #Get elevation, albedo and ti from maps if the user didn't specify
  #Construct latitude and elevation line, as they are handled differently than everything else
  xy=geo_trans(lat,360-lon,2)


	#Sets Default propeties if they dont exist (note used to be a separate function materials_krc)
	#suggest moving back to a separate function at somepoint in the future
	##########################################################################################
	#KRC can accepts an upper and lower material
	#set the default materials
	#upper is basalt with inertia from TES and a porosity of 0.4 by default
	#lower is basalt with inertia from TES and a porosoty of 0.4 by default
	#One Layer By Default
	  if(type(body) != "STRUCT"){                                                 #Avoid warning with "Generic"; body is a string
		  if(body=="Europa"){
		    if(HasValue(INERTIA)==0)   INERTIA=100.                                 #Assigns INERTIA = 100 if nothing is provided
		    if((HasValue(COND)==1)&&(HasValue(DENSITY)==1)&&(HasValue(SPEC_HEAT)==1))   INERTIA=sqrt(COND*DENSITY*SPEC_HEAT) #K,R,C provided
				if((HasValue(ConUp0)==1)&&(HasValue(DENSITY)==1)&&(HasValue(SphUp0)==1))    INERTIA=sqrt(ConUp0*DENSITY*SphUp0)	 #K(T),R,C(T) provided
		    if((HasValue(COND)==1)&&((HasValue(DENSITY)==0)||(HasValue(SPEC_HEAT)==0))) INERTIA=sqrt(COND*1.E6)              #CASE ADDED TO AVOID BAD INERTIA(from Map)/COND(from User) Combo
				if((HasValue(ConUp0)==1)&&((HasValue(DENSITY)==0)||(HasValue(SphUp0)==0)))  INERTIA=sqrt(ConUp0*1.E6)            #CASE ADDED TO AVOID BAD INERTIA(from Map)/COND(from User) Combo
		    if(HasValue(Mat1)==0)      Mat1="H2O"                                   #Forces Europa to be made of H2O ice
		    if(HasValue(Mat2)==0)      Mat2="H2O"                                   #Forces Europa to be made of H2O ice
		    if(HasValue(T_user)==0)    T_user=100.                                  #Temperature where properties are defined
		    if(HasValue(INERTIA2)==0)  INERTIA2=INERTIA
		    if(HasValue(ALBEDO)==0)    ALBEDO=0.67
		    if(HasValue(ELEV)==0)      ELEV=0.
		    if(HasValue(TFROST)==0)    TFROST=0.
		    if(HasValue(k_style)==0)   k_style="Moon"
		    if(PTOTAL<1.)              TAUD=0.                                      #Forces the opacity to be 0. if no atmophere (a string like "N/A breaks the interface)
		  } else if (body=="Mars") {
		    if(HasValue(INERTIA)==0) {
					global(krc_INERTIA)
				  INERTIA=krc_INERTIA[xy[1],xy[2]]
				}
				if((HasValue(COND)==1)&&(HasValue(DENSITY)==1)&&(HasValue(SPEC_HEAT)==1))   INERTIA=sqrt(COND*DENSITY*SPEC_HEAT) #K,R,C provided
				if((HasValue(ConUp0)==1)&&(HasValue(DENSITY)==1)&&(HasValue(SphUp0)==1))    INERTIA=sqrt(ConUp0*DENSITY*SphUp0)	 #K(T),R,C(T) provided
		    if((HasValue(COND)==1)&&((HasValue(DENSITY)==0)||(HasValue(SPEC_HEAT)==0))) INERTIA=sqrt(COND*1.E6)              #CASE ADDED TO AVOID BAD INERTIA(from Map)/COND(from User) Combo
				if((HasValue(ConUp0)==1)&&((HasValue(DENSITY)==0)||(HasValue(SphUp0)==0)))  INERTIA=sqrt(ConUp0*1.E6)            #CASE ADDED TO AVOID BAD INERTIA(from Map)/COND(from User) Combo
		    if(HasValue(Mat1)==0)      Mat1="basalt"
		    if(HasValue(Mat2)==0)      Mat2="basalt"
		    if(HasValue(T_user)==0)    T_user=220.                                  #Temperature where properties are defined
		    if(HasValue(INERTIA2)==0)  INERTIA2=INERTIA
		    if(HasValue(ALBEDO)==0) {
			    global(krc_ALBEDO)
					ALBEDO=krc_ALBEDO[xy[1],xy[2]]
				}
		    if(HasValue(ELEV)==0) {
					global(krc_ELEV)
			    ELEV=krc_ELEV[xy[1],xy[2]]
				}
				if(HasValue(k_style)==0)   k_style="Mars"
		    if(PTOTAL<1.)              TAUD=0.                                      #Forces the opacity to be 0. if Mars without atmophere (a string like "N/A" breaks the interface)
		  } else {
			  if(HasValue(INERTIA)==0)   INERTIA=100.
	      if((HasValue(COND)==1)&&(HasValue(DENSITY)==1)&&(HasValue(SPEC_HEAT)==1)) INERTIA=sqrt(COND*DENSITY*SPEC_HEAT)
	      if((HasValue(COND)==1)&&((HasValue(DENSITY)==0)||(HasValue(SPEC_HEAT)==0))) INERTIA=sqrt(COND*1.E6) #CASE ADDED TO AVOID BAD INERTIA(from Map)/COND(from USer) Combo
	      if(HasValue(Mat1)==0)      Mat1="basalt"
	      if(HasValue(Mat2)==0)      Mat2="basalt"
	      if(HasValue(T_user)==0)    T_user=220.                                  #Temperature where properties are defined
	      if(HasValue(INERTIA2)==0)  INERTIA2=INERTIA
	      if(HasValue(ALBEDO)==0)    ALBEDO=0.67
	      if(HasValue(ELEV)==0)      ELEV=0.
	      if(HasValue(TFROST)==0.)   TFROST=0.
			  if(HasValue(k_style)==0)   k_style="Moon"
	      if(PTOTAL<1.)              TAUD=0.                                      #Forces the opacity to be 0. if no atmophere (a string like "N/A" breaks the interface)
      }
		} else {                                                                    #Avoid warning with "Generic"; body is a structure
	      if(HasValue(INERTIA)==0)   INERTIA=100.
				if((HasValue(COND)==1)&&(HasValue(DENSITY)==1)&&(HasValue(SPEC_HEAT)==1))   INERTIA=sqrt(COND*DENSITY*SPEC_HEAT) #K,R,C provided
				if((HasValue(ConUp0)==1)&&(HasValue(DENSITY)==1)&&(HasValue(SphUp0)==1))    INERTIA=sqrt(ConUp0*DENSITY*SphUp0)	 #K(T),R,C(T) provided
		    if((HasValue(COND)==1)&&((HasValue(DENSITY)==0)||(HasValue(SPEC_HEAT)==0))) INERTIA=sqrt(COND*1.E6)              #CASE ADDED TO AVOID BAD INERTIA(from Map)/COND(from User) Combo
				if((HasValue(ConUp0)==1)&&((HasValue(DENSITY)==0)||(HasValue(SphUp0)==0)))  INERTIA=sqrt(ConUp0*1.E6)            #CASE ADDED TO AVOID BAD INERTIA(from Map)/COND(from User) Combo
	      if(HasValue(Mat1)==0)      Mat1="basalt"
	      if(HasValue(Mat2)==0)      Mat2="basalt"
 	      if(HasValue(T_user)==0)    T_user=220.                                  #Temperature where properties are defined
	      if(HasValue(INERTIA2)==0)  INERTIA2=INERTIA
	      if(HasValue(ALBEDO)==0)    ALBEDO=0.67
	      if(HasValue(ELEV)==0)      ELEV=0.
	      if(HasValue(TFROST)==0.)   TFROST=0.
		    if(HasValue(k_style)==0)   k_style="Moon"
	      if(PTOTAL<1.)              TAUD=0.                                      #Forces the opacity to be 0. if no atmophere (a string like "N/A" breaks the interface)
      }

	#set the upper layer material properties
  X_user                     = (T_user-220.)*0.01
	T_min                      = 30.
	T_max                      = 500.
	T_Step                     = 10.0
	T_NUM                      = int(1 + (T_max - T_min)/T_Step)
	T_Tab                      = create(T_NUM,1,1,start=T_min,step=T_Step,format=float)
	X                          = (T_Tab-220.)*0.01

	Mat_Prop                   = Mat_Prop(Mat1,"F")
	if(HasValue(SphUp0)==0)    SphUp0=Mat_Prop.Cp.Sph0
	if(HasValue(SphUp1)==0)    SphUp1=Mat_Prop.Cp.Sph1
	if(HasValue(SphUp2)==0)    SphUp2=Mat_Prop.Cp.Sph2
	if(HasValue(SphUp3)==0)    SphUp3=Mat_Prop.Cp.Sph3
	if(HasValue(SPEC_HEAT)==0) SPEC_HEAT=SphUp0+SphUp1*X_user+SphUp2*X_user^2+SphUp3*X_user^3   #Cp(T_user)
  if(HasValue(Por1)==0)      Por1=0.60 * (2200. - INERTIA)/2200.
  if(HasValue(DENSITY)==0)   DENSITY=(1 - Por1) * Mat_Prop.Dens.Dens0 + Mat_Prop.Dens.Dens1*X_user + Mat_Prop.Dens.Dens2*X_user^2 + Mat_Prop.Dens.Dens3*X_user^3 #Density @ T_user
  if(HasValue(COND)==0)      COND=INERTIA^2/(DENSITY*SPEC_HEAT)                 #Conductivity @ T_user

	if(k_style == "Moon"){                                                        #increases with T, T^3 trend
	  k_Table      = COND*(1+2.7*((T_Tab-T_user)/350.)^3)                         #Trend from Hayne et al. REF HERE
  }
	if(k_style == "Mars"){                                                        #increses with T, SQRT(T) trend
	  k_Table      = COND*sqrt(T_Tab/T_user)                                      #Trend from Morgan et al. REF HERE
  }
	if(k_style == "Bulk"){                                                        #Decreases with T, driven by bulk conductivity
    k_user       = Mat_Prop.k.Con0+Mat_Prop.k.Con1*X_user+Mat_Prop.k.Con2*X_user^2+Mat_Prop.k.Con3*X_user^3
		k_Table      = (Mat_Prop.k.Con0+Mat_Prop.k.Con1*X+Mat_Prop.k.Con2*X^2+Mat_Prop.k.Con3*X^3)/k_user
  }
	FIT          = fit(y=k_Table,x=X,"cube",plot=0)

  if(HasValue(ConUp0)==0)    ConUp0=FIT[1]
  if(HasValue(ConUp1)==0)    ConUp1=FIT[2]
  if(HasValue(ConUp2)==0)    ConUp2=FIT[3]
  if(HasValue(ConUp3)==0)    ConUp3=FIT[4]

	Mat_Prop                   = Mat_Prop(Mat2,"F")
	if(HasValue(SphLo0)==0)    SphLo0=Mat_Prop.Cp.Sph0
	if(HasValue(SphLo1)==0)    SphLo1=Mat_Prop.Cp.Sph1
	if(HasValue(SphLo2)==0)    SphLo2=Mat_Prop.Cp.Sph2
	if(HasValue(SphLo3)==0)    SphLo3=Mat_Prop.Cp.Sph3
	if(HasValue(SpHeat2)==0)   SpHeat2=SphLo0+SphLo1*X_user+SphLo2*X_user^2+SphLo3*X_user^3 #Cp(T_user)
	if(HasValue(Por2)==0)      Por2 = 0.60 * (2200. - INERTIA2)/2200.
	if(HasValue(DENS2)==0)     DENS2 = (1 - Por2) * Mat_Prop.Dens.Dens0 + Mat_Prop.Dens.Dens1*X_user + Mat_Prop.Dens.Dens2*X_user^2 + Mat_Prop.Dens.Dens3*X_user^3 #Density @ T_user
	if(HasValue(COND2)==0)     COND2 = INERTIA2^2/(DENS2*SpHeat2)                 #Conductivity @ T_user

	if(k_style == "Moon"){                                                        #increases with T, T^3 trend
		k_Table      = COND2*(1+2.7*((T_Tab-T_user)/350.)^3)                        #Trend from Hayne et al. REF HERE
	}
	if(k_style == "Mars"){                                                        #increses with T, SQRT(T) trend
		k_Table      = COND2*sqrt(T_Tab/T_user)                                     #Trend from Morgan et al. REF HERE
	}
	if(k_style == "Bulk"){                                                        #Decreases with T, driven by bulk conductivity
		k_user       = Mat_Prop.k.Con0+Mat_Prop.k.Con1*X_user+Mat_Prop.k.Con2*X_user^2+Mat_Prop.k.Con3*X_user^3
		k_Table      = (Mat_Prop.k.Con0+Mat_Prop.k.Con1*X+Mat_Prop.k.Con2*X^2+Mat_Prop.k.Con3*X^3)/k_user
	}
	FIT          = fit(y=k_Table,x=X,"cube",plot=0)

  if(HasValue(ConLo0)==0)    ConLo0=FIT[1]
  if(HasValue(ConLo1)==0)    ConLo1=FIT[2]
  if(HasValue(ConLo2)==0)    ConLo2=FIT[3]
  if(HasValue(ConLo3)==0)    ConLo3=FIT[4]

	upper               = {}
	upper.req           = {}
	upper.req.INERTIA   = INERTIA
	upper.req.SphUp0    = SphUp0
	upper.req.SphUp1    = SphUp1
	upper.req.SphUp2    = SphUp2
	upper.req.SphUp3    = SphUp3
	upper.req.SPEC_HEAT = SPEC_HEAT
	upper.req.DENSITY   = DENSITY
  upper.req.ConUp0    = ConUp0
	upper.req.ConUp1    = ConUp1
	upper.req.ConUp2    = ConUp2
	upper.req.ConUp3    = ConUp3
	upper.COND          = COND
	upper.composition   = Mat1
	upper.porosity      = Por1

	#now populate the KRC input file for the specifc things we just set
	upper_keys=get_struct_key(upper.req)
	for(i=1;i<=length(upper_keys);i+=1) {
		if(eval(sprintf("HasValue(%s)==0",upper_keys[,i]))) eval(sprintf("%s=%f",upper_keys[,i],upper.req[i]))
	}

	#set the lower layer material properties
	lower               = {}
	lower.req           = {}
	lower.req.INERTIA2  = INERTIA2
	lower.req.SphLo0    = SphLo0
	lower.req.SphLo1    = SphLo1
	lower.req.SphLo2    = SphLo2
	lower.req.SphLo3    = SphLo3
	lower.req.SpHeat2   = SpHeat2
	lower.req.DENS2     = DENS2
  lower.req.ConLo0    = ConLo0
	lower.req.ConLo1    = ConLo1
	lower.req.ConLo2    = ConLo2
	lower.req.ConLo3    = ConLo3
	lower.req.COND2     = COND2
	lower.composition2  = Mat2
	lower.porosity2     = Por2

	#populate the lower keys just set
  lower_keys=get_struct_key(lower.req)
  for(i=1;i<=length(lower_keys);i+=1) {
    if(eval(sprintf("HasValue(%s)==0",lower_keys[,i]))) eval(sprintf("%s=%f",lower_keys[,i],lower.req[i]))
  }

  #Latitude section of the input file
  inp.part4[,2]=sprintf("%7.2f",lat)

  #Elevation section of the input file
  inp.part5[,2]=sprintf("%7.2f",ELEV)

  # Copy files over to temp directories and setup the initial input file
  # use randdir as the zone file name, sequential test
	randdir="krc_"+int(random(1,type=rand))
  if($DV_OS=="mac") {
		base=basename($TMPDIR)
		workdir="/tmp/"+base+"/"+randdir
		syscall("mkdir -p "+workdir)
	} else if ($DV_OS=="linux") {
		workdir=$TMPDIR
	} else {
		printf("Your operating system is not supported for use with krc\n\n")
		return(null)
	}

  #Start construction of parameter change lines for default input files
  #We now use the input file generator rather than set values
  params=text(0)

  #set the output file type
	#force it to be bin52 as it should capture most other file types
  K4OUT=52

  #Use either DELLS or DELJUL error checking
  if(HasValue(DELLS) && HasValue(DELJUL)) {
    printf("\nPlease do not set both DELLS and DELJUL\n")
    printf("Please unset one variable and try again\n\n")
    return(null)
  }


################################################################################
###ONE POINT SIMULATED MODE
################################################################################


  #Setup the special case of the onepoint model error checking
  if(HasValue(T)) {
    if(ls==-32768 || hour==-32768) {
      printf("\n'ls' and 'hour' must be set for the T (krc_one) option\n")
      printf("Please set these variables and try again\n\n")
      return(null)
    }
		#disabling temperature with depth for one point mode - unnecessary output
		TUN8=0
		TUN_Flx15=0

		#standard onepoint LS and time of day spacing
    if(HasValue(DELLS)==0) DELLS=8
    if(HasValue(N24)==0) N24=48
  }

  #set up default values that are required for smart functions
  #we get them from the standard master.inp but they are changeable at runtime
  if(HasValue(FLAY)==0)   FLAY=atof(key.part1.value[,maxpos(key.part1.key=="FLAY")[2]])
  if(HasValue(RLAY)==0)   RLAY=atof(key.part1.value[,maxpos(key.part1.key=="RLAY")[2]])
  if(HasValue(TFROST)==0) TFROST=atof(key.part1.value[,maxpos(key.part1.key=="TFROST")[2]])

  #deal with the lower boundary condition
  if(HasValue(lbound)==0) {                                                     #Insulate
		IIB=-1
		TDEEP=180                                                                   #DOES NOT MATTER IF INSULATION
	} else {
		#Bottom layer set to TDEEP
		if(lbound[1]==-1){                                                          #Fixed Bottom Temperature @ TDEEP
			IIB=-1
			if(HasValue(TDEEP)==0) TDEEP=lbound[2]
		}
		#All layers set to TDEEP
		if(lbound[1]==-2){                                                          #All layers start @ TDEED, then bottom fixed @ TDEEP)
			IIB=-2
			if(HasValue(TDEEP)==0) TDEEP=lbound[2]
		}
		#Insulating bottom layer
		if(lbound[1]==0){
			IIB=0
		}
		#geothermal heatflux
		if(lbound[1]>0){
			IIB=lbound[1]
		}
	}

  #handle the DELLS case where we specify the LS delta instead of the DELJUL
  if(HasValue(DELLS)) {

    #set the standard DELLS
    if(HasValue(DELLS)==0) DELLS=1
    if(DELLS<0.53845) {
      DELLS=0.53845
      printf("\nWARNING: You may not select a DELLS < %.4f as it will compound\n",DELLS)
      printf("time of day and season into the output. Resetting to %.4f\n",DELLS)
    }

    #this julian date delta 1.9083 is approximately equal to 1 Martian LS
    #calculate the new approximate DELJUL based on the DELLS increment
    DELJUL=1.9083*DELLS

    #calculate N5 & JDISK for 2 year spin up and a full year output
    N5=int(ceil(360./DELLS*3))
    JDISK=int(ceil(360./DELLS*2+1))
  } else {

    #this case makes sure DELLS is always set even if its not specified
    DELLS=DELJUL/1.9083
  }

  #just a little error handling so we don't break KRC
  if(N5-JDISK>720) {
    printf("ERROR: KRC only supports writing of 720 seasons to a file\n")
    printf("Please correct N5-JDISK to meet this requirement (<=720)\n\n")
    return(null)
  }
  if(N5>2161) {
    printf("ERROR: N5 must be <= 2161 for this version of KRC\n")
    printf("Please correct N5 to meet this requirement\n\n")
    return(null)
  }
	if(DELJUL<PERIOD) {
		DELJUL=PERIOD
		printf("\nWARNING: You may not select a DELJUL < %.4f as it will compound\n",DELJUL)
		printf("time of day and season into the output. Resetting to %.4f\n",DELJUL)
	}

	#This handles if we are using KRCs Temperature Predicting capabilits
	#for increased speed, for LOW DELJULs, the model may not reach stability
	#before the prediction happens
	if(DELJUL<=3*PERIOD) {
		if(HasValue(TPREDICT)==0) TPREDICT="F"
	}
	if(HasValue(TPREDICT)==0)   TPREDICT="T"
	if(TPREDICT=="F") {
		if(HasValue(GGT)==0)      GGT=99.
		if(HasValue(N3)==0)       N3=1
		if(HasValue(NRSET)==0)    NRSET=999
	} else {
		if(HasValue(GGT)==0)      GGT=atof(key.part1.value[,maxpos(key.part1.key=="GGT")[2]])
		if(HasValue(N3)==0)       N3=atof(key.part2.value[,maxpos(key.part2.key=="N3")[2]])
		if(HasValue(NRSET)==0)    NRSET=atof(key.part2.value[,maxpos(key.part2.key=="NRSET")[2]])
	}

  #calculate N1/N2 so that we optimize run time and model stability
  #calculate the minumum number of layers required to reach 3 seasonal skin depths

	#note this is actually running when we call the one point mode too...we should probably modify that.
   N1struct=krc_evalN1(RLAY,FLAY,upper.req.INERTIA,upper.req.SPEC_HEAT,upper.req.DENSITY,DELJUL,N5,JDISK,MAXN1,PERIOD,lower.req.INERTIA2,lower.req.SpHeat2,lower.req.DENS2,thick,LKofT)
	 if(LKofT=="T")                      N1struct.layer.Cond=ConUp0
   if(LKofT=="T")                      N1struct.layer.Cp=SphUp0
	#here we dont really honor FLAY-need to decide what happens when the user overwrites FLAY/RLAY
	FLAY=N1struct.req.FLAY
	RLAY=N1struct.req.RLAY
	if(HasValue(IC2)==0)                IC2=N1struct.req.IC2
	if(HasValue(N1)==1){                                                                              #makes sure regolith properties are only returned for N1 elements (and not deeper)
		N1struct.req.N1                   = N1                                                          #SP 2019 05 16: Allows to set N1 in one point mode; can sometimes lead to "Illegal range value." if the number of layers is < N1
		N1struct.layer.Num                = N1struct.layer.Num[,,:N1]
		N1struct.layer.mass_burden        = N1struct.layer.mass_burden[,,:N1]
		N1struct.layer.Cond               = N1struct.layer.Cond[,,:N1]
  if(LKofT=="T")                      N1struct.layer.Cond=ConUp0
		N1struct.layer.Density            = N1struct.layer.Density[,,:N1-1]
		N1struct.layer.Cp                 = N1struct.layer.Cp[,,:N1-1]
  if(LKofT=="T")                      N1struct.layer.Cp=SphUp0
		N1struct.layer.m.thickness        = N1struct.layer.m.thickness[,,:N1]
		N1struct.layer.m.center_depth     = N1struct.layer.m.center_depth[,,:N1]
		N1struct.layer.m.depth            = N1struct.layer.m.depth[,,:N1]
	 	N1struct.layer.Scale.thickness    = N1struct.layer.Scale.thickness[,,:N1]
 		N1struct.layer.Scale.center_depth = N1struct.layer.Scale.center_depth[,,:N1]
 		N1struct.layer.Scale.depth        = N1struct.layer.Scale.depth[,,:N1]
  }

	if(HasValue(N1)==0)    N1=N1struct.req.N1

	if(HasValue(LZONE)==0) LZONE=N1struct.req.LZONE

	#use the krc_evalN1 generated zone file which is like the albedo/taud files
	if(LZONE=="T") {
	  #zonefile must be located where KRC runs - forces a soft link to krc
 	  write(N1struct.Zone.inp,workdir+"/zonefile.tab",type=ascii,force=1)
	  params=cat(params,sprintf("8 25 0 'zonefile.tab' /"),y)
	  if(v==1) printf("ZONE FILE\n")
	}

  #calculate the minumum number of times per day for krc to run
  if(HasValue(N2)==0) {
  	N2=krc_evalN2(FLAY,INERTIA,upper.req.DENSITY,upper.req.SPEC_HEAT,PERIOD,N24,MAXN2)
  }

	#report the body thats being run
	if(porb.type.body_type=="Minor"){
		body_type_clean="Minor body"
	} else {
		body_type_clean=porb.type.body_type
	}

	printf("\nRunning KRC for \"%s, %s\"\n\n",porb.type.body_type,porb.type.name)

  printf("Output:\n")
  printf("\tEvery ~%.3f Ls (%.4f JD) for %i seasons starting at %.2f Ls\n",DELLS,DELJUL,N5-JDISK+1,DJUL)
  printf("\tFor %i times per day, every %i local minutes\n",N24,(24*60)/N24)
	if(TPREDICT=="F") {
		printf("\tRunning model WITH NO temperature prediction\n")
		if(DELJUL<=3*PERIOD) printf("\tbecause DELJUL < %.4f\n",3*PERIOD)
	} else {
		printf("\tRunning model WITH temperature prediction for speed\n")
		if(DELJUL<=3*PERIOD) printf("\tbecause the user forced TPREDICT=\"T\"\n")
	}
  if(IC2!=999) {
    layerstring=sprintf("material properties changed at layer %i",IC2)
  } else {
    layerstring="uniform material properties"
  }
  printf("\nFor a Surface With:\n")
  printf("\t%i Layers with %s and %i daily model time steps",N1,layerstring,N2)
  if(LKofT=="T") printf("\n\tand T-dependant material properties")
  if(HasValue(IIB)) {
    if(IIB==0) printf("\n\tand an insulating bottom edge condition")
    if(IIB==-1) printf("\n\tand a fixed bottom layer temperature of %.2fK",TDEEP)
    if(IIB==-2) printf("\n\tand all layers starting at the same temperature of %.2fK",TDEEP)
	  if(IIB>0) printf("\n\tand a geothermal heatflux of %.2f mW",IIB)
  }
	if(PhotoFunc==0.) printf("\n\tand a lambertian photometric surface")
	if(PhotoFunc<-1.) printf("\n\tand a Lommel-Seeliger photometric surface")
	if(PhotoFunc>=-1 && PhotoFunc<0) printf("\n\tand Minnaert photometric surface with exponent %.2f",abs(PhotoFunc))
	if(PhotoFunc>0 && PhotoFunc<1) printf("\n\tand Lunar-Like photometric surface with Keihm polynomial %.2f",PhotoFunc)
	if(PTOTAL<=0.1) {
			printf("\n\tfor an airless body")
		}

	if(PTOTAL>0.1) {
  	printf("\n\n")
		printf("With Atmospheric Parameters:")
		printf("\n\tfor a body with an average global atmospheric pressure of %d Pa",PTOTAL)
		if(LVFT=="T") {
			printf("\n\tand a pressure-dependant condensable atmosphere")
		} else {
			printf("\n\tand a condensable atmosphere with frost Temperature of %.2f K",TFROST)
		}
		if(HasValue(KPREF)) {
			if(KPREF==1) {
				printf("\n\tand a seasonal pressure that follows Viking landers trends")
			} if(KPREF==2) {
				printf("\n\tand a seasonal pressure that depends on the global frost budget")
			}
		}
	}

	printf("\n\n")
  printf("With Observation Parameters:\n")

  printf("\tLATITUDE: %6.2f\tLONGITUDE: %6.2f\n\tELEVATION: %.3fkm^\tSLOPE/AZIMUTH: %.2f/%.2fdeg\n",lat,lon,ELEV,SLOPE,SLOAZI)
  if(dim(ALBEDO)>1) {
    printf("\tALBEDO: Varies")
  } else {
    printf("\tALBEDO: %.3f^",ALBEDO)
  }
	if(PTOTAL>0.1) {
		if(dim(TAUD)>1) {
	    printf("\tOPACITY: Varies\n")
	  } else {
	    printf("\t\tOPACITY: %.3f\n",TAUD)
	  }
	} else {
		printf("\n")
	}
  if(hour!=-32768) {
    printf("\tHOUR: %.2f",hour)
  } else {
    printf("\tHOUR: All")
  }
  if(ls!=-32768) {
    printf("\t\tLS: %.2f\n\n",ls)
  } else {
    printf("\t\tLS: All\n\n")
  }

  if(HasValue(T)==0) {
    if(IC2!=999) {
 	    printf("Upper Material:\t\t\tLower Material:\n")
	    printf("\tINERTIA: %.2f\t\tINERTIA2: %.2f*\n\tCONDUCTIVITY: %.4f*\tCONDUCTIVITY: %.4f\n",upper.req.INERTIA,lower.req.INERTIA2,upper.COND,lower.req.COND2)
      printf("\tDENSITY: %.2f*\tDENSITY: %.2f*\n\tSPECIFIC HEAT: %.2f\tSPECIFIC HEAT: %.2f\n",upper.req.DENSITY,lower.req.DENS2,upper.req.SPEC_HEAT,lower.req.SpHeat2)
	    printf("\tPOROSITY: %.2f\t\tPOROSITY: %.2f\n\n",upper.porosity,lower.porosity2)
    } else {
 		  printf("Upper Material:\n")
 	    printf("\tINERTIA: %.2f\n\tCONDUCTIVITY: %.4f*\n\tDENSITY: %.2f*\n\tSPECIFIC HEAT: %.2f\n\tPOROSITY: %.2f\n",upper.req.INERTIA,upper.COND,upper.req.DENSITY,upper.req.SPEC_HEAT,upper.porosity)
 	  }

		printf("\n* = derived value unless overwritten by user\n")
		if((bodytype!="Generic")&&(bodytype!="Exoplanet")) {
			if(body=="Mars") printf("^ = from TES 2ppd map unless overwritten by user\n")
			if(body!="Mars") printf("^ = Prescribed value unless overwritten by user\n")
		}
  } else {
    printf("Running One-Point Simulation Mode\n")
		printf("...for "+int(dim(T)[1]*dim(T)[2]*dim(T)[3])+ " case(s)\n")
  }

	if(porb.rot_per_flag==1) {
		printf("\nWARNING: No Rotation Period was found in the default parameters\n")
		printf("Defaulting to 24 hrs per day\n\n")
	}

  #start constructing the input file
  #set N4 because KRC performs the check of # of elevations/latitudes prior to setting the change cards.
  N4part2posy=maxpos(inp.part2==grep(inp.part2,"N4")[,1])[2]
  N4part2posx=strstr(inp.part2[,N4part2posy],"N4")+1
  inp.part2[N4part2posx-9:N4part2posx,N4part2posy+1]=sprintf("%10s",N4+"")

  #Deal with the upgraded change card options
  #Start with part 3: the boolean values (translate them from T/F to 0/1 using atob)
  for(i=1;i<=length(key.part3.key);i+=1) {
    if(eval(sprintf("HasValue(%s)==1",key.part3.key[,i]))){
      params=cat(params,sprintf("3 %i %i '%s' /",i,atob(eval(key.part3.key[,i])),key.part3.key[,i]),axis=y)
      if(v==1) printf("YES %s=%i\n",key.part3.key[,i],atob(eval(key.part3.key[,i])))
    } else {
      if(v==1)  printf("NO %s\n",key.part3.key[,i])
    }
  }

  #Then part 2: the integer values
  for(i=1;i<=length(key.part2.key);i+=1) {
    if(eval(sprintf("HasValue(%s)==1",key.part2.key[,i])) && key.part2.key[,i]!="N4"){
      verbose=0
      params=cat(params,sprintf("2 %i %i '%s' /",i,eval(key.part2.key[,i]),key.part2.key[,i]),axis=y) #THIS LINE HAS AN ISSUE WHEN SETTING TUN8="T" or "F" #OK but TUN8 should not be "T" or "F"
      verbose=1
      if(v==1) printf("YES %s=%i\n",key.part2.key[,i],eval(key.part2.key[,i]))
    } else {
      if(v==1) printf("NO %s\n",key.part2.key[,i])
    }
  }

  #Then part 1: the floating point values
  #Also check for a time varying albedo/taud
  for(i=1;i<=length(key.part1.key);i+=1) {

    #check to see if the variable has a value
    if(eval(sprintf("HasValue(%s)==1",key.part1.key[,i]))){

      #if ALBEDO is an array, do a special thing
      if (max(dim(ALBEDO))>1 && key.part1.key[,i]=="ALBEDO") {
				global(krc_var_header)
				var=krc_var_header
        for(j=1;j<=dim(ALBEDO)[2];j+=1) {
          var=cat(var,sprintf("%.2f\t%.2f",ALBEDO[1,j],ALBEDO[2,j]),axis=y)
        }
        write(var,workdir+"/albfile.tab",type=ascii,force=1)
        params=cat(params,sprintf("8 22 0 '%s/albfile.tab' /", workdir),y)
        if(v==1) printf("ALBEDO Array\n")

      #if TAUD is an array, do the same special thing.
      } else if(max(dim(TAUD))>1 && key.part1.key[,i]=="TAUD") {
				global(krc_var_header)
				var=krc_var_header
        for(j=1;j<=dim(TAUD)[2];j+=1) {
          var=cat(var,sprintf("%.2f\t%.2f",TAUD[1,j],TAUD[2,j]),axis=y)
        }
        write(var,workdir+"/taufile.tab",type=ascii,force=1)
        params=cat(params,sprintf("8 23 0 '%s/taufile.tab' /", workdir),y)
        if(v==1) printf("TAUD Array\n")

      #otherwise, just do the normal thing
      } else {
				if(eval(key.part1.key[,i])<1 && eval(key.part1.key[,i])>-1) {
	        params=cat(params,sprintf("1 %i %.3E '%s' /",i,eval(key.part1.key[,i]),key.part1.key[,i]),axis=y)
	        if(v==1) printf("YES %s=%.3E\n",key.part1.key[,i],eval(key.part1.key[,i]))
				} else {
		      params=cat(params,sprintf("1 %i %.4f '%s' /",i,eval(key.part1.key[,i]),key.part1.key[,i]),axis=y)
	        if(v==1) printf("YES %s=%.4f\n",key.part1.key[,i],eval(key.part1.key[,i]))
				}
      }
    } else {
    if(v==1) printf("NO %s\n",key.part1.key[,i])
    }
  }

  #set the output file path
  params=cat(params,sprintf("8 5 0 '%s/outdata.bin.%s' /",workdir,K4OUT+""),y)

	if(ffout!="" && ffin!="" ) {
		printf("Error: Far Field Out and Input may not be set simultaneously\n")
	} else {
		if(ffout!="") {
			if(v==1) printf("Writing Far Field File to %s\n",ffout)
			K4OUT2=-3
			k4out_loc=maxpos(key.part2.key=="K4OUT")[2]
			params=cat(params,sprintf("2 %i %i '%s' /",k4out_loc,K4OUT2,"K4OUT2"),y)
			params=cat(params,sprintf("8 21 0 '%s' /",ffout),y)
			if(KEEP != "T") syscall("rm "+ffout)                                      #KEEP FILES FOR DEBUGS
		}

		if(ffin!="") {
			if(v==1) printf("Reading Far Field File from %s\n",ffin)
			params=cat(params,sprintf("8 3 0 '%s' /",ffin),y)
		}
	}

##########################################################################################
		#run the planetary_flux_table if an array is provided
    if((HasValue(IR) == 1)&&(HasValue(Vis) == 1)&&(HasValue(Planetary_Flux)==0)){
      printf("Customized Planetary Flux, IR and VIS provided\n")
			Planetary_Flux=krc_planetary_flux_table(IR,Vis,Lon_Hr)
			params=cat(params,Planetary_Flux,axis=y)
	  }
	  if(HasValue(Planetary_Flux)==1){
	    params=cat(params,Planetary_Flux,axis=y)
    }
##########################################################################################



	#Add Eclipse line here
  if(HasValue(Eclipse_line)==1){
    params=cat(params,Eclipse_line,axis=y)
  }

  #end the run
  params=cat(params,sprintf("0/"),y)
  params=cat(params,sprintf("0/"),y)

  #This is the standard KRC_BIN case
  if(HasValue(T)==0) {
    #Assemble and write the input file to the temporary directory
    input=cat(inp.header,inp.part1,inp.part2,inp.part3,inp.part4,inp.part5,inp.part6,params,axis=y)
    write(input,workdir+"/krc.inp",ascii,force=1)

    #run krc on the input file we just generated.
		if($DV_OS=="mac") {
			cmd="chmod a+rwx "+workdir+"/"+krcprog+" ;"
		} else {
			cmd=""
		}

    if(v>=1){
      system("cd "+workdir+"; ln -s "+$DV_KRC_HOME+"/src/"+krcprog+" .; "+cmd+" ./"+krcprog+" < "+$DV_SCRIPT_FILES+"/krc_support/fake_krc344 2>&1 | tee -a "+workdir+"/krc.log")
      log=read_lines(workdir+"/krc.log")
    } else {
      log=syscall("cd "+workdir+"; ln -s "+$DV_KRC_HOME+"/src/"+krcprog+" .; "+cmd+" ./"+krcprog+" < "+$DV_SCRIPT_FILES+"/krc_support/fake_krc344 > /dev/null 2>&1")
    }

		#make sure krc ran appropriately and created a bin5 file
		if(fexists(workdir+"/outdata.bin."+K4OUT)==0) {
			printf("KRC failed to run for some reason\n")
			printf("Returning the runtime log\n")
			return(log)
		}
    #load the full bin5 struct if the anc data flag is set
    #process the bin52 file...other formats can go here too.
		verbose=0
    ret=process_bin52(workdir+"/outdata.bin."+K4OUT,raw=anc,hour=hour,ls=ls,TUN8=TUN8,JD=JD,GD=GD)
		verbose=1
    #setup the ouput structure
    out={}

    #fill in the output data
    out=ret
    out.alb=ALBEDO
    out.elev=ELEV
		out.body=porb.body
		out.anc.porb=porb
		if(bodytype=="Generic") out.anc.porb.elements=body
#		if(bodytype=="Exoplanet") out.anc.porb.elements=body

  } else {

    #This case is like the KRC_ONE Option
    #Krc is run multiple times and interpolate T to get TI values
		#value=14;expon=0.65765;steps=35

		if(HasValue(TI_Guess)==0) {
			#set the exponent and starting point
			value=6  #was 14
			expon=0.6313
			steps=int(41)                                                             #Might want to reduce that

			#create the TI table
			T_table=TI_table=create(steps,1,1,start=0,step=0,format=float)
      for(i=1;i<=dim(TI_table)[1];i+=1) {
        TI_table[i]=value=round(ceil((value^expon))+value)
      }
		} else {
      TI_table = cat(TI_Guess*0.55,TI_Guess*0.85,TI_Guess*1.15,TI_Guess*1.45,axis=x)
      T_table  = TI_table * 0.0
      steps    = dim(TI_table)[1]
    }

		#find the position of things that need to change
		#currently this only works for parts 1/2
		removelist=cat("INERTIA","DENSITY","N2","ConUp0","ConUp1","ConUp2","ConUp3","FLAY","RLAY","IC2","N1",axis=y)
		update=pos=index=part_num=clone(0,length(removelist),1,1)

		#loop through the remove list to make sure we delete and index all values that need to be updated
		for(j=1;j<=length(removelist);j+=1) {

			#determine which part each item comes from so we can index it in the future
			part_num[j]=int(sum((key.part1.key==removelist[,j]))+sum(key.part2.key==removelist[,j])*2)
			index[j]=maxpos(eval("key.part"+part_num[j]+".key")==removelist[,j])[2]

			#determine the position of each item in the parameters list and remove it
			if(HasValue(grep(params,removelist[,j]))) {
				pos[j]=maxpos(params==grep(params,removelist[,j])[,1])[2]
				params=cat(params[,:pos[j]-1],params[,pos[j]+1:],axis=y)
			}
		}

    #remove the trailing double zeros
    params=params[,:length(params)-2]

    #loop through all cases and make the table
    for(i=1;i<=steps;i+=1) {

			INERTIA = TI_table[i]


Mat_Prop                   = Mat_Prop(Mat1,"F")
SphUp0=Mat_Prop.Cp.Sph0
SphUp1=Mat_Prop.Cp.Sph1
SphUp2=Mat_Prop.Cp.Sph2
SphUp3=Mat_Prop.Cp.Sph3
SPEC_HEAT=SphUp0+SphUp1*X_user+SphUp2*X_user^2+SphUp3*X_user^3                  #Cp(T_user)
Por1 = 0.60 * (2200. - INERTIA)/2200.
DENSITY = (1 - Por1) * Mat_Prop.Dens.Dens0 + Mat_Prop.Dens.Dens1*X_user + Mat_Prop.Dens.Dens2*X_user^2 + Mat_Prop.Dens.Dens3*X_user^3 #Density @ T_user
COND = INERTIA^2/(DENSITY*SPEC_HEAT)                                            #Conductivity @ T_user

if(k_style == "Moon"){                                                          #increases with T, T^3 trend
	k_Table      = COND*(1+2.7*((T_Tab-T_user)/350.)^3)                           #Trend from Hayne et al. REF HERE
}
if(k_style == "Mars"){                                                          #increses with T, SQRT(T) trend
	k_Table      = COND*sqrt(T_Tab/T_user)                                        #Trend from Morgan et al. REF HERE
}
if(k_style == "Bulk"){                                                          #Decreases with T, driven by bulk conductivity
	k_user       = Mat_Prop.k.Con0+Mat_Prop.k.Con1*X_user+Mat_Prop.k.Con2*X_user^2+Mat_Prop.k.Con3*X_user^3
	k_Table      = (Mat_Prop.k.Con0+Mat_Prop.k.Con1*X+Mat_Prop.k.Con2*X^2+Mat_Prop.k.Con3*X^3)/k_user
}
FIT          = fit(y=k_Table,x=X,"cube",plot=0)
ConUp0       = FIT[1]
ConUp1       = FIT[2]
ConUp2       = FIT[3]
ConUp3       = FIT[4]


Mat_Prop                   = Mat_Prop(Mat2,"F")
SphLo0=Mat_Prop.Cp.Sph0
SphLo1=Mat_Prop.Cp.Sph1
SphLo2=Mat_Prop.Cp.Sph2
SphLo3=Mat_Prop.Cp.Sph3
SpHeat2=SphLo0+SphLo1*X_user+SphLo2*X_user^2+SphLo3*X_user^3                    #Cp(T_user)
Por2 = 0.60 * (2200. - INERTIA2)/2200.
DENS2 = (1 - Por2) * Mat_Prop.Dens.Dens0 + Mat_Prop.Dens.Dens1*X_user + Mat_Prop.Dens.Dens2*X_user^2 + Mat_Prop.Dens.Dens3*X_user^3 #Density @ T_user
COND2 = INERTIA2^2/(DENS2*SpHeat2)                                              #Conductivity @ T_user

if(k_style == "Moon"){                                                          #increases with T, T^3 trend
	k_Table      = COND2*(1+2.7*((T_Tab-T_user)/350.)^3)                          #Trend from Hayne et al. REF HERE
}
if(k_style == "Mars"){                                                          #increses with T, SQRT(T) trend
	k_Table      = COND2*sqrt(T_Tab/T_user)                                       #Trend from Morgan et al. REF HERE
}
if(k_style == "Bulk"){                                                          #Decreases with T, driven by bulk conductivity
	k_user       = Mat_Prop.k.Con0+Mat_Prop.k.Con1*X_user+Mat_Prop.k.Con2*X_user^2+Mat_Prop.k.Con3*X_user^3
	k_Table      = (Mat_Prop.k.Con0+Mat_Prop.k.Con1*X+Mat_Prop.k.Con2*X^2+Mat_Prop.k.Con3*X^3)/k_user
}
FIT          = fit(y=k_Table,x=X,"cube",plot=0)
ConLo0       = FIT[1]
ConLo1       = FIT[2]
ConLo2       = FIT[3]
ConLo3       = FIT[4]


			upper               = {}
			upper.req           = {}
			upper.req.INERTIA   = INERTIA
			upper.req.SphUp0    = SphUp0
			upper.req.SphUp1    = SphUp1
			upper.req.SphUp2    = SphUp2
			upper.req.SphUp3    = SphUp3
			upper.req.SPEC_HEAT = SPEC_HEAT
			upper.req.DENSITY   = DENSITY
			upper.req.ConUp0    = ConUp0
			upper.req.ConUp1    = ConUp1
			upper.req.ConUp2    = ConUp2
			upper.req.ConUp3    = ConUp3
			upper.COND          = COND                                                #This is NOT upper.req.COND (no .req.)
			upper.composition   = Mat1
			upper.porosity      = Por1

			#calculate parameters for optimal model stability
		  N1struct=krc_evalN1(RLAY,FLAY,upper.req.INERTIA,upper.req.SPEC_HEAT,upper.req.DENSITY,DELJUL,N5,JDISK,MAXN1,PERIOD,INERTIA2,SpHeat2,DENS2,thick,LKofT)    #Missing "LKofT"

			#Force the onepoint mode to have IC2=999
			N1struct.req.IC2=999
			if(thick!=0) {
				print("\nNOTE: More than one material is not permitted in the \"one point mode\". Ignoring all but the top layer properties\n")
			}

		  N2=float(krc_evalN2(N1struct.req.FLAY,upper.req.INERTIA,upper.req.DENSITY,upper.req.SPEC_HEAT,PERIOD,N24,MAXN2))
			if(LKofT=="T") {
				#update FLAY, RLAY, IC2, N1, plus all the T dependant parameters
				vals=cat(TI_table[i],float(upper.req.DENSITY),N2,float(upper.req.ConUp0),float(upper.req.ConUp1),float(upper.req.ConUp2),float(upper.req.ConUp3),float(N1struct.req.FLAY),float(N1struct.req.RLAY),float(N1struct.req.IC2),float(N1struct.req.N1),axis=x)
			} else {
				#if LKofT is F, still update N1, FLAY, RLAY, IC2, N2 and TI
				vals=cat(TI_table[i],float(upper.req.DENSITY),N2,0.,0.,0.,0.,float(N1struct.req.FLAY),float(N1struct.req.RLAY),float(N1struct.req.IC2),float(N1struct.req.N1),axis=x)
			}
			#insert the updated change cards dynamically
			tparams=text(0)
			for(j=1;j<=dim(vals)[1];j+=1) {
				if(part_num[j]==1) {
					if(vals[j]<1 && vals[j]>-1)	{
						tparams=cat(tparams,sprintf("1 %i %.3E '%s' /",index[j],vals[j],removelist[,j]),axis=y)
					} else {
						tparams=cat(tparams,sprintf("1 %i %.4f '%s' /",index[j],vals[j],removelist[,j]),axis=y)
					}
				} else if (part_num[j]==2) {
					tparams=cat(tparams,sprintf("2 %i %i '%s' /",index[j],vals[j],removelist[,j]),axis=y)
				}
	      if(v==1) printf("YES %s=%f\n",removelist[,j],vals[j])
			}
			params=cat(params,tparams,"0/",axis=y)
    }
    params=cat(params,"0/",axis=y)

    #Assemble and write the input file to the temporary directory
    input=cat(inp.header,inp.part1,inp.part2,inp.part3,inp.part4,inp.part5,inp.part6,params,axis=y)
    write(input,workdir+"/krc.inp",ascii,force=1)

		if($DV_OS=="mac") {
			cmd="chmod a+rwx "+workdir+"/"+krcprog+" ;"
		} else {
			cmd=""
		}

    #run krc on the input file we just generated.
    if(v>=1) {
      system("cd "+workdir+"; ln -s "+$DV_KRC_HOME+"/src/"+krcprog+" .; "+cmd+" ./"+krcprog+" < "+$DV_SCRIPT_FILES+"/krc_support/fake_krc344 2>&1 | tee -a "+workdir+"/krc.log")
      log=read_lines(workdir+"/krc.log")
    } else {
      log=syscall("cd "+workdir+"; ln -s "+$DV_KRC_HOME+"/src/"+krcprog+" .; "+cmd+" ./"+krcprog+" < "+$DV_SCRIPT_FILES+"/krc_support/fake_krc344 > /dev/null 2>&1")
    }

		#make sure krc ran appropriately and created a bin5 file
		if(fexists(workdir+"/outdata.bin."+K4OUT)==0) {
			printf("KRC failed to run for some reason\n")
			printf("Returning the runtime log\n")
			return(log)
		}

		#get the multicase input
		verbose=0
    ret=process_bin52(workdir+"/outdata.bin."+K4OUT,raw=0,hour=hour,ls=ls,one=1,TUN8=TUN8,JD=JD,GD=GD)
    verbose=1

    #create the temperature lookup table
		cases=grep(get_struct_key(ret),"case")
		ncases=length(cases)
    for(i=1;i<=ncases;i+=1) {
      T_table[i]=get_struct(ret,cases[,i]).tsurf
    }

		#remove bad values (e.g. 0)
		TI_table=extract(TI_table,T_table)
		T_table=extract(T_table,T_table)

		if(WRITE=="T"){
      write(T_table,"~/Desktop/T_Table.ascii",ascii,force=1)
      write(TI_table,"~/Desktop/TI_Table.ascii",ascii,force=1)
    }

TI = T*0.                                                                       #Create a TI Array with same dimension as T
for(TI_i=1;TI_i<=dim(T)[1];TI_i+=1){                                            #Loop X AXIS
if(TI_i%(dim(T)[1]/10)==0){                                                     #Multiple of 10%
	bufff = (int(1 + 100*TI_i/dim(T)[1]))
	printf("%i%%\n",bufff)
}
for(TI_j=1;TI_j<=dim(T)[2];TI_j+=1){                                            #Loop Y AXIS
for(TI_k=1;TI_k<=dim(T)[3];TI_k+=1){                                            #Loop Z AXIS

if(T[TI_i,TI_j,TI_k] > 0.){

		if(HasValue(T_Tol)==0)         T_Tol = 1.                                   #Frost Temperature tolerance in lookup table
		T_table[where T_table < 0.]    = -32768.

		if(min(T_table,ignore=-32768.) > T[TI_i,TI_j,TI_k]){
		  TI[TI_i,TI_j,TI_k] = -300                                                    #T is too cold for the lookuptable
		} else if(max(T_table) < T[TI_i,TI_j,TI_k]){
		  TI[TI_i,TI_j,TI_k] = -400                                                    #T is too warm for the lookuptable
		} else {

		#Determine whether LuT contains frosted or near frosted cases
		  Buffer                        = T_table
		  Buffer[where abs(T_table-min(T_table,ignore=-32768.))<=T_Tol] = -32768.   #All the LuT values near min(LuT) are assigned Ignore
		  NUM                           = int(ccount(Buffer,1)[2])                  #Number of Usable LuT points, assuming points above 1K are usable
		  if(NUM >= 4){                                                             #If 4 LuT values are usable, proceed with fit
		  SORT                          = abs(Buffer-T[TI_i,TI_j,TI_k])                #Calculates distance between T and LuT Values
		  SORT[where Buffer == -32768.] =  32768.
		  LuT                           = cat(float(TI_table),float(SORT),float(T_table),axis=y)
		  SORT                          = sort(LuT,by=LuT[,2,])
		    if(SORT[1,2,1]*SORT[2,2,1]<0){                                          #Linear fit if non-monotonic LuT
		    TI[TI_i,TI_j,TI_k]                          = fit(x=SORT[:4,3,1]-T[TI_i,TI_j,TI_k],y=SORT[:4,1,1],"linear",plot=0)[1]
		  } else {                                                                  #Quadratic fit if monotonic LuT
		    TI[TI_i,TI_j,TI_k]                         = fit(x=SORT[:4,3,1]-T[TI_i,TI_j,TI_k],y=SORT[:4,1,1],"quad",plot=0)[1]
		      if((TI[TI_i,TI_j,TI_k] < min(SORT[:4,1,1]))||(TI[TI_i,TI_j,1] > max(SORT[:4,1,1]))){               #first TI interpolation not OK; lower or higher than selected LuT points, redo with linear fit
		      TI[TI_i,TI_j,TI_k]                       = fit(x=SORT[:4,3,1]-T[TI_i,TI_j,TI_k],y=SORT[:4,1,1],"linear",plot=0)[1]
		      }
		    }
		  } else {
		  TI[TI_i,TI_j,TI_k] = -600
		  }                                                                         #LuT has less than 4 usable values
		}

		if((HasValue(TI_Guess_PCT)==1)&&(HasValue(TI_Guess)==1)){                   #Poor TI Guess          => -200 Poor Guess
		  TI[where (TI[TI_i,TI_j,TI_k] < TI_Guess*(1.-TI_Guess_PCT)) || (TI[TI_i,TI_j,TI_k] > TI_Guess*(1.+TI_Guess_PCT))]=-200
		}

		if((HasValue(TI_Guess_PCT)==1)&&(HasValue(TI_Guess)!=1)){                   #Bad Input (user error) => -100
		  TI[TI_i,TI_j,TI_k] = -100.
		  TI_Guess = 0.
		}

		#check to see if we produced a TI                                           #-500 Complete Fail
		if(HasValue(TI[TI_i,TI_j,TI_k]) != 1){
		  TI[TI_i,TI_j,1] = -500.
		}

		if((dim(T)[1]==1)&&(dim(T)[2]==1)&&(dim(T)[3]==1)){                         #Only print screen if signle value
		#print the values we interpolate for:
		if(TI[TI_i,TI_j,TI_k]>0)                             printf("Fitting for TI values: %.1f to %.1f\n",min(SORT[:4,1,1]),max(SORT[:4,1,1]))
		if(TI[TI_i,TI_j,TI_k]>0)                             printf("    with temperatures: %.2fK to %.2fK\n",min(SORT[:4,3,1]),max(SORT[:4,3,1]))
		if((TI[TI_i,TI_j,TI_k]>0)&&(HasValue(TI_Guess)))     printf("    and a TI guess of: %.1f Kieffer\n",TI_Guess)
		if((TI[TI_i,TI_j,TI_k]>0)&&(HasValue(TI_Guess_PCT))) printf("    and a tolerance on TI of: %.1f Kieffer \n",TI_Guess*TI_Guess_PCT)
		if(TI[TI_i,TI_j,TI_k]==-100)                         printf("FLAG: No TI_Guess provided by user, despite TI_Guess_PCT entered\n")
		if(TI[TI_i,TI_j,TI_k]==-200)                         printf("FLAG: TI_Guess does not meet proximity criterion\n")
		if(TI[TI_i,TI_j,TI_k]==-300)                         printf("FLAG: User-provided temperature (%.1fK) lower or too close to the lowest lookup Table value (%.1fK)\n",T[TI_i,TI_j,TI_k],min(T_table,ignore=-32768.))
		if(TI[TI_i,TI_j,TI_k]==-400)                         printf("FLAG: User-provided temperature (%.1fK) higher or too close to the highest lookup Table value (%.1fK)\n",T[TI_i,TI_j,TI_k],max(T_table))
		if(TI[TI_i,TI_j,TI_k]==-500)                         printf("FLAG: Thermal Inertia retrieval failed\n")
		if(TI[TI_i,TI_j,TI_k]==-600)                         printf("FLAG: No enough non-frosted cases in the lookup Table \n")
		printf("\n")
	  }
}                                                                               #If T != 0 condition
}                                                                               #Loop X Axis
}                                                                               #Loop Y Axis
}                                                                               #Loop Z Axis

	  #return some ancillary data
    if(anc==1) {
      out              = {}
      out.TI           = TI
      out.TI_table     = TI_table_orig
      out.T_table      = T_table
			out.T_table_orig = T_table_orig
      out.T=T
    } else {
  	  #clean up
 			if(KEEP != "T") syscall("rm -rf "+workdir+"/*")                           #KEEP FOR DEBUG
			if($DV_OS=="mac") {
			  if(KEEP != "T") syscall("rmdir "+workdir)
			  if(KEEP != "T") syscall("rm -rf "+workdir+"/*")                         #KEEP FOR DEBUG
			}
			return(TI)
    }
  }

  #if the user wants all the ancillary data then generate it
  #this contains the running original input file, change cards,
  #all small parts, logs, an the print file.
  if(anc==1) {
    out.anc={}
		out.anc.porb=porb
		out.anc.N1struct=N1struct
		out.anc.upper=upper
		out.anc.lower=lower

    #return the full input file
    out.anc.input=input

    #return the change cards
    out.anc.change_cards=params
    out.anc.values={}

    #Parse and clean up the key_value pairs into a single structure
    #This can't be done earlier because the order/count needs to be preserved
    for(i=1;i<=length(key.part1.key);i+=1) {
      if(eval("HasValue("+key.part1.key[,i]+")==1")) {
        add_struct(out.anc.values,name=key.part1.key[,i],value=eval(key.part1.key[,i]))
      } else {
        add_struct(out.anc.values,name=key.part1.key[,i],value=key.part1.value[,i])
      }
    }
    for(i=1;i<=length(key.part2.key);i+=1) {
      if(eval("HasValue("+key.part2.key[,i]+")==1")) {
        add_struct(out.anc.values,name=key.part2.key[,i],value=eval(key.part2.key[,i]))
      } else {
        add_struct(out.anc.values,name=key.part2.key[,i],value=key.part2.value[,i])
      }
    }
    for(i=1;i<=length(key.part3.key);i+=1) {
      if(eval("HasValue("+key.part3.key[,i]+")==1")) {
        add_struct(out.anc.values,name=key.part3.key[,i],value=eval(key.part3.key[,i]))
      } else {
        add_struct(out.anc.values,name=key.part3.key[,i],value=key.part3.value[,i])
      }
    }

    #return other output
    out.anc.values.latitude=inp.part4
    out.anc.values.elevation=inp.part5
    out.anc.values.orbit=inp.part6
    out.anc.parts=inp

    #return the log and print data
    out.anc.log=log

    #keep the raw data too
    if(HasValue(T)!=0) {
			out.anc.raw_data=ret
		}

		#get and return the krc prt
    if(HasValue(prt)==0) {
			prt=read_lines(workdir+"/krc.prt")
		}
    out.anc.prt=prt
	}

  # Clean up the mess that we've created
  if(KEEP != "T") syscall("rm -rf "+workdir+"/*")                               #KEEP FOR DEBUG

	if(stability==1 && HasValue(T)==0) {
		out.stability=stability_flag_krc(out,TFROST)
	}

  #return the output
  out.depth           = translate(N1struct.layer.m.depth,from=z,to=y)
  N1struct.layer.tmin = out.layer.tmin
  N1struct.layer.tmax = out.layer.tmax
  out.layer           = N1struct.layer

  if(LMST=="T"){
    Resampled_out=ltst2lmst(out.ls,out.tsurf,out.time)                          #ltst2lmst() can also resample .time, but that would be too confusing for a user here
		out.tsurf_LMST={}
		out.tsurf_LMST=Resampled_out.TLMST                                          #Surface temperatures corresponding to .time in LMST
	}

return(out)
}


define krc_process_input(usage,updatekrcfunc) {

  if($ARGC==0) {
    printf("Parse and return the input structure from a krc input file\n")
    printf("$1=path to the input file (generally master.inp)\n\n")
    printf("c.edwards\n\n")
    return(null)
  }

  if(HasValue(usage)==0) usage=0

  #This is the input file handling code.
  #This assumes the user just provided the base krc directory
  #in the folowing section we will parse out the master.inp file
  #and generate a list of key/value pairs for which we can add
  #a bunch of change cards.
  master=read_lines($1)

  inp={}
  #first 2 lines of the input file
  start1=maxpos(master==grep(master,"ALBEDO")[,1])[2]

  #hard to tell if this header will always be the same
  inp.header=master[,:start1-1]

  #floating point variables (#1 in change cards) from the input file
  end1=maxpos(master==grep(master,"N1")[,1])[2]-1
  inp.part1=master[,start1:end1]

  key={}
  if(usage==1){
    printf("\nReal Value Parameters (Values from default input file)\n")
    printf("####################################################################################\n")
  }
  key.part1=krc_get_key_value(inp.part1, print=usage)

  #integer variables (#2 in change cards) from the input file
  start2=end1+1
  end2=maxpos(master==grep(master,"LP1")[,1])[2]-1
  inp.part2=master[,start2:end2]

  if(usage==1){
    printf("Integer Value Parameters (Values from default input file)\n")
    printf("####################################################################################\n")
  }
  key.part2=krc_get_key_value(inp.part2, print=usage)

  #boolean variables (#3 in change cards) from the input file
  start3=end2+1
  end3=maxpos(master==grep(master,"Latitudes")[,1])[2]-1
  inp.part3=master[,start3:end3]

  if(usage==1){
    printf("Boolean Parameters (Values from default input file)\n")
    printf("####################################################################################\n")
  }
  key.part3=krc_get_key_value(inp.part3, print=usage)

  #latitudes from the input file (with dummy values)
  start4=end3+1
  end4=maxpos(master==grep(master,"Elevations")[,1])[2]-1
  inp.part4=cat(master[,start4],sprintf("%7.2f",-32768),axis=y)

  #elevation section of the input file (with dummy values)
  start5=end4+1
  end5=maxpos(master==grep(master,"=RUNTIME")[,1])[2]-1
  inp.part5=cat(master[,start5],sprintf("%7.2f",-32768),axis=y)

  #crazy orbital parameters from the input file
  start6=end5+1
  end6=start6+6
  inp.part6=master[,start6:end6]

  out={}
  out.inp=inp
  out.key=key

	if(HasValue(updatekrcfunc)==1) {
		keys=cat(key.part1.key,key.part2.key,key.part3.key,axis=y)

		#change this line for updating krc parameter keys
		lib_version=read_lines($DV_KRC_HOME+"/../dvrc/krc2.dvrc")

		tmp=grep(lib_version,"define krc\\(")
		tmp=strsub(tmp,"define krc\\(","")
		tmp=strsub(tmp,"\\) ","")
		tmp=tmp[:length(tmp[,1])-1,1]
		tmp=strsplit(tmp,delim=",")
		albpos=maxpos(tmp=="ALBEDO")[2]
		pastkeys=tmp[,albpos:]

		pastkeys=sort(pastkeys)
		korder=keys
		keys=sort(keys)

		pastkeystruc={}
		keystruc={}

		for(i=1;i<=length(pastkeys);i+=1) {
			add_struct(pastkeystruc,name=pastkeys[,i],val=0)
		}

		for(i=1;i<=length(keys);i+=1) {
			add_struct(keystruc,name=keys[,i],val=0)
		}

		for(i=1;i<=length(pastkeys);i+=1) {
			for(j=1;j<=length(keys);j+=1) {
				if(pastkeys[,i]==keys[,j]) {
					remove_struct(pastkeystruc,pastkeys[,i])
				}
			}
		}

		for(i=1;i<=length(keys);i+=1) {
			for(j=1;j<=length(pastkeys);j+=1) {
				if(keys[,i]==pastkeys[,j]) {
					remove_struct(keystruc,keys[,i])
				}
			}
		}

		printf("\nKRC Input File Report:\n")
		printf("Current Keys\n")
		if(length(keystruc)!=0) {
			tkeys=get_struct_key(keystruc)
			for(i=1;i<=length(keystruc);i+=1) {
				printf("ERROR:%s\n",tkeys[,i])
			}
		} else {
			printf("FOUND NO MISSING/ADDED KEYS\n")
		}

		printf("\nExisting Keys\n")
		if(length(pastkeystruc)!=0) {
			tkeys=get_struct_key(pastkeystruc)
			for(i=1;i<=length(pastkeystruc);i+=1) {
				printf("ERROR:%s\n",tkeys[,i])
			}
		} else {
			printf("FOUND NO MISSING/ADDED KEYS\n")
		}

		printf("\n\n")

		out=""
		for(i=1;i<=length(korder);i+=1) {
			if(i==1) {
				out=sprintf("%s",korder[,i])
			} else {
				out=cat(out,sprintf(",%s",korder[,i]),axis=x)
			}
		}
	}

  return(out)
}



define krc_get_key_value(print) {

  if($ARGC==0) {
    printf("\n\nGet a set of keyword and value pairs from the KRC input file\n")
    printf("$1=column spaced text array\n")
    printf("print = print the results cleanly\n")
    printf("c.edwards\n\n")
    reutrn(null)
  }

  if(HasValue(print)==0) {
    print=0
  }

  #take the input of a column spaced text array
  master=$1
  part_key=text(0)
  part_val=text(0)

  #split the string by a space
  master=strsplit(master,delim=" ")

  #parse the giant strsplit struct/text array to extract the keywords
  for(i=1;i<=length(master);i+=2) {
    for(j=1;j<=length(master[i]);j+=1) {
      if(master[i][,j]!="") {
        if(master[i][1,j]=="[") {
          master[i][,j]=master[i][2:,j]
        }
        part_key=cat(part_key,master[i][,j],axis=y)
      }
    }

    #search the keywords for their respective value pairs
    for(j=1;j<=length(master[i+1]);j+=1) {
      if(master[i+1][,j]!="") {
        part_val=cat(part_val,master[i+1][,j],axis=y)
      }
    }
  }

  #print the keyword data for krc() help
  if(print==1) {
    for(i=1;i<=length(part_key);i+=1) {
     #printf("%s,",part_key[,i])
     printf("%-9s%-13s",part_key[,i],"= "+part_val[,i])
     #printf("%-9s",part_key[,i])
     if(i%4==0 && i!=length(part_key)) {
       printf("\n")
     }
    }
  printf("\n\n")
  }
  return({key=part_key,value=part_val})
}

define krc_evalN1(){
  if($ARGC == 0){
    printf (" Calculates the minimum number of layers required given the number of years the model runs \n")
    printf (" Calculates the content of ZoneX.tab \n")
    printf (" Return an Array \n")
    printf (" $1  = RLAY, Layer thickness ratio \n")
    printf (" $2  = FLAY, First layer thickness (in skin depths) \n")
    printf (" $3  = INERTIA, Surface material thermal inertia \n")                                  #Top Inertia Value
    printf (" $4  = SPEC_HEAT, Surface material specific heat \n")
    printf (" $5  = DENSITY, surface material density \n")
    printf (" $6  = DELJUL, delta julian date to increment by (Default = 1.9083 \n")
    printf (" $7  = N5, number of \"seasons\" to run (Default = 1080) \n")
    printf (" $8  = JDISK, start \"season\" to output (Default = 721) \n")
    printf (" $9  = MAXN1, Maximum number of layers KRC can accept \n")
    printf (" $10 = PERIOD, Length of solar day in days (of 86400 seconds) \n")
    printf (" $11 = INERTIA2, bottom material thermal inertia \n")                                  #Depth Inertia Value
    printf (" $12 = SpHeat2, bottom material specific heat \n")
    printf (" $13 = DENS2, bottom material density \n")
    printf (" $14 = THICK, Top Material Thickness in m or H parameter if < 0 \n")                   #if THICK > 0. => 2 material regolith, THICK is the top material thickness
                                                                                                    #if THICK < 0. => Exponential trend, THICK is the H parameter (see Hayne)
                                                                                                    #if THICK = 0. => Homogeneous material
    printf (" $15 = LKofT, temperature-dependence \n")
    printf ("s.piqueux 5/4/17\n\n")
    return(null)
  }

  RLAY          = float($1)
  FLAY          = float($2)
  INERTIA       = float($3)
  SPEC_HEAT     = Cp1        = float($4)
  DENSITY       = DENS1      = float($5)
  DELJUL        = float($6)
  N5            = int($7)
  JDISK         = int($8)
  MAXN1         = N1         = int($9)
  PERIOD        = float($10)
  INERTIA2      = float($11)
  SPEC_HEAT2    = Cp2        = float($12)
  DENSITY2      = DENS2      = float($13)
  THICK         = float($14)
  LKofT         = $15
  Min_Num_Layer = 25
  Res           = 10

if(sum(dim(THICK))==3){                                                         #Not a Table provided
    ###Calculate Default Mesh Properties
        if(THICK==0){
          INERTIA2   = INERTIA
          SPEC_HEAT2 = SPEC_HEAT
          DENSITY2   = DENSITY
        }

    #Number of Seconds in 1 Year
    PY = 3600*24*DELJUL*((N5-JDISK)+1)
    #Length of the solar day in seconds
    PD = PERIOD*86400

    #Seasonal Skin Depth in meters
    SSD1_m    = (INERTIA /(DENSITY *SPEC_HEAT ))*sqrt(PY/3.14159)
    SSD2_m    = (INERTIA2/(DENSITY2*SPEC_HEAT2))*sqrt(PY/3.14159)
    SSD_max_m = max(cat(SSD1_m,SSD2_m,axis=x))

    #Diurnal Skin Depth in meters
    DSD1_m = (INERTIA /(DENSITY *SPEC_HEAT ))*sqrt(PD/3.14159)
    DSD2_m = (INERTIA2/(DENSITY2*SPEC_HEAT2))*sqrt(PD/3.14159)

    #Calculate the number of years the model runs
    NSKIN = N5/(N5-JDISK+1)

    #We want as many seasonal skin depths of soil as there are years
    #Calculate The total Depth required, assuming 1 material, homogeneous, driven by highest INERTIA
    DEPTH_m = NSKIN * max(cat(SSD1_m,SSD2_m,axis=x))
    if(DEPTH_m > 25.){                                                          #Force N1 to be smaller than 25. meters to avoid very deep models
        DEPTH_m  = 25.
    }

    if(THICK == 0.){                                                            #CASE 1: NO LAYEREING
      LZONE      = "F"
      FLAY2      = FLAY
      IC2        = 999.
    }

    if(THICK > 0.){                                                             #CASE 2: LAYERING
      LZONE      = "F"
    }

    if((THICK <= (FLAY * DSD1_m * RLAY))&&(THICK > 0.)){                        #CASE 2a: top mesh element is smaller than default low TI element thickness
      FLAY2      = THICK/(DSD1_m*RLAY)
      IC2        = 3
      LZONE      = "F"
    }

    if((THICK > (FLAY * DSD1_m * RLAY))&&(RLAY > 1.)){                          #CASE 2b: top material thickness is larger than FLAY * DSD1 * RLAY, calculate number of elements
      LZONE      = "F"
      IC2        = int(logb(RLAY,1-THICK*(1-RLAY)/(DSD1_m*FLAY*RLAY))) + 4      #Not sure why + 4
      FLAY_Step  = (FLAY - FLAY*0.01)/(Res - 1)
      FLAY_Table = create(Res+1,1,1,start=FLAY*0.01,step=FLAY_Step,format=double)
      Mesh       = create(Res+1,IC2-2,1,start=0.,format=double,step=0.)         #Double Check IC2-2 (was used to be n)
      Mesh[,1,1] = FLAY_Table
      Bot_Thick  = create(Res+1,1,1,start=0.,format=double,step=0.)
        for(i=2;i<=dim(Mesh)[2];i+=1){
          Mesh[,i,1] = Mesh[,i-1,1]*RLAY                                        #Mesh Element thickness in skin depth
        }
      Bot_Thick  = sum(Mesh,axis=y)*DSD1_m                                      #Bottom thickness in m
      FIT        = fit(x=Bot_Thick-THICK,y=FLAY_Table,type="linear",plot=0)
      FLAY2      = FIT[1]
    }

    if((THICK > (FLAY * DSD1_m * RLAY))&&(RLAY == 1.)){                         #CASE 2c: RLAY = 1, top material thickness is larger than than FLAY * DSD1 * RLAY
      IC2        = int(THICK/(FLAY*DSD1_m*RLAY)) + 3                            #IC   number of top elements + 1 (because of virtual layer) + 1 (indicates beginning of bot material)
      FLAY2      = (THICK/DSD1_m)/(IC2 - 2)                                     #Double check using .prt file ####################################################################################
    }

    if(HasValue(FLAY2) == 0){                                                   #Could Happen when THICK < 0.
      FLAY2 = FLAY
    }
    if(HasValue(IC2) == 0){                                                     #Could Happen when THICK < 0.
      IC2 = 999
    }


#
#GENERATE PROPERTIES WITH DEPTH; REPLICATES .prt FILE
#
LAYER                = create(1,1,N1,start=1,format=int)                                #[1], layer number (1 is virtual)
THICKNESS_D_Scale    = create(1,1,N1,start=FLAY2/RLAY,format=double)                    #[1], mesh element thickness in diurnal skin depth
CENTER_DEPTH_D_Scale = create(1,1,N1,start=-0.5 * THICKNESS_D_Scale ,format=double)     #[1], mesh element center depth, in diurnal skin depth
THICKNESS_m          = create(1,1,N1,start=THICKNESS_D_Scale * DSD1_m ,format=double)   #[m], mesh element thickness in meter
CENTER_DEPTH_m       = create(1,1,N1,start=CENTER_DEPTH_D_Scale * DSD1_m,format=double) #[m], mesh element center depth, in m
Conductiv            = create(1,1,N1,start=INERTIA^2/(SPEC_HEAT*DENSITY),format=double) #[W/m-K]
Density              = create(1,1,N1,start=DENSITY,format=double)                       #[kg/m^3]
Sp_Heat              = create(1,1,N1,start=SPEC_HEAT,format=double)                     #[J/kg]
Total_mass           = create(1,1,N1,start=0.,format=double)                            #[kg/m^2]
Z_T                  = create(1,1,N1,start=0.,format=double)                            #[m], depth where KRC reports the temperatures
Z_T_D                = create(1,1,N1,start=0.,format=double)                            #[1], depth where KRC reports the temperatures, in local DSD
SCALES               = create(1,1,N1,start=0.,format=double)                            #[m], Scales, i.e. diurnal skin depth
  for(i=2;i<=N1;i+=1){
    if(LAYER[1,1,i] < IC2){
      DSD  = DSD1_m
      DENS = DENSITY
      Cp   = SPEC_HEAT
      I    = INERTIA
    } else {
      DSD  = DSD2_m
      DENS = DENSITY2
      Cp   = SPEC_HEAT2
      I    = INERTIA2
    }
    LAYER[1,1,i]                = LAYER[1,1,i-1] + 1
    THICKNESS_D_Scale[1,1,i]    = THICKNESS_D_Scale[1,1,i-1]*RLAY
    CENTER_DEPTH_D_Scale[1,1,i] = CENTER_DEPTH_D_Scale[1,1,i-1] + 0.5 * (THICKNESS_D_Scale[1,1,i] + THICKNESS_D_Scale[1,1,i-1])
    THICKNESS_m[1,1,i]          = THICKNESS_D_Scale[1,1,i]*DSD
    CENTER_DEPTH_m[1,1,i]       = CENTER_DEPTH_m[1,1,i-1] + 0.5 * (THICKNESS_m[1,1,i] + THICKNESS_m[1,1,i-1])
    Conductiv[1,1,i]            = I^2/(DENS*Cp)
    Density[1,1,i]              = DENS
    Sp_Heat[1,1,i]              = Cp
    Total_mass[1,1,i]           = Total_mass[1,1,i-1] + Density[1,1,i] * THICKNESS_m[1,1,i]
    SCALES[1,1,i]               = DSD
    Z_T[1,1,i]                  = CENTER_DEPTH_m[1,1,i]                         #1: Surface T; 2: middle of 2nd layer etc.
    Z_T_D[1,1,i]                = CENTER_DEPTH_D_Scale[1,1,i]                   #1: Surface T; 2: middle of 2nd layer etc.

      if(((CENTER_DEPTH_m[1,1,i-1]>DEPTH_m)&&(i>=Min_Num_Layer))||(i>=MAXN1)){
        N1                      = i
        LAYER                   = LAYER[1,1,:i]
        THICKNESS_D_Scale       = THICKNESS_D_Scale[1,1,:i]
        CENTER_DEPTH_D_Scale    = CENTER_DEPTH_D_Scale[1,1,:i]
        THICKNESS_m             = THICKNESS_m[1,1,:i]
        CENTER_DEPTH_m          = CENTER_DEPTH_m[1,1,:i]
        Conductiv               = Conductiv[1,1,:i]
        Density                 = Density[1,1,:i]
        Sp_Heat                 = Sp_Heat[1,1,:i]
        Total_mass              = Total_mass[1,1,:i]
        SCALES                  = SCALES[1,1,:i]
        Z_T                     = Z_T[1,1,:i]
        Z_T_D                   = Z_T_D[1,1,:i]
      }                                                                         #Crop tables deeper than N1
  }                                                                             #for loop building table

if(THICK < 0.){                                                                 #CASE 3: H parameter
  IC2                  = 999
  LZONE                = "T"
  FLAY2                = 0.15                                                   #FLAY
  DSD                  = DSD1_m
  DENS                 = DENSITY
  Cp                   = SPEC_HEAT
  I                    = INERTIA
  LAYER                = create(1,1,N1,start=1,format=int)                                #[1], layer number (1 is virtual)
  THICKNESS_D_Scale    = create(1,1,N1,start=FLAY2/RLAY,format=double)                    #[1], mesh element thickness in diurnal skin depth
  CENTER_DEPTH_D_Scale = create(1,1,N1,start=-0.5 * THICKNESS_D_Scale ,format=double)     #[1], mesh element center depth, in diurnal skin depth
  THICKNESS_m          = create(1,1,N1,start=THICKNESS_D_Scale * DSD1_m ,format=double)   #[m], mesh element thickness in meter
  CENTER_DEPTH_m       = create(1,1,N1,start=CENTER_DEPTH_D_Scale * DSD1_m,format=double) #[m], mesh element center depth, in m
  Conductiv            = create(1,1,N1,start=INERTIA^2/(SPEC_HEAT*DENSITY),format=double) #[W/m-K]
  Density              = create(1,1,N1,start=DENSITY,format=double)                       #[kg/m^3]
  Sp_Heat              = create(1,1,N1,start=SPEC_HEAT,format=double)                     #[J/kg]
  Total_mass           = create(1,1,N1,start=0.,format=double)                            #[kg/m^2]
  Z_T                  = create(1,1,N1,start=0.,format=double)                            #[m], depth where KRC reports the temperatures
  SCALES               = create(1,1,N1,start=0.,format=double)                            #[m], Scales, i.e. diurnal skin depth
  Z_T                  = create(1,1,N1,start=0.,format=double)                            #[m], depth where KRC reports the temperatures
  Z_T_D                = create(1,1,N1,start=0.,format=double)                            #[1], depth where KRC reports the temperatures, in local DSD

    for(i=2;i<=N1;i+=1){
      LAYER[1,1,i]                = LAYER[1,1,i-1] + 1
      THICKNESS_D_Scale[1,1,i]    = THICKNESS_D_Scale[1,1,i-1]*RLAY
      CENTER_DEPTH_D_Scale[1,1,i] = CENTER_DEPTH_D_Scale[1,1,i-1] + 0.5 * (THICKNESS_D_Scale[1,1,i] + THICKNESS_D_Scale[1,1,i-1])
      THICKNESS_m[1,1,i]          = THICKNESS_D_Scale[1,1,i]*DSD
      CENTER_DEPTH_m[1,1,i]       = CENTER_DEPTH_m[1,1,i-1] + 0.5 * (THICKNESS_m[1,1,i] + THICKNESS_m[1,1,i-1])
      Conductiv[1,1,i]            = I^2/(DENS*Cp)
      Density[1,1,i]              = DENS
      Sp_Heat[1,1,i]              = Cp
      Total_mass[1,1,i]           = Total_mass[1,1,i-1] + Density[1,1,i] * THICKNESS_m[1,1,i]
      SCALES[1,1,i]               = DSD
      Z_T[1,1,i]                  = CENTER_DEPTH_m[1,1,i]                       #[m], depth where KRC reports the temperatures
      Z_T_D[1,1,i]                = CENTER_DEPTH_D_Scale[1,1,i]                 #1: Surface T; 2: middle of 2nd layer etc.

        if(((CENTER_DEPTH_m[1,1,i-1]>DEPTH_m)&&(i>=Min_Num_Layer))||(i>=MAXN1)){
          N1                      = i
          LAYER                   = LAYER[1,1,:i]
          THICKNESS_D_Scale       = THICKNESS_D_Scale[1,1,:i]
          CENTER_DEPTH_D_Scale    = CENTER_DEPTH_D_Scale[1,1,:i]
          THICKNESS_m             = THICKNESS_m[1,1,:i]
          CENTER_DEPTH_m          = CENTER_DEPTH_m[1,1,:i]
          Conductiv               = Conductiv[1,1,:i]
          Density                 = Density[1,1,:i]
          Sp_Heat                 = Sp_Heat[1,1,:i]
          Total_mass              = Total_mass[1,1,:i]
          SCALES                  = SCALES[1,1,:i]
          Z_T                     = Z_T[1,1,:i]
          Z_T_D                   = Z_T_D[1,1,:i]
        }                                                                       #Crop tables deeper than N1
    }                                                                           #for loop building table

  H                    = THICK
  COND1                = INERTIA^2/(DENSITY*SPEC_HEAT)
  COND2                = INERTIA2^2/(DENSITY2*SPEC_HEAT2)
  Col_1                = translate(THICKNESS_m,from=z,to=y)                        #Keep Default Meshing; thickness of each layer in m
  Col_2                = translate(DENS2 - (DENS2 - DENS1)*exp(Z_T/H),from=z,to=y) #Density
  Col_3                = translate(COND2 - (COND2 - COND1)*exp(Z_T/H),from=z,to=y) #Conductivity
  Col_4                = translate(Cp2 - (Cp2 - Cp1)*exp(Z_T/H),from=z,to=y)       #Specific Heat
  col_dim              = dim(Col_1)[2]-1                                           #when a table file is created (H parameter), there is no virtual layer necessary
  Col_1                = Col_1[,:col_dim]
  Col_2                = Col_2[,:col_dim]
  Col_3                = Col_3[,:col_dim]
  Col_4                = Col_4[,:col_dim]

    if(LKofT == "T"){                                                           #If Temperature-dependent properties, change top 2 zones
      Col_3[1,1,1]     = -1.                                                    #In this model, only the top 2 mesh elements are T_dep
      Col_3[1,2,1]     = -1.
      Col_4[1,1,1]     = 3.
      Col_4[1,2,1]     = 4.
    }
}                                                                               #Zone file


#process the output structure if thick is not an array
out                            = {}
out.req                        = {}
out.layer                      = {}
out.req.FLAY                   = float(FLAY2)                                   #New FLAY
out.req.RLAY                   = float(RLAY)                                    #RLAY
out.req.N1                     = int(N1)                                        #New N1
out.req.IC2                    = IC2
out.req.LZONE                  = LZONE
out.Depth                      = DEPTH_m                                        #Regolith thickness required, in m
out.thick                      = THICK                                          #Top material thickness, [m]
out.thermal_scales             = SCALES                                         #Material diurnal skin depth (Scale)

out.layer.Num                  = LAYER                                          #[1] Layer Number
out.layer.mass_burden          = Total_mass                                     #[kg/m^2], surface to bottom of the mesh element
out.layer.Cond                 = Conductiv                                      #[J/s/m/K], Mesh element conductivity
out.layer.Density              = Density                                        #[kg/m^3], Mesh element density
out.layer.Cp                   = Sp_Heat                                        #[J/kg/K], Mesh element specific heat

out.layer.m                    = {}                                             #Mesh Properties, in meters
out.layer.Scale                = {}                                             #Mesh Properties, in local skin depths

out.layer.m.thickness          = THICKNESS_m                                    #[m] Mesh element thickness
out.layer.m.center_depth       = CENTER_DEPTH_m                                 #[m] Depth at the center of the mesh element
out.layer.m.depth              = Z_T                                            #[m] Depth at the center of the mesh element EXCEPT 1st is surface (0m)

out.layer.Scale.thickness      = THICKNESS_D_Scale                              #[1] Mesh element thickness, in local DSD
out.layer.Scale.center_depth   = CENTER_DEPTH_D_Scale                           #[m] Depth at the center of the mesh element, in local DSD
out.layer.Scale.depth          = Z_T                                            #[m] Depth at the center of the mesh element EXCEPT 1st is surface (0m)
out.layer.Scale.DSD1           = DSD1_m                                         #Top material Diurnal Skin Depth, in m
out.layer.Scale.DSD2           = DSD2_m                                         #Lower material Diurnal Skin Depth, in m
out.layer.Scale.SSD1           = SSD1_m                                         #Top material Seasonal Skin Depth, in m
out.layer.Scale.SSD2           = SSD2_m                                         #Lower material Seasonal Skin Depth, in m


if(THICK<0) {
  out.H          = -H                                                           #Flags an exponential configuration
  out.Zone       = {}
  out.Zone.Col_1 = Col_1                                                        #Mesh (or Zone) Element Thickness [m]
  out.Zone.Col_2 = Col_2                                                        #Mesh (or Zone) Element Density [kg/m^3]
  out.Zone.Col_3 = Col_3                                                        #Pointer for Column 4, or conducticity [j/kg/K/s]
  out.Zone.Col_4 = Col_4                                                        #Thermal Conductivity and Specific heat from Materials 1    and 2
  out.Zone.inp   = text()
  out.Zone.inp   = cat(out.Zone.inp,"C_END",axis=y)
    for(i=1;i<=dim(Col_1)[2];i+=1) {
      out.Zone.inp = cat(out.Zone.inp,sprintf("%.4f %.1f %.4f %.1f",Col_1[,i],Col_2[,i],Col_3[,i],Col_4[,i]),axis=y)
    }
  out.Zone.inp   = cat(out.Zone.inp,"0 0 0 0",axis=y)
}
}

if(dim(THICK)[1]==4 && dim(THICK)[2]>=3 && dim(THICK)[3]==1) {                  #CASE 4: Table file provided
  out                            = {}
  out                            = {}
  out.req                        = {}
  out.layer                      = {}
  out.layer.m                    = {}
  out.layer.m.depth              = -999.                                        #There is no way to predict the meshing from the zones; assign -999.
  out.req.FLAY                   = float(FLAY)                                  #New FLAY
  out.req.RLAY                   = float(RLAY)                                  #RLAY
  out.req.N1                     = 50                                           #Very hard to predict how many layers are needed when zones are present; assigns 50
  out.req.IC2                    = 999
  out.req.LZONE                  = "T"
  out.input_array                = THICK
  out.Zone                       = {}
  out.Zone.inp                   = text()
  out.Zone.inp                   = cat(out.Zone.inp,"C_END",axis=y)
    for(i=1;i<=dim(THICK)[2];i+=1) {
      out.Zone.inp = cat(out.Zone.inp,sprintf("%.4f %.1f %.4f %.1f",THICK[1,i],THICK[2,i],THICK[3,i],THICK[4,i]),axis=y)
    }
  out.Zone.inp                   = cat(out.Zone.inp,"0 0 0 0",axis=y)
}

return(out)
}



define krc_evalN2(){
  if($ARGC == 0){
    printf (" Calculates the minimum number of times per day to consider for N2 \n")
    printf (" Returns an integer\n\n")
    printf (" $1 = FLAY, First layer thickness (in skin depths) \n")
    printf (" $2 = INERTIA, Thermal inertia of the top material at 220K \n")
    printf (" $3 = DENSITY, Density of the top material \n")
    printf (" $4 = SPEC_HEAT, Specific heat of the top material \n")
    printf (" $5 = PERIOD, Length of solar day in days (of 86400 seconds) \n")
    printf (" $6 = N24, # 'hours' per day stored, should be divisir of  N2 (lim MAXNH) \n")
    printf (" $7 = MAXN2, maximum # of 'hours' per day \n")
    printf ("s.piqueux 8/9/13\n\n")
    return(null)
  }

  FLAY = float($1)
  INERTIA = float($2)
  DENSITY = float($3)
  SPEC_HEAT = float($4)
  PERIOD = float($5)
  N24 = float($6)
  MAXN2 = float($7)

  #Number of seconds in a Martian day
  PD = PERIOD*86400

  #Diurnal Skin Depth in meters
  DSD = (INERTIA/(DENSITY*SPEC_HEAT))*sqrt(PD/3.14159)

  #First Layer Thickness in meters
  FLAYM = FLAY*DSD

  #The minimum time step cannot be larger than DEL_T Kieffer 2013 Section 103
  ###DEL_T MAY NEED TO BE MORE CONSERVATIVE IF WE FIND THAT THE STABILITY IS NOT GARANTEED
  DEL_T = 0.8*(FLAYM^2*DENSITY^2*SPEC_HEAT^2)/(2*INERTIA^2)

  #Minimum number of time steps in a day
  Num_time_step = int(PD/DEL_T)+1

  #Minimum number of time step in a day, adjusted for N24
  if (N24 > Num_time_step) N2 = N24

  #Minimum number of time step in a day, adjusted for N24
  if (N24 <= Num_time_step) N2 = (int(Num_time_step/N24)+1)*N24

  #Makes sure that N2 is smaller than MAXN2
  if (N2 > MAXN2) N2 = MAXN2

  return(N2)
}



define stability_flag_krc(){
	if($ARGC == 0){
		printf (" Flags suspicious output surface temperatures \n")
		printf (" Returns an integer, 0 noting suspicious detected; 1 possible issue \n")
		printf (" $1 = davinci output file for a krc run \n")
		printf (" $2 : TFROST \n")
		printf ("s.piqueux 8/8/13\n\n")
		return(null)
	}

	Data = $1
	TFROST = $2

	FLAG = {}
	FLAG.TFROST = 0.
	FLAG.BUMP = 0.
	FLAG.BREAK= 0.
	FLAG.SLOPE= 0.

	T = Data.data.tsurf[1,1,]

	#FIRST FLAG: TEMPERATURES BELOW FROST POINT
	if(min(T) < TFROST) FLAG.TFROST = 1.

	#2ND FLAG: TEMPERATURE BUMPS NOT ASSOCIATED WITH TFROST
	for(i=2;i<=dim(T)[3]-2;i+=1){
		#+-+-
		if((T[1,1,i]>T[1,1,i-1])&&(T[1,1,i]>T[1,1,i+1])&&(T[1,1,i+1]<T[1,1,i+2])) FLAG.BUMP= 1.

		#-+-+
		if((FLAG.BUMP==0.)&&(T[1,1,i]<T[1,1,i-1])&&(T[1,1,i]<T[1,1,i+1])&&(T[1,1,i+1]>T[1,1,i+2])) FLAG.BUMP= 1.

		#Slope Breaks
		Slope_1 = T[1,1,i]-T[1,1,i-1]
		Slope_2 = T[1,1,i+1]-T[1,1,i]
		Slope_3 = T[1,1,i+2]-T[1,1,i+1]
		if((Slope_1>Slope_2)&&(Slope_2<Slope_3)) FLAG.SLOPE = 1.
		if((FLAG.SLOPE==0.)&&(Slope_1<Slope_2)&&(Slope_2>Slope_3)) FLAG.SLOPE = 1.
	}

	return(FLAG)
}



define porb(epoch,anc,v,force) {
	if($ARGC==1) {
		if(type($1)=="STRING") {
			if($1=="updatedefaults") {
				update="updatedefaults"
			} else {
				update="dontupdate"
			}
		} else {
			update="dontupdate"
		}
	}

	if($ARGC==0) {
		printf("\nRun PORB to calculate an appropriate rotation matrix for use in krc\n")
		printf("\t$1=body - planetary body name/Horizons id or generic_porb/exo_porb generated structure\n\n")
		printf("\tName Formatting:\n")
		printf("\t\tFor a major body (e.g. \"Mars\"), simply enter the body name\n")
		printf("\t\tFor a satellite (e.g. \"Phobos\"), simply enter the body name\n")
		printf("\t\tFor an asteroid (e.g. \"Bennu\"), either enter the body name or JPL Horizon id\n")
		printf("\t\tFor a comet, enter the full name (e.g. \"1P-Halley\") to avoid ambiguity or the JPL Horizon id\n\n")
		printf("Options:\n")
		printf("\tepoch=fraction of the century for start date (Default = 0.10 -> 2010)\n")
		printf("\tforce=force running of PORB (default=0)\n\n")
		printf("c.edwards 4/1/2020\n")
		return(null)
	}

	if(HasValue(anc)==0) anc=0
	if(HasValue(v)==0) v=0
	if(HasValue(force)==0) force=0

	out={}
	out.rot_per_flag=0

	if(update!="updatedefaults") {
		#setup the output
		out.krc={}

		if(type($1)=="STRUCT") {
			bodystruct={}
			bodystruct.body_type="Generic"
			XXX = $1                                                                #### If structure has an obliquity value, the body is an exoplanet
			if(hasvalue(XXX.Obliq)==1){
				bodystruct.body_type="Exoplanet"                                      #### If structure has an obliquity value, the body is an exoplanet
			}
		} else {
			bodystruct=porb_type($1)
	 	}

		#if we are dealing with a planet or a moon
		if(bodystruct.body_type=="Planet" || bodystruct.body_type=="Satellite") {
			body=bodystruct.name
			if(bodystruct.body_type=="Satellite") {
				parentbody=bodystruct.parent_body
			} else {
				parentbody=body
			}

			#check to see if we've already run this in a standard case
			testfile=$DV_SCRIPT_FILES+"/krc_support/porb_defaults/"+body+".porb.hdf"
			if(fexists(testfile) && force!=1) {
				printf("Found Default File: $DV_SCRIPT_FILES/krc_support/porb_defaults/%s\n",basename(testfile))
				verbose=0
				default=read(testfile)
				verbose=3
				return(default)
			}

			if(force==1) {
				printf("Forcing PORB run\n")
			}

			#set the epoch to deal with in fractions of a century
			if(HasValue(epoch)==0) {
				epoch=0.10
			}

			#setup the working directory
			workdir=$TMPDIR+"/porb"
			syscall("mkdir -p "+workdir)

			#hugh supplies thes files tailored to KRC input...maybe we should re-do them
      verbose=0
			global(krc_standish)
			standish=krc_standish
			global(krc_spinaxis)
			spinaxis=krc_spinaxis
			global(krc_otherparams)
			otherparams=krc_otherparams

      verbose=1
			#look for the comment line
			standish_END=maxpos(standish[:length("C_END")]=="C_END")[2]

			#find the appropriate body lines
			if(sum(standish[:length(parentbody),standish_END:]==parentbody)!=1) {
				printf("Error: Did not find %s in the available planets\n",parentbody)
				return(null)
			} else {
				parentbodypos=maxpos(standish[:length(parentbody),standish_END:]==parentbody)[2]+standish_END-1
				parentbodylines=cat("C_END",standish[,parentbodypos:parentbodypos+1],axis=y)
			}

			#look for the comment line
			spin_END=maxpos(spinaxis[:length("C_END")]=="C_END")[2]

			#find the appropriate spin axis lines
			if(sum(spinaxis[:length(body),spin_END:]==body)!=1) {
				printf("Error: Did not find %s in the spin axis file\n",body)
				return(null)
			} else {
				spinpos=maxpos(spinaxis[:length(body),spin_END:]==body)[2]+spin_END-1
				spinlines=cat("C_END",spinaxis[,spinpos],axis=y)
			}

			#get some other planetary parameters
			parampos=maxpos(otherparams.name==body)[2]
			rot_per=otherparams.orbit_period[,parampos]
			period=otherparams.sideral_period[,parampos]*365.25636
			out.krc.GRAV=otherparams.gravity[,parampos]

			#set the amospheric conditions
			out.krc.PTOTAL=otherparams.ptotal[,parampos]
			out.krc.ARC2_G0=otherparams.arc2_pho[,parampos]
			out.krc.DUSTA=otherparams.dusta[,parampos]
			out.krc.TAURAT=otherparams.taurat[,parampos]

			#set the standard planetary flux values
			out.planet_flux={}
			out.planet_flux.BT_Min=float(otherparams.bt_min[,parampos])
			out.planet_flux.BT_Max=float(otherparams.bt_max[,parampos])
			out.planet_flux.BT_Avg=float(otherparams.bt_avg[,parampos])
			out.planet_flux.Radius=float(otherparams.radius[,parampos])
			out.planet_flux.Geom_alb=float(otherparams.geom_alb[,parampos])
			out.planet_flux.Dis_AU=float(otherparams.dis_au[,parampos])
			out.planet_flux.Orb_Radius=float(otherparams.orb_radius[,parampos])
			out.planet_flux.Mut_Period=float(otherparams.mut_period[,parampos])

			#write out the temporary files
			name=body
			write(parentbodylines,workdir+"/standish.tab",ascii,force=1)
			write(spinlines,workdir+"/spinaxis.tab",ascii,force=1)
			operations=cat("T","1","1","1",""+epoch,"0",body,"2","2","2",body+".mat","0",axis=y)
			write(operations,workdir+"/porb_"+name+".run",ascii,force=1)
			out.body=body
			out.type=bodystruct

		if(anc==1) {
			input={}
      verbose=0
			input.parentbodylines=read_lines(workdir+"/standish.tab")
			input.spinlines=read_lines(workdir+"/spinaxis.tab")
      verbose=1
		}

		} else if(bodystruct.body_type=="Minor") {

			body=bodystruct.name

			#do this so we can run faster..using pre definied values
			testfile=$DV_SCRIPT_FILES+"/krc_support/porb_defaults/"+body+".porb.hdf"
			if(fexists(testfile) && force!=1) {
				printf("Found Default File: %s\n",testfile)
				verbose=0
				default=read(testfile)
				verbose=3
				return(default)
			}
			if(force==1) {
				printf("Forcing PORB run\n")
			}

			#read in the reference structure
			global(krc_smallbodies)
			ref=krc_smallbodies

			#setup a working directory
			workdir=$TMPDIR+"/porb"
			syscall("mkdir -p "+workdir)

			if(type(body)=="STRING") {
        names=""
        names=grep(ref.name,body)
        if(names=="") {
          printf("Could not find body: %s in named asteroids\n",body)
          return(-1)
        } else if(length(names)>1) {
          printf("\nFound more than one body matching the	name\n")
  	  	  printf("Select a body	from the list below\n")
          for(i=1;i<=length(names);i+=1) {
            printf("\t%s\n",names[,i])
    	  	}
	    	  return(-1)
				}

	      pos=maxpos(ref.name==names[,1])[2]

			} else if(type(body)=="int") {
				pos=0
				pos=maxpos(ref.id==body)[2]
				if(pos==0) {
					printf("Could not find body: %i in named asteroids\n",body)
					return(-1)
				}
			}

			#assemble the minor bodies input file
			lines=text(14)
			lines[,1]="C_END"
			lines[,2]="--------  1"
			if(type(body)=="int") {
				lines[,3]=ref.id[,pos]+" / body name"
			} else {
				lines[,3]=ref.name[,pos]+" / body name"
			}
			lines[,4]=ref.jd[,pos]+" / epoch in JD"
			lines[,5]=ref.a[,pos]+" / a - semi-major axis in AU"
			lines[,6]=ref.e[,pos]+" / e - eccentricity"
			lines[,7]=ref.i[,pos]+" / i - inclination of orbit"
			lines[,8]=ref.node[,pos]+" / omega - longitude of ascending node"
			lines[,9]=ref.peri[,pos]+" / peri - augment of perihelion"
			lines[,10]=ref.m[,pos]+" / m - mean anomoly at epoch"
			lines[,11]=ref.polera[,pos]+" / PoleRA - polar right ascension"
			lines[,12]=ref.poledec[,pos]+" / PoleDec - polar declination"
			lines[,13]=ref.merid[,pos]+" / merid - meridian"
      if(ref.rot_per[,pos]==0) {
        ref.rot_per[,pos]=24.
        out.rot_per_flag=1
      }
			lines[,14]=ref.rot_per[,pos]+" / rot_per - sideral rotation period"
			name=body

			#write out the temoporary files
			write(lines,workdir+"/minor.tab",ascii,force=1)
			operations=cat("T","1","3","1","0","2","2","2",name+".mat","0",axis=y)
			write(operations,workdir+"/porb_"+name+".run",ascii,force=1)

			#extract the period and rotation period for calculating various parameters for krc()
			rot_per=ref.rot_per[,pos]
			period=ref.period[,pos]

			out.body=body
			#turn off the atmosphere because they're airless
			out.krc.PTOTAL=0.1
      out.krc.GRAV=0.0
      out.krc.ARC2_G0=0.0
      out.krc.DUSTA=0.0
      out.krc.TAURAT=0.0

			#create a blank planetary_flux
      out.planet_flux={}
      out.planet_flux.BT_Min=-999.
      out.planet_flux.BT_Max=-999.
      out.planet_flux.BT_Avg=-999.
      out.planet_flux.Radius=-999.
      out.planet_flux.Geom_alb=-999.
      out.planet_flux.Dis_AU=-999.
      out.planet_flux.Orb_Radius=-999.
      out.planet_flux.Mut_Period=-999.

			#turn off frost (for now)
			out.krc.TFROST=0.0

			#set TAUD=0
			out.krc.TAUD=0.0
			out.type=bodystruct

			if(anc==1) {
				input=lines
			}

		} else if (bodystruct.body_type=="Comet") {

			body=bodystruct.name

			#do this so we can run faster..using pre definied values
			testfile=$DV_SCRIPT_FILES+"/krc_support/porb_defaults/"+body+".porb.hdf"
			if(fexists(testfile) && force!=1) {
				printf("Found Default File: %s\n",testfile)
				verbose=0
				default=read(testfile)
				verbose=3
				return(default)
			}
			if(force==1) {
				printf("Forcing PORB run\n")
			}

			#read in the reference structure
			global(krc_comets)
			ref=krc_comets

			#setup a working directory
			workdir=$TMPDIR+"/porb"
			syscall("mkdir -p "+workdir)

			if(type(body)=="STRING") {
				names=""
				names=grep(ref.name,body)
				if(names=="") {
					printf("Could not find body: %s in named comets\n",body)
					return(-1)
				} else if(length(names)>1) {
					printf("\nFound more than one body matching the name\n")
					printf("Select a body from the list below\n")
					for(i=1;i<=length(names);i+=1) {
						printf("\t%s\n",names[,i])
					}
					return(-1)
				}

				pos=maxpos(ref.name==names[,1])[2]

			} else if(type(body)=="int") {
				pos=0
				pos=maxpos(ref.id==body)[2]
				if(pos==0) {
					printf("Could not find body: %i in named comets\n",body)
					return(-1)
				}
			}

			#assemble the comets input file
			lines=text(11)
			lines[,1]="C_END"
			lines[,2]=""
			if(type(body)=="int") {
				lines[,3]=ref.id[,pos]+" / body name"
			} else {
				lines[,3]=ref.name[,pos]+" / body name"
			}
			lines[,4]=ref.year[,pos]+" "+ref.month[,pos]+" "+ref.day[,pos]+" / tper - time of perihelion"
			lines[,5]=ref.peri[,pos]+" / peri - augment of perihelion"
			lines[,6]=ref.node[,pos]+" / omega - longitude of ascending node"
			lines[,7]=ref.i[,pos]+" / i - inclination of orbit"
			lines[,8]=ref.q[,pos]+" / q - perihelion distance"
			lines[,9]=ref.e[,pos]+" / e - eccentricity"
			lines[,10]=ref.polera[,pos]+" "+ ref.poledec[,pos]+" / PoleRA/DEC - polar right ascension/declination"
			if(ref.rot_per[,pos]==0) {
				ref.rot_per[,pos]=24.
				out.rot_per_flag=1
			}
			lines[,11]=ref.rot_per[,pos]+" / rot_per - sideral rotation period"
			name=body

			#write out the temoporary files
			write(lines,workdir+"/comet.tab",ascii,force=1)
			operations=cat("T","1","5","1","0","2","2","2",name+".mat","0",axis=y)
			write(operations,workdir+"/porb_"+name+".run",ascii,force=1)

			#extract the period and rotation period for calclating various parameters for krc()
			rot_per=ref.rot_per[,pos]
			period=ref.period[,pos]

			out.body=body
			#turn off the atmosphere because they're airless
			out.krc={}
			out.krc.PTOTAL=0.1
	   	out.krc.GRAV=0.0
      out.krc.ARC2_G0=0.0
      out.krc.DUSTA=0.0
      out.krc.TAURAT=0.0

	    #create a	blank planetary_flux
      out.planet_flux={}
      out.planet_flux.BT_Min=-999.
      out.planet_flux.BT_Max=-999.
      out.planet_flux.BT_Avg=-999.
      out.planet_flux.Radius=-999.
      out.planet_flux.Geom_alb=-999.
      out.planet_flux.Dis_AU=-999.
      out.planet_flux.Orb_Radius=-999.
      out.planet_flux.Mut_Period=-999.

			#turn off frost (for now)
			out.krc.TFROST=0.0

			#set TAUD=0
			out.krc.TAUD=0.0
			out.type=bodystruct

      if(anc==1) {
        input=lines
      }

		} else if(bodystruct.body_type=="Generic") {

			ref=$1

			#setup a working directory
			workdir=$TMPDIR+"/porb"
			syscall("mkdir -p "+workdir)

			#assemble the minor bodies input file
			lines=text(14)
			lines[,1]="C_END"
			lines[,2]="--------  1"
			lines[,3]=ref.name[,pos]+" / body name"
			lines[,4]=ref.epoch[,pos]+" / epoch in JD"
			lines[,5]=ref.a[,pos]+" / a - semi-major axis in AU"
			lines[,6]=ref.e[,pos]+" / e - eccentricity"
			lines[,7]=ref.i[,pos]+" / i - inclination of orbit"
			lines[,8]=ref.node[,pos]+" / omega - longitude of ascending node"
			lines[,9]=ref.peri[,pos]+" / peri - augment of perihelion"
			lines[,10]=ref.m[,pos]+" / m - mean anomoly at epoch"
			lines[,11]=ref.polera[,pos]+" / PoleRA - polar right ascension"
			lines[,12]=ref.poledec[,pos]+" / PoleDec - polar declination"
			lines[,13]=ref.merid[,pos]+" / merid - meridian"
			lines[,14]=ref.rot_per[,pos]+" / rot_per - sideral rotation period"
			name=ref.name

			#write out the temoporary files
			write(lines,workdir+"/minor.tab",ascii,force=1)
			operations=cat("T","1","3","1","0","2","2","2",name+".mat","0",axis=y)
			write(operations,workdir+"/porb_"+name+".run",ascii,force=1)

			#extract the period and rotation period for calclating various parameters for krc()
			rot_per=ref.rot_per[,pos]
			period=ref.period[,pos]

			out.body=name
			#turn off the atmosphere because they're airless
			out.krc.PTOTAL=0.1
      out.krc.GRAV=0.0
      out.krc.ARC2_G0=0.0
      out.krc.DUSTA=0.0
      out.krc.TAURAT=0.0

		  #create a	blank planetary_flux
      out.planet_flux={}
      out.planet_flux.BT_Min=-999.
      out.planet_flux.BT_Max=-999.
      out.planet_flux.BT_Avg=-999.
      out.planet_flux.Radius=-999.
      out.planet_flux.Geom_alb=-999.
      out.planet_flux.Dis_AU=-999.
      out.planet_flux.Orb_Radius=-999.
      out.planet_flux.Mut_Period=-999.

			#turn off frost (for now)
			out.krc.TFROST=0.0

			#set TAUD=0
			out.krc.TAUD=0.0
			out.type=bodystruct
			out.type.name=name
			out.type.id=0
			out.type.parent_body=""


			if(anc==1) {
				input=lines
			}

		} else if(bodystruct.body_type=="Exoplanet") {

		  ref=$1

		  #setup a working directory
		  workdir=$TMPDIR+"/porb"
		  syscall("mkdir -p "+workdir)

		  #assemble the minor bodies input file
		  lines=text(14)
		  lines[,1]="C_END"
		  lines[,2]="--------  1"
		  lines[,3]=ref.name[,pos]+" / name. Must have no blanks"
		  lines[,4]=ref.Vismag[,pos]+" / Visual Magnitude of host star"
		  lines[,5]=ref.epoch[,pos]+" / Time of periastron as full Julian date ; 2000 Jan 1 noon UTC= 2451545.0"
		  lines[,6]=ref.DisEarth[,pos]+" / Distance from Earth to host star. Lightyears"
		  lines[,7]=ref.a[,pos]+" / a - semi-major axis in AU"
		  lines[,8]=ref.period[,pos]+" / sideral orbital period, in days (Default=365.256)"
		  lines[,9]=ref.e[,pos]+" / e - eccentricity"
		  lines[,10]=ref.Obliq[,pos]+" / Obliquity of planet pole, in degree"
		  lines[,11]=ref.Lsperi[,pos]+" / Season (Ls) at periastron, in degree"
		  lines[,12]=ref.rot_per[,pos]+" / siderial rotation period, in hours (Default=23.9345)"
		  lines[,13]="--------"
		  name=ref.name

      printf(workdir+"/exoplan.tab")

		  #write out the temporary files
		  write(lines,workdir+"/exoplan.tab",ascii,force=1)
		  operations=cat("T","1","6","1","0","2","2","2",name+".mat","0",axis=y)          ###What does this line?
		  write(operations,workdir+"/porb_"+name+".run",ascii,force=1)

		  #extract the period and rotation period for calclating various parameters for krc()
		  rot_per=ref.rot_per[,pos]
		  period=ref.period[,pos]

      #For exoplanets, the user has to provide PTOTAL and the atmopheric properties
		  out.body=name
#		  out.krc.PTOTAL=PTOTAL
#		  out.krc.GRAV=GRAV
#		  out.krc.ARC2_G0=ARC2_G0
#		  out.krc.DUSTA=DUSTA
#		  out.krc.TAURAT=TAURAT

		  #create a	blank planetary_flux
		  out.planet_flux={}
		  out.planet_flux.BT_Min=-999.
		  out.planet_flux.BT_Max=-999.
		  out.planet_flux.BT_Avg=-999.
		  out.planet_flux.Radius=-999.
		  out.planet_flux.Geom_alb=-999.
		  out.planet_flux.Dis_AU=-999.
		  out.planet_flux.Orb_Radius=-999.
		  out.planet_flux.Mut_Period=-999.

		  #turn off frost (for now)
		  out.krc.TFROST=TFROST

		  #set TAUD=0
		  #out.krc.TAUD=0.0
		  out.type=bodystruct
		  out.type.name=name
		  out.type.id=0
		  out.type.parent_body=""


		  if(anc==1) {
		    input=lines
		  }

		} else {
			printf("Please enter a supported type\n")
			printf("planet, minor, comet\n\n")
			return(-1)
		}

		#run porb
		if(v>=1) {
	 		system("cd "+workdir+"; "+$DV_KRC_HOME+"/src/porbmn < "+workdir+"/porb_"+name+".run | tee -a "+workdir+"/krc.log")
			log=read_lines(workdir+"/krc.log")
		} else {
			log=syscall("cd "+workdir+"; "+$DV_KRC_HOME+"/src/porbmn < "+workdir+"/porb_"+name+".run")
	  }

		#read in the porb ouput
		verbose=0
		rot=read_lines(workdir+"/"+name+".mat")
    verbose=1

		#fill out the output structure
		out.rot=rot
		out.rot_per=rot_per
		out.period=period

		#we do this for every 15 earth minutes or a minimum 96 times a day
		out.krc.N24=int(floor((rot_per*4)/96)*96)
		if(out.krc.N24<96) out.krc.N24=96

		#ratio of body day to earth day
		out.krc.PERIOD=rot_per/24.

		#deljul is in days/degree of Ls (ish)
		out.krc.DELJUL=period/360.

		#return the log if requested
		if(anc==1) {
			out.log=log
			out.input=input
		}

		#clean up
		syscall("rm -r "+workdir+"/*")
		return(out)
	} else {

		#this is the case to make the defaults files
		outdir=$PWD+"/porb_defaults"
		syscall("mkdir "+outdir)

		#choose our defaults from each list
		global(krc_porb_defaults)
		run_list=krc_porb_defaults

		#run all the cases
		for(i=1;i<=length(run_list);i+=1) {
			printf("Running Body: %s\n",run_list[,i])
			out=porb(run_list[,i],force=1)
			outname=outdir+"/"+run_list[,i]+".porb.hdf"
			printf("Writing: %s\n",outname)
			write(out,outname,hdf,force=1)
		}
	}
}



define krc_find_body() {
	if($ARGC==0) {
		printf("\n\nSearch for the KRC body name to use\n")
		printf("$1=search string (Note: case sensitive)\n\n")

		printf("c.edwards 4/30/2020\n\n")
		return(null)
	}

	search=$1
	verbose=0
	global(krc_porb_master)
	master=krc_porb_master

	matches=grep(master.name,search)
	verbose=3

	if(HasValue(matches)==0) {
		printf("\nNo Match Found for: %s\n\n",search)
		return(null)
	}

	printf("\nListing Matches for: %s\n\n",search)
	printf("   Body Name\t|  KRC Name\t|  Body Type\t|  Parent Body\n")
	printf("-------------------------------------------------------------------------------------\n")

	for(i=1;i<=length(matches);i+=1){
		pos=maxpos(master.name==matches[,i])[2]
		krcname=matches[,i]

		type=master.body_type[,pos]
		if(type=="Minor") {
			bodyname=strsplit(krcname,delim="_")[,2]
		} else if (type=="Comet") {
			bodyname=strsplit(krcname,delim="-")[,2]
		} else {
			bodyname=krcname
		}

		if(length(krcname)<8) {
			krcname=krcname+clone(" ",x=9-length(krcname))
		}

		if(length(bodyname)<8) {
			bodyname=bodyname+clone(" ",x=9-length(bodyname))
		}

		if(length(type)<8) {
			type=type+clone(" ",x=9-length(type))
		}

		if(type=="Satellite") {
			parentbody=master.parent_body[,pos]
		} else {
			parentbody="N/A"
		}

		printf("   %s\t|  %s\t|  %s\t|  %s\n",bodyname,krcname,type,parentbody)
	}
	printf("-------------------------------------------------------------------------------------\n")
}




define porb_type(make_master){

	if(HasValue(make_master)==0) {
		make_master=0
	}

	if($ARGC==0 && make_master==0) {
		printf("\nReturn the Body type structure for use with porb functions\n")
		printf("$1 = body - the name or JPL horizons ID # of the body of interet\n\n")
		printf("c. edwards 3/11/2020\n\n")
		return(null)
	}

	body=$1

	if(make_master==0) {

		verbose=0
		global(krc_porb_master)
		master=krc_porb_master
		verbose=3

	  if(type(body)=="STRING") {
 	    names=""
 	    names=grep(master.name,body)
		  if(length(names)==1) {
			  pos=maxpos(master.name==names[,1])[2]
			} else if(sum(names==body)==1) {
				 pos=maxpos(master.name==names[,1])[2]
 	    } else if(length(names)>1) {
 	      printf("\nFound more than one body matching the name\n")
 	      printf("Select a body from the list below\n")
 	      for(i=1;i<=length(names);i+=1) {
 	        printf("\t%s\n",names[,i])
 	      }
		    return(-1)
 		  } else if (names=="") {
 	      printf("Could not find body: %s in named comets\n",body)
 	      return(-1)
			}

	 	} else if(type(body)=="int") {
 	   	 pos=0
 	   	 pos=maxpos(master.id==body)[2]
 	   	 if(pos==0) {
 	   		 printf("Could not find body: %i in named Minor Bodies or Comets Database\n",body)
 	   	   return(-1)
 	   	 }
 	  }

		out={}
		out.name=master.name[,pos]
		out.id=master.id[,pos]
		out.body_type=master.body_type[,pos]
		out.parent_body=master.parent_body[,pos]
		return(out)

	} else if(make_master==1) {
	  standish=read_lines($DV_SCRIPT_FILES+"/krc_support/standish.tab")
  	spinaxis=read_lines($DV_SCRIPT_FILES+"/krc_support/spinaxis.tab")
		comet=read($DV_SCRIPT_FILES+"/krc_support/comets.hdf")
		minor=read($DV_SCRIPT_FILES+"/krc_support/small_bodies.hdf")

		out={}
		out.name=text(0)
		out.id=create(1,1,1,start=0,step=0,format=int,org=bsq)
		out.body_type=text(0)
		out.parent_body=text(0)
		spin_start=maxpos(spinaxis[:5]=="C_END")[2]+1
		spin_end=maxpos(spinaxis[:8]=="lastLine")[2]-1
		spin_split=strsplit(spinaxis[,spin_start:spin_end],delim="\t")

		standish_start=maxpos(standish[:5]=="C_END")[2]+1
		standish_split=strsplit(standish[,standish_start::2],delim=" ")

		count=1
		for(i=1;i<=length(spin_split);i+=1){
			out.name=cat(out.name,spin_split[i][,1],axis=y)
			out.id=cat(out.id,0,axis=y)
			out.parent_body=cat(out.parent_body,spin_split[i][,8],axis=y)
			if(spin_split[i][,8]=="") {
				out.body_type=cat(out.body_type,"Planet",axis=y)
			} else {
				out.body_type=cat(out.body_type,"Satellite",axis=y)
			}
			count+=1
		}
		out.id=out.id[,2:]

		out.name=cat(out.name,text(length(minor.name)),axis=y)
		out.id=cat(out.id,create(1,length(minor.name),1,start=0,step=0,format=int,org=bsq),axis=y)
		out.parent_body=cat(out.parent_body,text(length(minor.name)),axis=y)
    out.body_type=cat(out.body_type,text(length(minor.name)),axis=y)

		out.name[,count:]=minor.name
    out.id[,count:]=minor.id
   	out.body_type[,count:]="Minor"

		out.name=cat(out.name,text(length(comet.name)),axis=y)
		out.id=cat(out.id,create(1,length(comet.name),1,start=0,step=0,format=int,org=bsq),axis=y)
		out.parent_body=cat(out.parent_body,text(length(comet.name)),axis=y)
    out.body_type=cat(out.body_type,text(length(comet.name)),axis=y)

		out.name[,length(out.name)-length(comet.name)+1:]=comet.name
    out.id[,length(out.name)-length(comet.name)+1:]=comet.id
   	out.body_type[,length(out.name)-length(comet.name)+1:]="Comet"

		return(out)
	}
}

define atob() {

  if($ARGC==0)  {
    printf("\nConvert a STRING/TEXT BOOLEAN to 0/1 integers\n")
    printf("$1=a STRING or TEXT array\n\n")
    printf("NOTE: This function explicitly matches \"T\" only.  Everything else is false\n\n")
    return(null)
  }

  if(type($1)!="STRING" && type($1)!="TEXT") {
    printf("$1 is not a STRING or TEXT array\n\n")
    return(null)
  }

  data=$1
  out=atoi(data)
  out[where data=="T"]=1

  return(out)
}

define generic_porb(name,epoch,e,a,w,i,node,peri,m,rot_per,polera,poledec,merid,usage,period) {

	if(HasValue(usage)==1) {
		printf("\nGenerate a generic PORB structure for use with the davinci porb function\n")
		printf("This is formatted in the minor body style for porb and permits the following values described below\n\n")
		printf("\tname = body name (Default=\"None\") will be truncated to 24 characters\n")
		printf("\tepoch = epoch in Julian Date (Default = 2451545.0, year 2000)\n")
		printf("\ta = Semi-Major Axis in AU (Default=1)\n")
		printf("\te = Eccentricity (Default=0)\n")
		printf("\ti = Inclination of mean orbit to ecliptic in degrees  (Default=0)\n")
		printf("\tnode = Longitude of the asceding node in degrees (Default=0)\n")
		printf("\tperi = Argument of perihelion in degrees (Default=0)\n")
		printf("\tm = Mean Anomoly at epoch in degrees (Default=0)\n")
		printf("\tpolera = Right Ascention of the pole in degrees (Default=0)\n")
		printf("\tpoledec = Declination of the pole in degrees (Default=0)\n")
		printf("\tmerid = prime meridian at epoch in degrees (Default=0\n")
		printf("\trot_per = siderial rotation period in hours (Default=23.9345)\n")
		printf("\tperiod = siderial orbital period in days (Default=365.256)\n")
		printf("\nc.edwards 4/27/17\n\n")
		return(null)
	}

	#fill in all the values w/defaults
	output={}
	if(HasValue(name)==0) {
		output.name="None"
	} else {
		output.name=name[:24]
	}
	if(HasValue(epoch)==0) {
		output.epoch=2451545.00
	} else {
		output.epoch=epoch
	}
	if(HasValue(a)==0) {
		output.a=1.0
	} else {
		output.a=a
	}
	if(HasValue(e)==0) {
		output.e=0.0
	} else {
		output.e=e
	}
	if(HasValue(i)==0) {
		output.i=0.0
	} else {
		output.i=i
	}
	if(HasValue(node)==0) {
		output.node=0.0
	} else {
		output.node=node
	}
	if(HasValue(peri)==0) {
		output.peri=0.0
	} else {
		output.peri=peri
	}
	if(HasValue(m)==0) {
		output.m=0.0
	} else {
		output.m=m
	}
	if(HasValue(polera)==0) {
		output.polera=0.0
	} else {
		output.polera=polera
	}
	if(HasValue(poledec)==0) {
		output.poledec=0.0
	} else {
		output.poledec=poledec
	}
	if(HasValue(merid)==0) {
		output.merid=0.0
	} else {
		output.merid=merid
	}
	if(HasValue(rot_per)==0) {
		output.rot_per=23.9345
	} else {
		output.rot_per=rot_per
	}
	if(HasValue(period)==0) {
		output.period=365.256
	} else {
		output.period=period
	}
	return(output)
}

define krc_cond_gas(){

	if($ARGC == 0){
    printf (" Uses the adequate Clausius Clapeyron Coefficients to predict the frost point \n")
    printf (" Feeds KRC with SatPrA, SatPrB, FANON, AMW \n")
    printf (" $1: Body \n")
    printf (" Currently Supported: \"Mars\" or \"Pluto\" or \"Titan\" \n")
 	}

	Body   = $1

	if(Body == "Mars"){
  	SatPrB = 3182.48
	  SatPrA = 27.9546
	  AMW    = 43.54                                                              #Sylvain's own calculation
    FANON  = 0.040                                                              #Paul R. Mahaffy, Science 2013 (SAM)
		KPREF  = 1
	}

	if(Body == "Pluto"){
  	SatPrB = 9.2338
	  SatPrA = -724.9720
	  AMW   = 27.
	  FANON = 0.1
		KPREF = 0
	}

 	if(Body == "Titan"){
  	SatPrB = 9.2338
	  SatPrA = -724.9720
 		AMW   = 28.8
   	FANON = 0.016
		KPREF = 0
	}

	if(Body != "Mars" && Body != "Titan" && Body != "Pluto") {
	  printf("Only Mars, Pluto, and Titan currently support Condensable Gas defaults\n")
		return(-999.)
	} else {
		out        = {}
		out.SatPrA = SatPrA
		out.SatPrB = SatPrB
		out.AMW    = AMW
		out.FANON  = FANON
		out.KPREF  = KPREF
		return(out)
	}
}



define krc_planetary_flux_porb(porb,porb_Planet,Lon_Hr){

	if($ARGC == 0){
    printf (" Generates the change card for planetary heat loads in KRC \n")
    printf (" $1: porb for the satellite \n")
    printf (" $2: porb for the main body (planet) \n")
    printf (" $3: Lon_Hr, Longitude Hour of the surface point \n")
	}

	pi             = 3.14159
	porb           = $1
	porb_Planet    = $2
	Data_Plan      = porb_Planet.planet_flux                                      #Gets satellites data
	Data_Sat       = porb.planet_flux                                             #Gets planet data
	Lon_Hr         = $3                                                           #Longitude Hour

	Radiance       = 5.56E-8 * float(Data_Plan.BT_Avg)^4                          #Calculates Average Radiance from Planet
	Min_Rad        = 5.56E-8 * float(Data_Plan.BT_Min)^4                          #Calculates the Min Radiance from Planet
	Max_Rad        = 5.56E-8 * float(Data_Plan.BT_Max)^4                          #Calculates the Max Radiance from Planet
	Delta_Radiance = 5.56E-8 * (float(Data_Plan.BT_Max)^4 - float(Data_Plan.BT_Min^4)) #Calculates Max - Min Radiance form Planet
	Plan_Ang_Surf  = pi*((360./pi)*atan(Data_Plan.Radius/(2*Data_Sat.Orb_Radius)))^2/3282.80635#Angular Surface of Planet
	IR_Flux        = (Radiance * Data_Plan.Radius^2/Data_Sat.Orb_Radius^2)        #1.0 assumes this emissivity ofr the parent body; IR Flux from Planet on Satellite making it to surface after IR albedo correction
	IR_Half_Amp    = (Radiance - Min_Rad ) * Plan_Ang_Surf * 0.5 / pi             #1/2 Amplitude, most often 0 for gas giants
	IR_Phase_Lag   = 0.                                                           #Will need to Look at that for Eclipses
	Vis_Flux_Peak  = 2*(pi*1361*Data_Plan.Radius^2/(Data_Plan.Dis_AU^2))/(2*pi*Data_Sat.Orb_Radius^2)*Data_Plan.Geom_alb  #Peak Visible Flux from Planet
	Vis_Flux       = 0.5 * Vis_Flux_Peak                                          #Average Visible Flux from the planet making it to surface after visible albedo correction
	Vis_Half_Amp   = 0.5 * Vis_Flux_Peak                                          #Mshould be equal to Vis_Flux
	Vis_Phase_Lag  = 0.                                                           #Will need to Look at that for Eclipses

	line = sprintf("15 %.2f %.2f %.2f %.2f %.2f %.2f %.2f / Forcing from Planet on Satellite",IR_Flux,IR_Half_Amp,IR_Phase_Lag,Vis_Flux,Vis_Half_Amp,Vis_Phase_Lag,Lon_Hr)
	return(line)
}



define krc_planetary_flux_table(IR,Vis,Lon_Hr){
#05/17/2018: Fixes issue with average fluxes definition (HHK email of 05/07/2018)

	if($ARGC == 0){
    printf (" Generates the change card for planetary heat loads in KRC \n")
    printf (" $1: IR array vs LTST (2xnx1)\n")
    printf (" $2: Vis array vs LTST (2xnx1)\n")
    printf (" $3: Lon_Hr, Longitude Hour of the surface point \n")
	}

	pi            = 3.14159
	IR_1          = $1
	IR            = IR_1[1,,1]                                                    #IR array, y axis
	LTST_IR       = IR_1[2,,1]                                                    #LTST for the IR array, y axis
	Vis_1         = $2
	Vis           = Vis_1[1,,1]                                                   #Vis array, y axis
	LTST_Vis      = Vis_1[2,,1]                                                   #LTST for the Vis array, y axis
	Lon_Hr        = $3                                                            #Longitude Hour

	Peak_IR       = maxpos(IR,showval=1)
	Min_IR        = minpos(IR,showval=1)
	LTST_IR_Peak  = LTST_IR[1,int(Peak_IR[2,1,1]),1]                              #int(Peak_IR[2,1,1]) is the index
	Half_Amp_IR   = 0.5*(Peak_IR[4]-Min_IR[4])
	Phase_IR      = 180 + 360.*LTST_IR_Peak/24.                                   #in degree SP added + 180. 03/30/2020
	IR_KRC        = Min_IR[4] + Half_Amp_IR * (1 + cosd(360.*LTST_IR/24. - Phase_IR))
	#labelxy("LTST","Flux")
	#plot(IR,"IR",Xaxis=LTST_IR,IR_KRC)


	Peak_Vis       = maxpos(Vis,showval=1)
	Min_Vis        = minpos(Vis,showval=1)
	LTST_Vis_Peak  = LTST_Vis[1,int(Peak_Vis[2,1,1]),1]                           #int(Peak_IR[2,1,1]) is the index
	Half_Amp_Vis   = 0.5*(Peak_Vis[4]-Min_Vis[4])
	Phase_Vis      = 180 + 360.*LTST_Vis_Peak/24.                                 #in degree SP added + 180. 03/30/2020
	Vis_KRC        = Min_Vis[4] + Half_Amp_Vis * (1 + cosd(360.*LTST_Vis/24. - Phase_Vis))
	#plot(Vis,"Vis",Xaxis=LTST_Vis,Vis_KRC)

	Vis_Flux      = Min_Vis[4]  + Half_Amp_Vis                                    #Average solar Flux
	Vis_Half_Amp  = Half_Amp_Vis                                                  #Visible Half Amplitude
	Vis_Phase_Lag = Phase_Vis                                                     #Vis Phase Lag in degrees
	IR_Flux       = Min_IR[4]  + Half_Amp_IR                                      #Average Thermal Emission
	IR_Half_Amp   = Half_Amp_IR                                                   #IR Half Amplitude
	IR_Phase_Lag  = Phase_IR                                                      #IR Phase Lag in degrees

	line = sprintf("15 %.2f %.2f %.2f %.2f %.2f %.2f %.2f / Forcing from Planet on Satellite",IR_Flux,IR_Half_Amp,IR_Phase_Lag,Vis_Flux,Vis_Half_Amp,Vis_Phase_Lag,Lon_Hr) #IR, then Vis
	return(line)
}



define Date2Ls(){
  if($ARGC == 0){
    printf("Converts Julian Date or UT Date to Ls for various bodies  \n")
    printf("$1: Julian Date or UT Date \n")
    printf("$2: Body \n")
    printf("Dates range from 1990-Jan-01 to 2040-Jan-01 (UT Date)\n")
    printf("Dates range from 2451544.5 to 2462502.5 (JD)\n")
    printf("UT Date ????-Mmm-DD, with Mmm:Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec\n")
    printf("Supported bodies: \"Mars\", \"Bennu\", \"Europa\", \"Moon\" \n")
    printf("Perceived Accuracy: Mars~0.3Ls \| Bennu~0.5Ls \| Europa~0.1Ls \| The Moon~1.Ls\"\n")
                 }
  if($ARGC != 0){
    DATE    = $1
    BODY    = $2
    PATH    = $DV_HOME + "/library/script_files/krc_support/porb_defaults/"

    if(fexists(PATH + "/" + BODY + "_Ls_Date.ascii") != 1){
      printf("Body not supported\n")
    } else {
      verbose = 0
      IN      = read_lines(PATH + BODY + "_Ls_Date.ascii")
      verbose = 1
      LINE    = atof(grep(IN,DATE[,1,1]+"")[24:29,1,1])
    if(length(DATE[1,,1]) > 1){
       for(i=2;i<=length(DATE);i+=1){
         BUFFER = atof(grep(IN,DATE[,i,1]+"")[24:29,1,1])
         LINE   = cat(LINE,BUFFER,axis=y)
       }
     }
    return(LINE)
    }
  }
}



define GD2JD(){
	if($ARGC == 0){
    printf("Converts Gregorian Date to Julian Date \n")
    printf("$1: Julian Date o\n")
    printf("Dates range from 1990-Jan-01 to 2040-Jan-01 (UT Date)\n")
    printf("UT Date ????-Mmm-DD, with Mmm:Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec\n")
		printf("Dates range from 2451544.5 to 2462502.5 (JD)\n")
                 }
  if($ARGC != 0){
		DATE    = $1
		PATH    = $DV_SCRIPT_FILES+"/krc_support/porb_defaults/Mars_Ls_Date.ascii"
		verbose = 0
		IN      = read_lines(PATH)
		verbose = 1
	  LINE    = atoi(grep(IN,DATE[,1,1]+"")[14:23,1,1])
		if(length(DATE[1,,1]) > 1){
			for(i=2;i<=length(DATE);i+=1){
				BUFFER = atof(grep(IN,DATE[,i,1]+"")[14:23,1,1])
			  LINE   = cat(LINE,BUFFER,axis=y)
			}
		}
	return(LINE)
	}
}



define process_bin52(raw,hour,ls,usage,one,TUN8,JD,GD) {
  if($ARGC == 0 && HasValue(usage)==0) {
    printf("\n")
    printf("Read in bin52 krc file and process to something more manageable\n")
    printf("\t$1 = filename\n\n")
    printf("Optional:\n")
    printf("\thour=return the specified hour (Default = -32768 for all hours)\n")
    printf("\tls=return the specified ls (Default = -32768 for all ls)\n")
    printf("\traw=return the raw data as well (Default = 0)\n")
		printf("\tusage=print the output usage (Default=0)\n")
		printf("\tone=process only the tsurf data for the one point mode\n\n")
    printf("C.Edwards 4/14\n\n")
  }

  if($ARGC == 0 || HasValue(usage)==1) {
    printf("Bin52 output struct is:\n")
    printf("By case#, where elements are:\n")
    printf("\tsurf - surface temperature (K) \t\t\t\t\t\t(Hours X Latitudes or Depth (default) X Seasons)\n")
    printf("\tbol - bolomieter temperature (K) \t\t\t\t\t(Hours X Latitudes X Seasons)\n")
    printf("\ttatm - atmosphere temperature (K) \t\t\t\t\t(Hours X Latitudes X Seasons)\n")
    printf("\tdown_vis - solar wavelength radiant flux (W/m^2)\t\t\t(Hours X Latitudes X Seasons)\n")
    printf("\tdown_ir - infrared downwelling radiant flux (W/m^2)\t\t\t(Hours X Latitudes X Seasons)\n")
    printf("\ttime - corresponding time of day axis (local hour) \t\t\t(Hours X 1 X 1)\n")
    printf("\tls - corresponding season axis (solar longitude)\t\t\t(1 X 1 X Seasons)\n")
		printf("\tdeltaJD - corresponding Julian Date (starting at 0, optional) \t\t(Hours X 1 X Seasons)\n")
    printf("\tlat - corresponding latitude (degrees)\t\t\t\t\t(1 X Latitudes X 1)\n")
    printf("\telev - corresponding elevation for specified latitude (km)\t\t(1 X Latitudes X 1)\n\n")
		printf("\tlayer - structure containing all layer properties\n")
		printf("\tlayer.thickenss - layer thickness (m & skindepths)\t\t\t(Layers X Type x 1)\n")
		printf("\tlayer.center - center position (m & skindepths)\t\t\t\t(Layers X Type x 1)\n")
		printf("\tlayer.top - top position (m & skindepths)\t\t\t\t(Layers X Type x 1)\n")
		printf("\tlayer.center_mass - layer-center columnar mass (kg/m^2)\t\t\t(Layers X 1 x 1)\n")
		printf("\tlayer.mass_burden - mass burden above bottom layer (kg/m^2)\t\t(Layers X 1 x 1)\n")
		printf("\tlayer.thermal_scales - thermal scales above bottom layer (skindepths)\t(Layers X 1 x 1)\n")
		printf("\tlayer.tmax - maximum daily temperature for every layer (K)\t\t(Layers X Latitudes x Seasons)\n")
		printf("\tlayer.tmin - minimum daily temperature for every layer (K)\t\t(Layers X Latitudes x Seasons)\n\n")
		printf("\tanc - structure containing additional properties\n")
		printf("\tanc.krccom - KRCcommon input parameters: real=fd, integer=id, and boolean=ld\n")
		printf("\tanc.JDate - Julian Date (J2000)\t\t\t\t\t\t(1 X 1 x Seasons)\n")
		printf("\tanc.ref_pressure - Current surface pressure at elevation 0 (Pascal)\t(1 X 1 x Seasons)\n")
		printf("\tanc.taud - Mean Visible Dust Opacity\t\t\t\t\t(1 X 1 x Seasons)\n")
		printf("\tanc.total_frost - Global average columnar mass of frost (kg/m^2)\t(1 X 1 x Seasons)\n")
		printf("\tanc.avg_heat_flow - Mean Upward heat flow on the last day (W/m^2)\t(1 X Latitudes x Seasons)\n")
		printf("\tanc.frost_alb - Frost albedo at the last time step\t\t\t(1 X Latitudes x Seasons)\n")
		printf("\tanc.frost - predicted frost amount (kg/m^2)\t\t\t\t(1 X Latitudes x Seasons)\n")
		printf("\tanc.tatm_predicted - predicted final atmospheric temperature (K)\t(1 X Latitudes x Seasons)\n")
		printf("\tanc.delta_t_rms - RMS temperature change on the last day (K)\t\t(1 X Latitudes x Seasons)\n")
		printf("\tanc.converge_days - number of days to compute a solution \t\t(1 X Latitudes x Seasons)\n")
    printf("\nIf only one case is present, the output will be composed only of these elements\n")
    printf("If multiple cases are present, the output will be composed of a structure of\n")
    printf("case1, case2, ..., caseN\n")
    printf("\n")
    return(null)
  }

	if(HasValue(JD)==0) JD=0
  if(HasValue(raw)==0)  raw=0
  if(HasValue(ls)==0)   ls=-32768
  if(HasValue(hour)==0) hour=-32768
	if(HasValue(one)==0)  one=0
	if(HasValue(TUN8)==0) TUN8=0

  # Read in bin52 file
  data=load_bin5($1)
	header=unpack("a512",$1,count=1).c1[,1]
	vpos=strstr(header,"KRCv")
	Mversion=atoi(header[vpos+4])
	mversion=atoi(header[vpos+6])
	rversion=atoi(header[vpos+8])
	if(Mversion==3) {
		dtype="double"
	} else {
		dtype="float"
	}
  if((Mversion+mversion/10.)<2.3 || (Mversion+mversion/10.)>3.6) {
     printf("Unsupported bin52 file version\n")
     printf("Detected version: %i.%i.%i -- requires >=2.3.2 or <= 3.6 \n",Mversion,mversion,rversion)
     return(null)
   }

	#output structure
	out={}

  #multiple case options....
  for(k=1;k<=dim(data[1][1])[3];k+=1) {

		#temporary working structure.
    tmp={}
		anc={}

		#extra 4 items tacked on to the front of the prefix that set the header size
		#number of output seasons
		#Number of 8?-byte words in KRCCOM
		NWKRC=int(data[1][1][1,1,k])

		#1-based index of the dimension with extra values -- not really clear what this one is
		IDX=int(data[2][1][1,1,k])

		#Number of those extra - this is the the number of "extra" seasons
		NDX=int(data[3][1][1,1,k])

		#Number of output seasons
		NSOUT=int(data[4][1][1,1,k])

		#full prefix size
		prefixsize=NWKRC+NSOUT*5+IDX
		prefix=create(1,1,dim(data[1][1])[1]*length(data)*7*NDX,start=0,step=0,format=dtype,org=bsq)
		count=1

		#loop through over, 1) seasons, 2) lats, 3) items, 4) hours to turn them into a single dimensioned array
		for(j=1;j<=NDX;j+=1) {
			for(m=1;m<=dim(data[1][1])[1];m+=1) {
				for(l=1;l<=7;l+=1) {
					for(i=1;i<=length(data);i+=1) {
						#printf("count=%i,i=%i,l=%i,m=%i,j=%i,k=%i,data=%f\n",count,i,l,m,j,k,data[i][l][m,j,k])
						prefix[,,count]=data[i][l][m,j,k]
						count+=1
					}
				}
			}
		}

		if(Mversion==3) {
			#get the parameters needed to calculate the layer type stuff
			#extract the float, integer, logicals parts
			skip=512+((k-1)*dim(data[1][1])[2]*dim(data[1][1])[1]*7*length(data)*8)

			#extract krccom
			#x8*4  = first 4 values that describe prefix
			#r8*96 = 64 real values in the input file modified by the changecards + 32 calculated values
			#r8*37 = MAXN4 (37) lat values
			#r8*37 = MAXN3 (37) elevation values
			#u4*40 = 40 integer parameters - first 25 input/last 15 calculated
			#u4*20 = 20 boolean parameters in the input file modified by the changecards
			#a80 = 80 character title
			#a24 = 24 character runtime
			anc.krccom=unpack("x8*4r8*96r8*37r8*37u4*40u4*20a80a24",$1,skip=skip,count=1,col_names=cat("fd","lats","elevs","id","ld","title","runtime",axis=y))

		} else if (Mversion==2) {
			skip=512+((k-1)*dim(data[1][1])[2]*dim(data[1][1])[1]*7*length(data)*4)
			#extract krccom
			#x8*4  = first 4 values that describe prefix
			#r8*96 = 64 real values in the input file modified by the changecards + 32 calculated values
			#u4*40 = 40 integer parameters - first 25 input/last 15 calculated
			#u4*20 = 20 boolean parameters in the input file modified by the changecards
			#a80 = 80 character title
			#a20 = 20 character runtime
			#r8*37 = MAXN4 (37) lat values
			#r8*37 = MAXN3 (37) elevation values
			anc.krccom=unpack("x4*4r4*96u4*40u4*20a80a20r4*37r4*37",$1,skip=skip,count=1,col_names=cat("fd","id","ld","title","runtime","lats","elevs",axis=y))
		}

		#get the parameters needed to calculate the layer type stuff.
		N1=int(anc.krccom.id[1])
		N24=int(anc.krccom.id[6])

		if(one==0) {
			N2=int(anc.krccom.id[2])
			IC2=int(anc.krccom.id[8])
			INERTIA=anc.krccom.fd[3]
			COND2=anc.krccom.fd[4]
			DENS2=anc.krccom.fd[5]
			PERIOD=anc.krccom.fd[6]
			SPHT=anc.krccom.fd[7]
			DENS=anc.krccom.fd[8]
			SPHT2=anc.krccom.fd[16]
			RLAY=anc.krccom.fd[33]
			FLAY=anc.krccom.fd[34]
			CONVF=anc.krccom.fd[35]
			LOCAL=anc.krccom.ld[15]

			#calculate some useful things
			COND=INERTIA^2/(DENS*SPHT)
			INERTIA2=sqrt(COND2*DENS2*SPHT2)
			PERSEC=PERIOD*86400
			DIFFU=COND/(DENS*SPHT)
			DIFF2=COND2/(DENS2*SPHT2)
			SCAL1=sqrt(DIFFU*PERSEC/3.141592741)
			SCAL2=sqrt(DIFF2*PERSEC/3.141592741)

			#set the diffusivity
			DIFF=clone(DIFFU,z=N1)
			if(IC2>1 && IC2<N1) {
				DIFF[,,IC2:]=DIFF2
			}

			#figure out layer progression in local units
			yy=FLAY*RLAY^create(1,1,N1,start=0,step=1,format=float)

			#calculate the layer thickness in meters
			if(LOCAL==1) {
				TLAY=yy*sqrt(DIFF*PERSEC/3.141592741)
			} else {
				TLAY=yy*SQRT(DIFF[,,1]*PERSEC/3.141592741)
			}

			#calculate the depth to the center in meters
			CDEPTHS=create(1,1,N1,start=0,step=0,format=dtype)
			CDEPTHS[,,1]=-TLAY[,,1]/2
			for(i=2;i<=N1;i+=1) {
				CDEPTHS[,,i]=CDEPTHS[,,i-1]+(TLAY[,,i]+TLAY[,,i-1])/2.
			}

			#calculate the various layer properties.
			scale=SCAL1
			Q6=rhop=rhop=sumd=burd=0.
			layerprops=create(7,1,N1,format=dtype,start=0,step=0)
			for(i=1;i<=N1;i+=1) {
				if(i==1) {
					rho=DENS
				}
				if (i==IC2) {
					rho=DENS2
					scale=SCAL2
				}
				Q2=TLAY[,,i]/SCAL1
				Q4=CDEPTHS[,,i]/SCAL1
				if(i>1) {
					Q6=Q6+0.5*(TLAY[,,i-1]*rhop+TLAY[,,i]*rho)
					sumd=sumd+Q2
					burd=burd+TLAY[,,i]*rho
				}
				rhop=rho
				layerprops[,,i]=cat(format(Q2,type=dtype),format(TLAY[,,i],type=dtype),format(Q4,type=dtype),format(CDEPTHS[,,i],type=dtype),format(Q6,type=dtype),format(burd,type=dtype),format(sumd,type=dtype),axis=x)
			}

			#fill out the layer properties
			layer={}
			layer.thickness=translate(cat(layerprops[2],layerprops[1],axis=y),x,z)[2:]
			layer.center=translate(cat(layerprops[4],layerprops[3],axis=y),x,z)[2:]
			layer.top=layer.center-(layer.thickness*float(0.5))
			layer.center_mass=translate(layerprops[5],x,z)[2:]
			layer.mass_burden=translate(layerprops[6],x,z)[2:]
			layer.thermal_scales=translate(layerprops[7],x,z)[2:]
		}

		#figure out how many elements KRCCOM+extra items are
		prefix=prefix[,,NWKRC+IDX+1:]
		NumLayers=int(min(N1//N24-2))                                                    #SP TEST ISSUE WITH PASSING THE NUMBER OF LAYERS N1

		#create the time axis
 		time=create(length(data),1,1,start=24./length(data),step=24./length(data),format=float)

		#extract all the various parameters in the prefix of each case
		J2000=double(2451545.0)
		datals=prefix[,,NSOUT+1:NSOUT*2]

		if(one==0) {
#Maybe something like this to get the JDate for the time of day
			anc.JDate=double(prefix[,,:NSOUT])+J2000
			anc.ref_pressure=prefix[,,(NSOUT)*2+1:NSOUT*3]
			anc.taud=prefix[,,(NSOUT)*3+1:NSOUT*4]
			anc.total_frost=prefix[,,(NSOUT)*4+1:NSOUT*5]
		}

	  #reset the hour and ls to max/min values to prevent bogus numbers (e.g. -1)
 		if(ls !=-32768 && (ls>360 || ls<0)) {
    	printf("\nls (%f) is out of data range (0-360), aborting\n\n",ls)
			return(null)
		}

 		if(hour !=-32768 && (hour>24 || hour<0)) {
    	printf("\nhour (%f) is out of data range (0-24), aborting\n\n",ls)
			return(null)
		}

    #create the output data (hours X latitudes X seasons)
		if(one==0) {
	    tmp.down_vis=tmp.down_ir=tmp.tatm=tmp.tbol=tmp.tsurf=create(length(data),dim(data[1][1])[1],NSOUT,start=0,step=0,format=dtype)

			#create another output data arrray (1 X latitudes X seasons)
	    anc.converge_days=anc.delta_t_rms=anc.tatm_predict=anc.frost=anc.frost_alb=anc.avg_heat_flow=create(1,dim(data[1][1])[1],NSOUT,start=0,step=0,format=dtype)

		#create yet another output data array (layer X latitudes X seasons)
			layer.tmin=layer.tmax=create(NumLayers-1,dim(data[1][1])[1],NSOUT,start=0,step=0,format=dtype)
		} else {
			tmp.tsurf=create(length(data),dim(data[1][1])[1],NSOUT,start=0,step=0,format=dtype)
		}

		#the data actually starts at NDX+1
		start=NDX+1

    #extract the specific data for each parameter
    for (i=1;i<=length(data);i+=1) {
      for(j=1;j<=dim(data[1][1])[1];j+=1) {

        tmp.tsurf[i,j]=translate(data[i][1][j,start:,k],y,z)
				if(one==0) {
	        tmp.tbol[i,j]=translate(data[i][2][j,start:,k],y,z)
	        tmp.tatm[i,j]=translate(data[i][3][j,start:,k],y,z)
	        tmp.down_vis[i,j]=translate(data[i][4][j,start:,k],y,z)
	        tmp.down_ir[i,j]=translate(data[i][5][j,start:,k],y,z)

					#extract the 6 and 7 items.
					#these are packed with various things...which is why there is so much code
					if(i==1) {
						anc.converge_days[,j]=translate(data[i][6][j,start:,k],y,z)
						anc.frost[,j]=translate(data[i][7][j,start:,k],y,z)
					} else if(i==2) {
						anc.delta_t_rms[,j]=translate(data[i][6][j,start:,k],y,z)
						anc.frost_alb[,j]=translate(data[i][7][j,start:,k],y,z)
					} else if(i==3) {
						anc.tatm_predict[,j]=translate(data[i][6][j,start:,k],y,z)
						anc.avg_heat_flow[,j]=translate(data[i][7][j,start:,k],y,z)
					} else {
						if(i-3<NumLayers) {
							layer.tmin[i-3,j]=translate(data[i][6][j,start:,k],y,z)
							layer.tmax[i-3,j]=translate(data[i][7][j,start:,k],y,z)
						}
					}
				}
      }
    }

		#set the time output structure
	  tmp.time=time

		if(TUN8!=0) {
			#8 6 character header bytes that define the file size
			dir=dirname($1)
			header=unpack("a6*8",dir+"/fort.77",count=1)
			cols=atoi(header.c1_1)-3
			times=atoi(header.c1_2)
			seasons=atoi(header.c1_4)

			if(TUN8==101) {
				#13 characters that define x, y, z
				#N-cols 8 characters that are all of the layers or atmospheric parameters
				TUN8_out=unpack(sprintf("a13a8*%i",cols),dir+"/fort.77",skip=48)

				#make an output-layer array
				col_array=create(cols,length(TUN8_out[2]),1,start=0,step=0,format=float)

				#turn it into a float
				for(i=2;i<=cols+1;i+=1) {
					col_array[i-1]=atof(TUN8_out[i])
				}

				#resize it so that its an xyz array and the right orientation.
				resize(col_array,cols,times,seasons)
				col_array=translate(col_array,y,x)

				#this is the case for temperature with depth
				tmp.tsurf=cat(tmp.tsurf,double(col_array),axis=y)
				tmp.depth=translate(cat(layer.top[1,2],layer.center[1:,2],axis=x),x,y)

			#atmospheric parameter atmospheric parameters
			} else if (TUN8==102) {
				#14 characters that define x, y, z
				#N-cols 8 characters that are all of the layers or atmospheric parameters
				TUN8_out=unpack(sprintf("a14a8*%i",cols),dir+"/fort.77",skip=48)

				#make an output-layer array
				col_array=create(cols,length(TUN8_out[2]),1,start=0,step=0,format=float)

				#turn it into a float
				for(i=2;i<=cols+1;i+=1) {
					col_array[i-1]=atof(TUN8_out[i])
				}

				#resize it so that its an xyz array and the right orientation.
				resize(col_array,cols,times,seasons)
				col_array=translate(col_array,y,x)

				atmparams={}
				atmparams.col_insol=col_array[,1]
				atmparams.diffuse_flux=col_array[,2]
				atmparams.atm_kinetic_T=col_array[,3]
				atmparams.apparent_zenith_sky_T=col_array[,4]
				atmparams.hemispheric_sky_T=col_array[,5]

				anc.atm_extras=atmparams

			} else {
				printf("Invalid TUN8 type: 101 or 102 are permitted\n")
			}
		}


    #Generate the output structure
    tmp.ls=datals

		#make a delta Julian Date Xaxis that is easy to use for slow rotating bodies
		tmp.deltaJD=tmp.tsurf*0
    anc.JDate = double(prefix[,,:NSOUT])+J2000                                  #DEBUG HERE 04/09/2020
    #anc.JDate = JD #solves the variable not found / math operation illegal
		tmp.deltaJD[1]=anc.JDate
		delJDate=double((anc.JDate[,,2]-anc.JDate[,,1]))/double(dim(tmp.deltaJD)[1])
		ramp=create(dim(tmp.deltaJD)[1],1,1,start=0,step=delJDate,format=float)
		tmp.deltaJD=double(clone(tmp.deltaJD[1,,],x=dim(tmp.deltaJD)[1])+ramp)-anc.JDate[,,1]
		if(hour!=-32768 || ls!=-32768) {
			remove_struct(tmp,"deltaJD")
		}

		if(one==0) {
			#add the elevations and latitutdes to the output structure
			tmp.lat=translate(anc.krccom.lats[:dim(data[1][1])[1]],x,y)
			tmp.elev=translate(anc.krccom.elevs[:dim(data[1][1])[1]],x,y)
			remove_struct(anc.krccom,"lats")
			remove_struct(anc.krccom,"elevs")

			tmp.layer=layer
			tmp.anc=anc
		}


    #resample all the elements to the  specified hour
    if(hour!=-32768) {
			if(one==0) {
				hourresamp=cat("tmp.down_ir","tmp.down_vis","tmp.tatm","tmp.tbol","tmp.tsurf","tmp.time",axis=y)
			} else {
				hourresamp=text(1)
				hourresamp[,1]="tmp.tsurf"
			}

			for(i=1;i<=length(hourresamp);i+=1) {
				#extract the data into a temporary array
				command=sprintf("resamptemp=%s\n",hourresamp[,i])
				eval(command)

				#get the data dimension
				resampdim=dim(resamptemp)[1]

				#buffer the various arrays appropriately...note tmp.time must be handeled differently
				timetemp=format(cat(time[resampdim]-24.,time,axis=x),format=dtype)

				if(hourresamp[,i]=="tmp.time") {
					resamptemp=timetemp
				} else {
					resamptemp=cat(resamptemp[resampdim],resamptemp,axis=x)
				}

				command=sprintf("%s=format(translate(resample(translate(resamptemp,x,z),translate(timetemp,x,z),clone(hour,z=2)).data[,,1],z,x),format=dtype)",hourresamp[,i])
				eval(command)
			}
    }

    #resample all the elements to the specified ls
    if(ls!=-32768) {
			if(one==0) {
				lsresamp=cat("tmp.down_ir","tmp.down_vis","tmp.tatm","tmp.tbol","tmp.tsurf","tmp.ls","tmp.layer.tmin","tmp.layer.tmax",axis=y)
				lsresamp=cat(lsresamp,"tmp.anc."+get_struct_key(tmp.anc)[,2:],axis=y)
			} else {
				lsresamp=text(1)
				lsresamp[,1]="tmp.tsurf"
			}

			for(i=1;i<=length(lsresamp);i+=1) {

				#extract the data into a temporary array
				command=sprintf("resamptemp=%s\n",lsresamp[,i])
				eval(command)

				#get the data dimension
				resampdim=dim(resamptemp)[3]

				#buffer the various arrays appropriately...note tmp.ls must be handeled differently
				datalstemp=format(cat(datals[,,resampdim]-360,datals,datals[,,1]+360,axis=z),format=dtype)

				if(lsresamp[,i]=="tmp.ls") {
					resamptemp=datalstemp
				} else {
					resamptemp=cat(resamptemp[,,resampdim],resamptemp,resamptemp[,,1],axis=z)
				}

				#execute the resample command with the buffered data so that we can interpolate from 0 to 360 without extrapolation
				command=sprintf("%s=format(resample(resamptemp,datalstemp,clone(ls,z=2)).data[,,1],format=dtype)",lsresamp[,i])
				eval(command)
			}
    }

    if(dim(data[1][1])[3] == 1) {
      out=tmp
    } else {
      add_struct(obj=out,val=tmp,name="case"+k)
    }
  }

  if(raw!=0) {
    out.raw=data
  }

	out.version=sprintf("v%i.%i.%i",Mversion,mversion,rversion)

  if(JD!=0){                                                                    #These Lines eliminate all the unrequested seasons
	  for(i=1;i<=length(out);i+=1){
	    if(type(out[i])!="STRUCT"){
	      out[i]=out[i][,,1]
	    }
	  }
		if(HasValue(out.anc.JDate)==1)               out.anc.JDate=out.anc.JDate[1,1,1]
#		if(HasValue(out.anc)==1 && HasValue(GD)==1)  out.anc.GDate=GD+""
  }




	printf("\n")
  return(out)
}



define ltst2lmst(LS,T,LT){
  if($ARGC==0){
    printf("    Resamples a Temperature and/or a LTST array to LMST\n")
    printf("    LS: Heliocentric Longitude\n")
    printf("    T: Temperature Array\n")
    printf("    LT: Local True Solar Time Array\n")
    printf("    All conversions evaluated for one Mars Year at J2000 (noon Jan 1, 2000 TT); i.e., ΔtJ2000 = 0\n")
    printf("    Returns .LMST, resampled local time (same Temperatures)\n")
    printf("    Returns .TLMST, resampled temperatures (same time axis, but in LMST)\n")
  }

  if($ARGC!=0){
    LS          = $1
    T           = $2
    LT          = $3
    LTST        = 12.                                                           #Difference between LTST and LMST is small over one sol, so we pick noon but
    tj2000      = create(10^4,1,start=0,step=688/1e4,format=float)              #ΔtJ2000
    aFMS        = 270.3871 + 0.524038496*tj2000                                 #αFMS = 270.3871° + 0.524038496° ΔtJ2000
    M           = 19.3871 + (0.52402073*tj2000)                                 #M = 19.3871° + 0.52402073° ΔtJ2000
    PBS         = 0.                                                            #PBS = Σ(i=1,7) Ai cos [ (0.985626° ΔtJ2000 / τi) + φi
    PBSmat      = create(3,7,format=double)
    PBSmat[1,,] = cat(0.0071,0.0057,0.0039,0.0037,0.0021,0.002,0.0018,axis=y)
    PBSmat[2,,] = cat(2.23530,2.75430,1.11770,15.7866,2.13540,2.46940,32.8493,axis=y)
    PBSmat[3,,] = cat(49.4090,168.173,191.837,21.7360,15.7040,95.5280,49.0950,axis=y)

    for(i=1;i<=7;i+=1){
      PBS = PBS + PBSmat[1,i]*cosd((0.985626*tj2000/PBSmat[2,i])+PBSmat[3,i])
    }

    vmM         = (10.691+(3.0*10e-7*tj2000))*sind(M)+0.623*sind(2*M)+0.050*sind(3*M)+0.005*sind(4*M)+0.0005*sind(5*M)+PBS
    Ls          = aFMS + vmM                                                    #ν - M = (10.691° + 3.0° × 10-7 ΔtJ2000) sin M + 0.623° sin 2M + 0.050° sin 3M + 0.005° sin 4M + 0.0005° sin 5M + PBS
    EOT         = 2.861*sind(2*Ls)-0.071*sind(4*Ls)+0.002*sind(6*Ls)-vmM        #EOT = 2.861° sin 2Ls - 0.071° sin 4Ls + 0.002° sin 6Ls - (ν - M)
    LMST        = LTST-EOT*(1./15)                                              #LTST = LMST+EOT*(1./15)
    shift       = LMST-LTST                                                     #Difference between LMST and LTST tied to LS
    Ls[where Ls>360]=Ls-360.                                                    #Set all LS values between 0 and 360

    #Setup arrays for local time & T, equal to input array dimensions
    #LT array based off size of T array (should one exist)
    #A single T will be ignored and a single LT will be ignored if an array of T is passed

    if(HasValue(T)==1 && dim(T)[1]>1){
      LT=create(dim(T)[1],start=24./dim(T)[1],step=24./dim(T)[1],format=double)
      LMST_arr=create(dim(T)[1],1,int(max(dim(LS))),start=0,step=0,format=double)
      TLMST=T*0.
    } else {
      LMST_arr=create(dim(LT)[1],1,int(max(dim(LS))),start=0,step=0,format=double)
    }

    #Cycle through solar longitude (which determines LTST/LMST shift) to generate an array of local times in LMST (for each index of solar longitude)
    for(j=1;j<=dim(LS)[3];j+=1){                                                #Generate equivalent LMST times for model time array (in LTST)
      LMST_arr[,,j]=LT+shift[minpos(abs(Ls-LS[,,j]))]
      if(HasValue(T)==1 && dim(T)[1]>1){                                        #Generate temperature array that ties to original time array as though it were in LMST
        TLMST[,,j]=interp(T[,,j],24+LMST_arr[,,j],24+LT[,,],type='linear')      #We add '24' to each quantity to avoid erroneous interp
      }
      LMST_arr[where LMST_arr>24.]=LMST_arr-24.                                 #Modify new time arrays so time <24 and >0
      LMST_arr[where LMST_arr<0.]=LMST_arr+24.                                  #Modify new time arrays so time <24 and >0
    }

  OUT={}                                                                        #Put output arrays into structure 'OUT'
  OUT.LMST=LMST_arr
  if(HasValue(TLMST)==1 && dim(T)[1]>1) OUT.TLMST=TLMST
  return(OUT)
  }
}

define Mat_Prop(Mat,PLOT){
  if($ARGC==0){
    printf("Calculates Default k(T), Cp(T), and Density Parameters\n")
    printf("Returns a structure with KRC Coefficients\n")
    printf(" $1: Material (Default is basalt)\n")
    printf(" \"H2O\", \"CO2\", \"N2\", \"CH4\", \"SO2\" \n")
    printf(" $2: Plot (Default is \"F\")\n")
  }

  if($ARGC!=0){
    Mat          = $1
    PLOT         = $2

    T_min        = 10.
    T_max        = 600.
    T_Step       = 10.0
    T_NUM        = int(1 + (T_max - T_min)/T_Step)
    T            = create(T_NUM,1,1,start=T_min,step=T_Step,format=float)
    X            = (T-220.)*0.01
    S            = {}
    S.Cp         = S.Dens       = S.k          = {}
    S.Cp.Sph0    = S.Cp.Sph1    = S.Cp.Sph2    = S.Cp.Sph3    = {}
    S.k.Con0     = S.k.Con1     = S.k.Con2     = S.k.Con3     = {}
    S.Dens.Dens0 = S.Dens.Dens1 = S.Dens.Dens2 = S.Dens.Dens3 = {}

    if(Mat == "H2O"){
      S.Cp.Sph0      = 1704.57
      S.Cp.Sph1      = 713.339
      S.Cp.Sph2      = 110.694
      S.Cp.Sph3      = 75.7506
      S.Cp.Ref       = "The Entropy of Water and the Third Law of Thermodynamics. The Heat Capacity of Ice from 15 to 273°K."
      S.Cp.Ref       = cat(S.Cp.Ref,"W. F. GiauqueJ. W. Stout",axis=y)
      S.Cp.Ref       = cat(S.Cp.Ref,"J. Am. Chem. Soc. 1936, 58, 7, 1144-1150",axis=y)
      S.Cp.Ref       = cat(S.Cp.Ref,"July 1, 1936",axis=y)
      S.Cp.Ref       = cat(S.Cp.Ref,"doi.org/10.1021/ja01298a023",axis=y)
      S.Cp.Note      = "COMMENTS ABOUT THE FITS, DOMAIN OF VALIDITY; WHERE THE FITS ARE ETC."
      S.Cp.Tmin      = 15.
      S.Cp.Tmax      = 273.
      Cp_Table       = S.Cp.Sph0 + S.Cp.Sph1*X + S.Cp.Sph2*X^2 +S.Cp.Sph3*X^3
      Cp_Table[where (T<S.Cp.Tmin)||(T>S.Cp.Tmax)] = -999.
      if(PLOT == "T"){
        labelxy("Temperature [K]","Cp [J kg^-1 K^-1]","Cp\(T\) H2O")
        plot(Cp_Table,w=3,color=2,xaxis=T,ignore=-999.,"Cp\(T\) for H2O")
      }
      S.k.Con0     = 3.06445
      S.k.Con1     = -1.08693
      S.k.Con2     = -0.33438
      S.k.Con3     = -1.60453
      S.k.Ref      = "Thermal conductivity of ice"
      S.k.Ref      = cat(S.k.Ref,"Glen A. Slack",axis=y)
      S.k.Ref      = cat(S.k.Ref,"Phys. Rev. B 22, 3065",axis=y)
      S.k.Ref      = cat(S.k.Ref,"15 September 1980", axis=y)
      S.k.Ref      = cat(S.k.Ref,"doi.org/10.1103/PhysRevB.22.3065",axis=y)
      S.k.Note     = "COMMENTS ABOUT THE FITS, DOMAIN OF VALIDITY; WHERE THE FITS ARE ETC."
      S.k.Tmin     = 60.                                                              #VERiFY THIS
      S.k.Tmax     = 270.                                                             #VERiFY THIS
      k_Table      = S.k.Con0 + S.k.Con1*X + S.k.Con2*X^2 +S.k.Con3*X^3
      k_Table[where (T<S.k.Tmin)||(T>S.k.Tmax)] = -999.
      if(PLOT == "T"){
        labelxy("Temperature [K]","k [J m^-1 K^-1 s^-1]","k\(T\) H2O")
        plot(k_Table,w=3,color=2,xaxis=T,ignore=-999.,"k\(T\) for H2O")
      }
      S.Dens.Dens0 = 924.148
      S.Dens.Dens1 = -12.1406
      S.Dens.Dens2 = -3.71136
      S.Dens.Dens3 = 0.036026
      S.Dens.Ref   = "Lattice constants and thermal expansion of H2O and D2O ice Ih between 10 and 265 K. Addendum."
      S.Dens.Ref   = cat(S.Dens.Ref,"Röttger K, Endriss A, Ihringer J, Doyle S, Kuhs WF.",axis=y)
      S.Dens.Ref   = cat(S.Dens.Ref,"Acta Crystallogr B. 2012 Feb\;68\(Pt 1\):91.",axis=y)
      S.Dens.Ref   = cat(S.Dens.Ref,"6 January 2012",axis=y)
      S.Dens.Ref   = cat(S.Dens.Ref,"doi: 10.1107/S0108768111046908",axis=y)
      S.Dens.Note  = "COMMENTS ABOUT THE FITS, DOMAIN OF VALIDITY; WHERE THE FITS ARE ETC."
      S.Dens.Tmin  = 10.                                                              #VERiFY THIS
      S.Dens.Tmax  = 265.                                                             #VERiFY THIS
      Dens_Table   = S.Dens.Dens0 + S.Dens.Dens1*X + S.Dens.Dens2*X^2 +S.Dens.Dens3*X^3
      Dens_Table[where (T<S.Dens.Tmin)||(T>S.Dens.Tmax)] = -999.
      if(PLOT == "T"){
        labelxy("Temperature [K]","Density [kg m^-3]","Density\(T\) H2O")
        plot(Dens_Table,w=3,color=2,xaxis=T,ignore=-999.,"Density\(T\) for H2O")
      }
    }

    if(Mat == "basalt"){
      S.Cp.Sph0    = 609.906
      S.Cp.Sph1    = 214.231
      S.Cp.Sph2    = -40.9437
      S.Cp.Sph3    = 11.2575
      S.Cp.Ref     = "Specific heats of lunar soils, basalt, and breccias from the Apollo 14, 15, and 16 landing sites, between 90 and 350°K"
      S.Cp.Ref     = cat(S.Cp.Ref,"Hemingway, B. S.; Robie, R. A.; Wilson, W. H.",axis=y)
      S.Cp.Ref     = cat(S.Cp.Ref,"Proceedings of the Lunar Science Conference, vol. 4, p.2481",axis=y)
      S.Cp.Ref     = cat(S.Cp.Ref,"1973",axis=y)
      S.Cp.Ref     = cat(S.Cp.Ref,"1973LPSC....4.2481H",axis=y)
      S.Cp.Note    = "COMMENTS ABOUT THE FITS, DOMAIN OF VALIDITY; WHERE THE FITS ARE ETC."
      S.Cp.Tmin    = 90.
      S.Cp.Tmax    = 350.
      Cp_Table     = S.Cp.Sph0 + S.Cp.Sph1*X + S.Cp.Sph2*X^2 +S.Cp.Sph3*X^3
      Cp_Table[where (T<S.Cp.Tmin)||(T>S.Cp.Tmax)] = -999.
      if(PLOT == "T"){
        labelxy("Temperature [K]","Cp [J kg^-1 K^-1]","Cp\(T\) Basalt")
        plot(Cp_Table,w=3,color=2,xaxis=T,ignore=-999.,"Cp\(T\) for Basalt")
      }
      S.k.Con0     = 5.32202                                                          #VERiFY THIS
      S.k.Con1     = -1.51737                                                         #VERiFY THIS
      S.k.Con2     = 0.587176                                                         #VERiFY THIS
      S.k.Con3     = -0.126695                                                        #VERiFY THIS
      S.k.Ref      = "NO REFERENCE; REDO THIS SECTION"
      S.k.Note     = "COMMENTS ABOUT THE FITS, DOMAIN OF VALIDITY; WHERE THE FITS ARE ETC."
      S.k.Tmin     = 10.                                                              #VERiFY THIS
      S.k.Tmax     = 500.                                                             #VERiFY THIS
      k_Table      = S.k.Con0 + S.k.Con1*X + S.k.Con2*X^2 +S.k.Con3*X^3
      k_Table[where (T<S.k.Tmin)||(T>S.k.Tmax)] = -999.
      if(PLOT == "T"){
        labelxy("Temperature [K]","k [J m^-1 K^-1 s^-1]","k\(T\) Basalt")
        plot(k_Table,w=3,color=2,xaxis=T,ignore=-999.,"k\(T\) for Basalt")
      }
      S.Dens.Dens0 = 2600.0000
      S.Dens.Dens1 = 1E-5
      S.Dens.Dens2 = 0.
      S.Dens.Dens3 = 0.
      S.Dens.Ref   = "High-temperature mechanical, physical and thermal properties of granitic rocks: A review."
      S.Dens.Ref   = cat(S.Dens.Ref,"F.E. Heuze.",axis=y)
      S.Dens.Ref   = cat(S.Dens.Ref,"Int. J. Rock Mech. Mining Sci., 20:3–10",axis=y)
      S.Dens.Ref   = cat(S.Dens.Ref,"Feb. 1983.",axis=y)
      S.Dens.Ref   = cat(S.Dens.Ref,"https://doi.org/10.1016/0148-9062(83)91609-1",axis=y)
      S.Dens.Note  = "COMMENTS ABOUT THE FITS, DOMAIN OF VALIDITY; WHERE THE FITS ARE ETC."
      S.Dens.Tmin  = 90.                                                              #VERiFY THIS
      S.Dens.Tmax  = 350.                                                             #VERiFY THIS
      Dens_Table   = S.Dens.Dens0 + S.Dens.Dens1*X + S.Dens.Dens2*X^2 +S.Dens.Dens3*X^3
      Dens_Table[where (T<S.Dens.Tmin)||(T>S.Dens.Tmax)] = -999.
      if(PLOT == "T"){
        labelxy("Temperature [K]","Density [kg m^-3]","Density\(T\) Basalt")
        plot(Dens_Table,w=3,color=2,xaxis=T,ignore=-999.,"Density\(T\) for Basalt")
      }
    }

    if(Mat == "CO2"){
      S.Cp.Sph0    = 1399.88
      S.Cp.Sph1    = 652.64
      S.Cp.Sph2    = 432.015
      S.Cp.Sph3    = 192.398
      S.Cp.Ref     = "Solar System Ices"
      S.Cp.Ref     = cat(S.Cp.Ref,"Table XX, pp XXX-XXX",axis=y)                      #Update this Reference
      S.Cp.Ref     = cat(S.Cp.Ref,"https://doi.org/10.1007/978-94-011-5252-5",axis=y)
      S.Cp.Note    = "COMMENTS ABOUT THE FITS, DOMAIN OF VALIDITY; WHERE THE FITS ARE ETC."
      S.Cp.Tmin    = 50.                                                              #VERiFY THIS
      S.Cp.Tmax    = 230.                                                             #VERiFY THIS
      Cp_Table     = S.Cp.Sph0 + S.Cp.Sph1*X + S.Cp.Sph2*X^2 +S.Cp.Sph3*X^3
      Cp_Table[where (T<S.Cp.Tmin)||(T>S.Cp.Tmax)] = -999.
      if(PLOT == "T"){
        labelxy("Temperature [K]","Cp [J kg^-1 K^-1]","Cp\(T\) CO2")
        plot(Cp_Table,w=3,color=2,xaxis=T,ignore=-999.,"Cp\(T\) for CO2")
      }
      S.k.Con0     = 0.441346
      S.k.Con1     = -0.0686357
      S.k.Con2     = 0.425127
      S.k.Con3     = 0.233004
      S.k.Ref      = "Solar System Ices"
      S.k.Ref      = cat(S.k.Ref,"Table XX, pp XXX-XXX",axis=y)                       #Update this Reference
      S.k.Ref      = cat(S.k.Ref,"https://doi.org/10.1007/978-94-011-5252-5",axis=y)
      S.k.Note     = "COMMENTS ABOUT THE FITS, DOMAIN OF VALIDITY; WHERE THE FITS ARE ETC."
      S.k.Tmin     = 50.                                                              #VERiFY THIS
      S.k.Tmax     = 230.                                                             #VERiFY THIS
      k_Table      = S.k.Con0 + S.k.Con1*X + S.k.Con2*X^2 +S.k.Con3*X^3
      k_Table[where (T<S.k.Tmin)||(T>S.k.Tmax)] = -999.
      if(PLOT == "T"){
        labelxy("Temperature [K]","k [J m^-1 K^-1 s^-1]","k\(T\) CO2")
        plot(k_Table,w=3,color=2,xaxis=T,ignore=-999.,"k\(T\) for CO2")
      }
      S.Dens.Dens0 = 1529.32
      S.Dens.Dens1 = -151.68
      S.Dens.Dens2 = -28.8237
      S.Dens.Dens3 = -0.042309
      S.Dens.Ref   = "Solar System Ices"
      S.Dens.Ref   = cat(S.Dens.Ref,"Table XX, pp XXX-XXX",axis=y)                    #Update this Reference
      S.Dens.Ref   = cat(S.Dens.Ref,"https://doi.org/10.1007/978-94-011-5252-5",axis=y)
      S.Dens.Note  = "COMMENTS ABOUT THE FITS, DOMAIN OF VALIDITY; WHERE THE FITS ARE ETC."
      S.Dens.Tmin  = 50.                                                              #VERiFY THIS
      S.Dens.Tmax  = 230.                                                             #VERiFY THIS
      Dens_Table   = S.Dens.Dens0 + S.Dens.Dens1*X + S.Dens.Dens2*X^2 +S.Dens.Dens3*X^3
      Dens_Table[where (T<S.Dens.Tmin)||(T>S.Dens.Tmax)] = -999.
      if(PLOT == "T"){
        labelxy("Temperature [K]","Density [kg m^-3]","Density\(T\) CO2")
        plot(Dens_Table,w=3,color=2,xaxis=T,ignore=-999.,"Density\(T\) for CO2")
      }
    }

    if(Mat == "N2"){
      S.Cp.Sph0    = 6137.28
      S.Cp.Sph1    = 4082.15
      S.Cp.Sph2    = 789.538
      S.Cp.Sph3    = -0.109612
      S.Cp.Ref     = "Solar System Ices"
      S.Cp.Ref     = cat(S.Cp.Ref,"Table XX, pp XXX-XXX",axis=y)                      #Update this Reference
      S.Cp.Ref     = cat(S.Cp.Ref,"https://doi.org/10.1007/978-94-011-5252-5",axis=y)
      S.Cp.Note    = "COMMENTS ABOUT THE FITS, DOMAIN OF VALIDITY; WHERE THE FITS ARE ETC."
      S.Cp.Tmin    = 50.                                                              #VERiFY THIS
      S.Cp.Tmax    = 230.                                                             #VERiFY THIS
      Cp_Table     = S.Cp.Sph0 + S.Cp.Sph1*X + S.Cp.Sph2*X^2 +S.Cp.Sph3*X^3
      Cp_Table[where (T<S.Cp.Tmin)||(T>S.Cp.Tmax)] = -999.
      if(PLOT == "T"){
        labelxy("Temperature [K]","Cp [J kg^-1 K^-1]","Cp\(T\) N2")
        plot(Cp_Table,w=3,color=2,xaxis=T,ignore=-999.,"Cp\(T\) for N2")
      }
      S.k.Con0     = 0.07
      S.k.Con1     = 0.
      S.k.Con2     = 0.
      S.k.Con3     = 0.
      S.k.Ref      = "The density and thermal conductivity of solid nitrogen and carbon dioxide"
      S.k.Ref      = cat(S.k.Ref,"T.Cook and G.Davey",axis=y)
      S.k.Ref      = cat(S.k.Ref,"Cryogenics, Volume 16, Issue 6, pp 363-369",axis=y)
      S.k.Ref      = cat(S.k.Ref,"June 1976", axis=y)
      S.k.Ref      = cat(S.k.Ref,"https://doi.org/10.1016/0011-2275(76)90217-4",axis=y)
      S.k.Note     = "COMMENTS ABOUT THE FITS, DOMAIN OF VALIDITY; WHERE THE FITS ARE ETC."
      S.k.Tmin     = 0.
      S.k.Tmax     = 230.
      k_Table      = S.k.Con0 + S.k.Con1*X + S.k.Con2*X^2 +S.k.Con3*X^3
      k_Table[where (T<S.k.Tmin)||(T>S.k.Tmax)] = -999.
      if(PLOT == "T"){
        labelxy("Temperature [K]","k [J m^-1 K^-1 s^-1]","k\(T\) N2")
        plot(k_Table,w=3,color=2,xaxis=T,ignore=-999.,"k\(T\) for N2")
      }
      S.Dens.Dens0 = 689.066
      S.Dens.Dens1 = -170.064
      S.Dens.Dens2 = -1.32878
      S.Dens.Dens3 = -0.450622
      S.Dens.Ref   = "Solar System Ices"
      S.Dens.Ref   = cat(S.Dens.Ref,"Table XX, pp XXX-XXX",axis=y)                    #Update this Reference
      S.Dens.Ref   = cat(S.Dens.Ref,"https://doi.org/10.1007/978-94-011-5252-5",axis=y)
      S.Dens.Note  = "COMMENTS ABOUT THE FITS, DOMAIN OF VALIDITY; WHERE THE FITS ARE ETC."
      S.Dens.Tmin  = 0.
      S.Dens.Tmax  = 63.
      Dens_Table   = S.Dens.Dens0 + S.Dens.Dens1*X + S.Dens.Dens2*X^2 +S.Dens.Dens3*X^3
      SDens_Table[where (T<S.Dens.Tmin)||(T>S.Dens.Tmax)] = -999.
      if(PLOT == "T"){
        labelxy("Temperature [K]","Density [kg m^-3]","Density\(T\) N2")
        plot(S.Dens_Table,w=3,color=2,xaxis=T,ignore=-999.,"Density\(T\) for N2")
      }
    }

    if(Mat == "SO2"){
      S.Cp.Sph0    = 1132.09
      S.Cp.Sph1    = 364.914
      S.Cp.Sph2    = 127.915
      S.Cp.Sph3    = 77.4213
      S.Cp.Ref     = "Solar System Ices"
      S.Cp.Ref     = cat(S.Cp.Ref,"Table XX, pp XXX-XXX",axis=y)                      #Update this Reference
      S.Cp.Ref     = cat(S.Cp.Ref,"https://doi.org/10.1007/978-94-011-5252-5",axis=y)
      S.Cp.Note    = "COMMENTS ABOUT THE FITS, DOMAIN OF VALIDITY; WHERE THE FITS ARE ETC."
      S.Cp.Tmin    = 10.                                                              #VERiFY THIS
      S.Cp.Tmax    = 200.
      Cp_Table     = S.Cp.Sph0 + S.Cp.Sph1*X + S.Cp.Sph2*X^2 +S.Cp.Sph3*X^3
      Cp_Table[where (T<S.Cp.Tmin)||(T>S.Cp.Tmax)] = -999.
      if(PLOT == "T"){
        labelxy("Temperature [K]","Cp [J kg^-1 K^-1]","Cp\(T\) SO2")
        plot(Cp_Table,w=3,color=2,xaxis=T,ignore=-999.,"Cp\(T\) for SO2")
      }
      S.k.Con0     = 0.
      S.k.Con1     = 0.
      S.k.Con2     = 0.
      S.k.Con3     = 0.
      S.k.Ref      = "N/A"
      S.k.Note     = "COMMENTS ABOUT THE FITS, DOMAIN OF VALIDITY; WHERE THE FITS ARE ETC."
      S.k.Tmin     = 0.
      S.k.Tmax     = 0.
      k_Table      = S.k.Con0 + S.k.Con1*X + S.k.Con2*X^2 +S.k.Con3*X^3
      k_Table[where (T<S.k.Tmin)||(T>S.k.Tmax)] = -999.
      if(PLOT == "T"){
        labelxy("Temperature [K]","k [J m^-1 K^-1 s^-1]","k\(T\) SO2")
        plot(k_Table,w=3,color=2,xaxis=T,ignore=-999.,"k\(T\) for SO2")
      }
      S.Dens.Dens0 = 1785.86
      S.Dens.Dens1 = -130.959
      S.Dens.Dens2 = 0.222652
      S.Dens.Dens3 = 0.00610492
      S.Dens.Ref   = "Solar System Ices"
      S.Dens.Ref   = cat(S.Dens.Ref,"Table XX, pp XXX-XXX",axis=y)                    #Update this Reference
      S.Dens.Ref   = cat(S.Dens.Ref,"https://doi.org/10.1007/978-94-011-5252-5",axis=y)
      S.Dens.Note  = "COMMENTS ABOUT THE FITS, DOMAIN OF VALIDITY; WHERE THE FITS ARE ETC."
      S.Dens.Tmin  = 10.
      S.Dens.Tmax  = 200.
      Dens_Table   = S.Dens.Dens0 + S.Dens.Dens1*X + S.Dens.Dens2*X^2 +S.Dens.Dens3*X^3
      Dens_Table[where (T<S.Dens.Tmin)||(T>S.Dens.Tmax)] = -999.
      if(PLOT == "T"){
        labelxy("Temperature [K]","Density [kg m^-3]","Density\(T\) SO2")
        plot(Dens_Table,w=3,color=2,xaxis=T,ignore=-999.,"Density\(T\) for SO2")
      }
    }

    if(Mat == "CH4"){
      S.Cp.Sph0    = 18356.1
      S.Cp.Sph1    = 29096.3
      S.Cp.Sph2    = 18515.3
      S.Cp.Sph3    = 4143.07
      S.Cp.Ref     = "Solar System Ices"
      S.Cp.Ref     = cat(S.Cp.Ref,"Table XX, pp XXX-XXX",axis=y)                      #Update this Reference
      S.Cp.Ref     = cat(S.Cp.Ref,"https://doi.org/10.1007/978-94-011-5252-5",axis=y)
      S.Cp.Note    = "COMMENTS ABOUT THE FITS, DOMAIN OF VALIDITY; WHERE THE FITS ARE ETC."
      S.Cp.Tmin    = 10.
      S.Cp.Tmax    = 100.
      Cp_Table     = S.Cp.Sph0 + S.Cp.Sph1*X + S.Cp.Sph2*X^2 +S.Cp.Sph3*X^3
      Cp_Table[where (T<S.Cp.Tmin)||(T>S.Cp.Tmax)] = -999.
      if(PLOT == "T"){
        labelxy("Temperature [K]","Cp [J kg^-1 K^-1]","Cp\(T\) CH4")
        plot(Cp_Table,w=3,color=2,xaxis=T,ignore=-999.,"Cp\(T\) for CH4")
      }
      S.k.Con0     = 0.0308666
      S.k.Con1     = 0.071247
      S.k.Con2     = 0.289212
      S.k.Con3     = 0.0617607
      S.k.Ref      = "Solar System Ices"
      S.k.Ref      = cat(S.k.Ref,"Table XX, pp XXX-XXX",axis=y)                       #Update this Reference
      S.k.Ref      = cat(S.k.Ref,"https://doi.org/10.1007/978-94-011-5252-5",axis=y)
      S.k.Note     = "COMMENTS ABOUT THE FITS, DOMAIN OF VALIDITY; WHERE THE FITS ARE ETC."
      S.k.Tmin     = 10.
      S.k.Tmax     = 100.
      k_Table      = S.k.Con0 + S.k.Con1*X + S.k.Con2*X^2 +S.k.Con3*X^3
      k_Table[where (T<S.k.Tmin)||(T>S.k.Tmax)] = -999.
      if(PLOT == "T"){
        labelxy("Temperature [K]","k [J m^-1 K^-1 s^-1]","k\(T\) CH4")
        plot(k_Table,w=3,color=2,xaxis=T,ignore=-999.,"k\(T\) for CH4")
      }
      S.Dens.Dens0 = 353.207
      S.Dens.Dens1 = -136.08
      S.Dens.Dens2 = -26.7422
      S.Dens.Dens3 = -0.794846
      S.Dens.Ref   = "Solar System Ices"
      S.Dens.Ref   = cat(S.Dens.Ref,"Table XX, pp XXX-XXX",axis=y)                    #Update this Reference
      S.Dens.Ref   = cat(S.Dens.Ref,"https://doi.org/10.1007/978-94-011-5252-5",axis=y)
      S.Dens.Note  = "COMMENTS ABOUT THE FITS, DOMAIN OF VALIDITY; WHERE THE FITS ARE ETC."
      S.Dens.Tmin  = 10.
      S.Dens.Tmax  = 100.
      Dens_Table   = S.Dens.Dens0 + S.Dens.Dens1*X + S.Dens.Dens2*X^2 +S.Dens.Dens3*X^3
      Dens_Table[where (T<S.Dens.Tmin)||(T>S.Dens.Tmax)] = -999.
      if(PLOT == "T"){
        labelxy("Temperature [K]","Density [kg m^-3]","Density\(T\) CH4")
        plot(Dens_Table,w=3,color=2,xaxis=T,ignore=-999.,"Density\(T\) for CH4")
      }
    }
  }
return(S)
}

define krc_ls(ls){
  if($ARGC == 0){
    printf("Calculates the index of a season on Mars with KRC\n")
    printf("$1: Ls \n")
                 }
  if($ARGC != 0){
    ls_1   = translate(0.10//1.05//1.99//2.94//3.88//4.82//5.76//6.69//7.62//8.55//9.48//10.40//11.33//12.24//13.16//14.07//14.99//15.90//16.80//17.71//18.61//19.51//20.41//21.30//22.20//23.09//23.98//24.86//25.75//26.63//27.52//28.39//29.27//30.15//31.02//31.90//32.77//33.64//34.50//35.37//36.23//37.10//37.96//38.82//39.68//40.54//41.39//42.25//43.10//43.95//44.80//45.65//46.50//47.35//48.20//49.04//49.89//50.73//51.57//52.42//53.26//54.10//54.94//55.78//56.62//57.45//58.29//59.13//59.96//60.80//61.64//62.47//63.31//64.14//64.97//65.81//66.64//67.47//68.31//69.14//69.97//70.81//71.64//72.47//73.30//74.14//74.97//75.80//76.64//77.47//78.30//79.14//79.97//80.81//81.64//82.48//83.32//84.15//84.99//85.83//86.67//87.51//88.35//89.19//90.03//90.87//91.72//92.56//93.41//94.25//95.10//95.95//96.80//97.65//98.50//99.356//100.21//101.06//101.92//102.78//103.63//104.50//105.36//106.22//107.09//107.95//108.82//109.69//110.56//111.44//112.31//113.19//114.07//114.95//115.83//116.71//117.60//118.49//119.38//120.27,from=x,to=y)
    ls_2   = translate(121.17//122.06//122.96//123.86//124.76//125.67//126.58//127.49//128.40//129.32//130.23//131.15//132.07//133.00//133.93//134.86//135.79//136.72//137.66//138.60//139.55//140.49//141.44//142.40//143.35//144.31//145.27//146.23//147.20//148.17//149.14//150.12//151.10//152.08//153.07//154.05//155.05//156.04//157.04//158.04//159.05//160.05//161.07//162.08//163.10//164.12//165.15//166.17//167.21//168.24//169.28//170.32//171.37//172.42//173.47//174.53//175.59//176.65//177.72//178.78//179.86//180.94//182.02//183.10//184.19//185.28//186.37//187.47//188.57//189.67//190.78//191.89//193.01//194.12//195.24//196.37//197.50//198.63//199.76//200.90//202.04//203.18//204.32//205.47//206.62//207.78//208.94//210.10//211.26//212.42//213.59//214.76//215.93//217.11//218.29//219.47//220.65//221.83//223.02//224.21//225.40//226.59//227.78//228.98//230.17//231.37//232.57//233.77//234.98//236.18//237.39//238.59//239.80,from=x,to=y)
    ls_3   = translate(241.01//242.21//243.42//244.63//245.84//247.05//248.27//249.48//250.69//251.90//253.11//254.32//255.53//256.74//257.95//259.16//260.37//261.58//262.79//263.99//265.20//266.40//267.61//268.81//270.01//271.21//272.41//273.60//274.80//275.99//277.18//278.37//279.56//280.75//281.93//283.11//284.29//285.47//286.64//287.81//288.98//290.15//291.31//292.47//293.63//294.79//295.94//297.09//298.24//299.38//300.52//301.66//302.80//303.93//305.06//306.19//307.31//308.43//309.54//310.66//311.77//312.87//313.98//315.08//316.17//317.26//318.35//319.44//320.52//321.60//322.68//323.75//324.82//325.88//326.94//328.00//329.06//330.11//331.16//332.20//333.24//334.28//335.31//336.34//337.37//338.39//339.41//340.43//341.44//342.46//343.46//344.47//345.47//346.46//347.46//348.45//349.44//350.42//351.40//352.38//353.35//354.33//355.29//356.26//357.22//358.18//359.14,from=x,to=y)
    ls = cat(ls_1,ls_2,ls_3,axis=y)
    Index = create(1,360,1,start=1,step=1,format=float)
    a1    = cat(ls,Index,axis=x)
    Ls    = valpos(a1[1,,1],value=$1)
    Ls_index = a1[2,Ls[2],1]
    return(int(Ls_index))
   }
}



define CROCUS(Latitude,Longitude){

  if($ARGC == 0){
       printf ("Returns an array containing: \n")
       printf ("The CROCUS Date for the given location \n")
       printf ("FroDa for the given location \n")
       printf ("If never frosted: -32668. \n")
       printf ("If always frosted: -32667. \n")
       printf (" $1 = Lat \n")
       printf (" $2 = Lon \n")
       printf ("From Piqueux et al. 2014 Icarus \n")
  }

  Lat = $1
  Lon = $2

  if(Lon < 0.){
    Lon = Lon + 360.
  }


  Res = 5                                                                                   #Climatologic Map Resolution
  Dis = (90 - abs(Lat))*Res                                                                 #Number of pixels from Center
  X   = int(250.5 + Dis*sind(Lon))                                                          #X coordinates
  Y   = int(250.5 - Dis*cosd(Lon))                                                          #Y coordinates
  if((X < 1)||(X > 500)||(Y < 1)||(Y > 500)){
    X = 1
    Y = 1
  }

  verbose = 0.
  if(Lat >= 0){
    CROCUS = ascii($DV_SCRIPT_FILES+"/crocus/CROCUS_N.ascii",format=float)                         #Climatological CROCUS Dates
    FroDa  = ascii($DV_SCRIPT_FILES+"/crocus/FroDa_N.ascii", format=float)                         #Climatological FroDa Dates
  }
  if(Lat < 0){
    CROCUS = ascii($DV_SCRIPT_FILES+"/crocus/CROCUS_S.ascii",format=float)                         #Climatological CROCUS Dates
    FroDa  = ascii($DV_SCRIPT_FILES+"/crocus/FroDa_S.ascii", format=float)                         #Climatological FroDa Dates
  }

  verbose = 1.

  CROCUS = CROCUS[X,Y,1]
  FroDa  = FroDa[X,Y,1]

  out        = {}
  out.CROCUS = CROCUS
  out.FroDa  = FroDa

  return(out)
}


define exo_porb(name,epoch,VisMag,DisEarth,e,a,rot_per,period,Obliq,Lsperi) {
	if(HasValue(usage)==1) {
		printf("\nGenerate an exoplanet PORB structure for use with the davinci porb function\n")
		printf("This is formatted in the exoplanet style for porb and permits the following values described below\n\n")
		printf("\tname = body name (Default=\"None\") will be truncated to 24 characters\n")
		printf("\tepoch = Time of periastron as full Julian date ; 2000 Jan 1 noon UTC= 2451545.0\n")
		printf("\Vismag = Visual Magnitude of host star (Default = 0.)\n")
		printf("\DisEarth = Distance from Earth to host star, in light years (Default = 0.)\n")
		printf("\ta = Semi-Major Axis, in AU (Default=1)\n")
		printf("\tperiod = siderial orbital period, in days (Default=365.256)\n")
		printf("\trot_per = siderial rotation period, in hours (Default=23.9345)\n")
		printf("\te = Eccentricity (Default=0)\n")
		printf("\tObliq = Obliquity of planet pole, in degree (Default=0)\n")
		printf("\tLsperi = Season (Ls) at periastron in degree (Default=0)\n")
		printf("\ns Piqueux 5/26/21\n\n")
		return(null)
	}

	#fill in all the values w/defaults
	output={}
	if(HasValue(name)==0) {
		output.name="None"
	} else {
		output.name=name[:24]
	}
	if(HasValue(epoch)==0) {
		output.epoch=2451545.00
	} else {
		output.epoch=epoch
	}
	if(HasValue(Vismag)==0) {
		output.Vismag=0.
	} else {
		output.Vismag=Vismag
	}
	if(HasValue(DisEarth)==0) {
		output.DisEarth=0.0
	} else {
		output.DisEarth=DisEarth
	}
	if(HasValue(a)==0) {
		output.a=1.0
	} else {
		output.a=a
	}
	if(HasValue(rot_per)==0) {
		output.rot_per=23.9345
	} else {
		output.rot_per=rot_per
	}
	if(HasValue(period)==0) {
		output.period=365.256
	} else {
		output.period=period
	}
	if(HasValue(e)==0) {
		output.e=0.0
	} else {
		output.e=e
	}
	if(HasValue(Obliq)==0) {
		output.Obliq=0.0
	} else {
		output.Obliq=Obliq
	}
	if(HasValue(Lsperi)==0) {
		output.Lsperi=0.0
	} else {
		output.Lsperi=Lsperi
	}
		return(output)
}



define mssdI(Thermal_inertia,Density, Specific_heat){ 

  if($ARGC == 0){ 
    printf (" Calculates the seasonal skin depth on Mars in m, given the thermal inertia SI \n") 
    printf (" $1: the thermal inertia (I) of the material SI \n") 
    printf (" $2: the density of the soil (SI) SI \n") 
    printf (" $3: the specific heat of the soil (SI) \n") 
  } 

  if($ARGC !=0){ 
 
     P_Day = 88775.24409 * 668.6 
     SD = ($1*sqrt(P_Day/3.14159))/($2*$3) 
	} 

	return(SD) 
} 


define mdsdI(Thermal_inertia,Density, Specific_heat){ 
	if($ARGC == 0){ 
	  printf (" Calculates the diurnal skin depth on Mars in m, given the thermal inertia SI \n") 
    printf (" $1: the thermal inertia (I) of the material SI \n") 
    printf (" $2: the density of the soil (SI) SI \n") 
    printf (" $3: the specific heat of the soil (SI) \n") 
  } 

  if($ARGC !=0){ 
    P_Day = 88775.24409 
    SD = ($1*sqrt(P_Day/3.14159))/($2*$3) 
  } 

  return(SD) 
}

#run the process input on sourcing
oldverbose=verbose
verbose=0
krc_master=krc_process_input($DV_KRC_HOME+"/run/master.inp",usage=0)
global(krc_master)
verbose=oldverbose

