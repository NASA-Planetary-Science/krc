krc_version=1.03
#This file contains all the functions pertaining to the davinci KRC interface
#
#
# krc
# process_bin52
# krc_process_input
# krc_get_key_value
# krc_evalN1
# krc_evalN2
# krc_stability_flag
# porb
# generic_porb
# krc_cond_gas
# krc_eclipse
# krc_planetary_flux_porb
# krc_planetary_flux_table
#
#
#Part of this work was performed at the Jet Propulsion Laboratory, California Institute of Technology
#under a contract with NASA.
#Government support acknowledged.
#Copyright 2018. All Rights reserved.
#This work was supported for part by: PDART grant #15-PDART15_2-0023
#                                     JPL Lew Allen Award grant #01STCR, Task R.18.022.087
#                                     the 2001 Mars Odyssey Thermal Emission Imaging System (THEMIS) project
#
#C.S. Edwards (1) and S. Piqueux (2)
#
#1: Northern Arizona University
#   Dept. of Physics & Astronomy
#   PO BOX 6010
#   Flagstaff, AZ 86011
#   USA
#
#2: Jet Propulsion Laboratory
#   California Institute of Technology
#   4800 Oak Grove Dr.
#   183-601
#   Pasadena, CA 91001
#   USA
#
#Citation: Improving Thermal Model Capability for the Planetary Science Community,
#          S. Piqueux, C. S. Edwards, R. L. Fergason, J. Laura, A. Weintraub, P. R. Christensen, H. H. Kieffer
#          49th Lunar and Planetary Science Conference (2018), Abstract #1027
#

F="F"
T="T"

define krc(KEEP,COND,ffout,ffin,lbound,TUN8,thick,bodyforce,body,bodytype,TPREDICT,T,adv_usage,stability,anc,v,lat,lon,ELEV,type,hour,ls,DELLS,Mat1,Mat2,Por1,Por2,INERTIA2,MAXN1,MAXN2,PFlux,BT_Avg,BT_Max,BT_Min,Dis_AU,Geom_alb,Mut_Period,Orb_Radius,Radius,Lon_Hr,IR,Vis,Eclipse,Eclipser,Ecl_Cent_Hr,Eclipse_Style,Sun_Dis,Eclipser_Rad,CM,Eclipsed_Rad,Per_Mut,Bias,Date,T_user,TI_CO,TI_Guess,TI_Guess_PCT,KRC_MASTER_INP_VARS_AFTER_HERE,ALBEDO,EMISS,INERTIA,COND2,DENS2,PERIOD,SPEC_HEAT,DENSITY,CABR,AMW,SatPrA,PTOTAL,FANON,TATM,TDEEP,SpHeat2,TAUD,DUSTA,TAURAT,TWILI,ARC2_G0,ARC3_Safe,SLOPE,SLOAZI,TFROST,CFROST,AFROST,FEMIS,AF1,AF2,FROEXT,SatPrB,RLAY,FLAY,CONVF,DEPTH,DRSET,PhotoFunc,GGT,DTMAX,DJUL,DELJUL,SOLARDEC,DAU,LsubS,SOLCON,GRAV,Atm_Cp,ConUp0,ConUp1,ConUp2,ConUp3,ConLo0,ConLo1,ConLo2,ConLo3,SphUp0,SphUp1,SphUp2,SphUp3,SphLo0,SphLo1,SphLo2,SphLo3,N1,N2,N3,N4,N5,N24,IIB,IC2,NRSET,NMHA,NRUN,JDISK,IDOWN,FlxP14,TUN_Flx15,KPREF,K4OUT,JBARE,Notif,IDISK2,end,LP1,LP2,LP3,LP4,LP5,LP6,LPGLOB,LVFA,LVFT,LKofT,LPORB,LKEY,LSC,LZONE,LOCAL,Prt76,LPTAVE,Prt78,Prt79,L_ONE){

	#determine the criteria for usage
  if(HasValue(lat)==0) { 
		usage=1
	} else {
		usage=0
	}
	if(HasValue(adv_usage)) {
		usage=0
	} else {
		adv_usage="none"
	}

  if(usage==1) {
    printf("\n")
    printf("This runs the full krc binary mode with the following inputs.\n\n")
	printf("IMPORTANT: This interface supports only KRC > v3.5.6\n")
    printf("\n")
    printf("lat       = latitude **Required**\n")
    printf("lon       = east longitude (Default = 0)\n")
    printf("body      = name of the body (Default = \"Mars\")\n")
	printf("              For planets, \"Name\", for example \"Jupiter\"\n")
	printf("              For satellites, \"Planet,Name\", for example \"Mars,Phobos\" \n")
	printf("              For comets, \"comet,Name\", for example \"comet,Wild_2\" \n")
	printf("              For asteroids, \"minor,Name\", for example \"minor,Ceres\" \n")		
    printf("hour      = hour of day for data to return (Default=-32768, all hours)\n")
    printf("ls        = ls for data to return (Default=-32768, all seasons)\n")
    printf("INERTIA   = thermal inertia of upper layers @ T_user (Default from 2ppd TES)\n")
    printf("T_user    = Temperature at which thermal inertia is defined \n")
    printf("TI_CO     = Thermal Inertia Cut Off, above which bulk conductivity is returned \n")  
    printf("Mat1      = material of upper layers, sets COND, DENSITY, SPEC_HEAT (Default=\"basalt\")\n")
    printf("Por1      = porosity of upper layers, affects DENSITY (Default=0.4)\n")
    printf("INERTIA2  = thermal inertia of lower layers (Default from 2ppd TES)\n")
    printf("Mat2      = material of lower layers, sets COND2, DENS2, SpHeat2 (Default=\"Mat1\")\n")
    printf("Por2      = porosity of lower layers, affects DENS2 (Default=Por1)\n")
    printf("thick     = top material thickness (Default=0, uniform material properties)\n")  
    printf("lbound    = lower boundary condition options (lbound=Option//Value)\n")
	printf("              Set bottom layer temperature (K); lbound=-1.//TDEEP (Default = -1.//180.)\n")
	printf("              Set all layers to a temperature (K); lbound=-2.//TDEEP\n")
	printf("              Set insulating bottom layer; lbound=0\n")
	printf("              Set geothermal heat flux (mW); lbound>0\n")
	printf("PhotoFunc = choose the photometric model (Default = 2)\n")
    printf("             -1<=x<0 for Minnaert->abs(Minnaert)\n")
    printf("              0<x<1 for Lunar Like (Keim=0.25, Vasavada=0.375)\n")
    printf("              2 for Lambert \n")
    printf("              3 for Lommel-Seeliger \n")
	printf("JBARE     = force frost free at specified season (Default JBARE=0, no forcing)\n")
    printf("LVFT      = enable condensable gas parameters (Default=\"F\")\n")
    printf("SLOPE     = surface slope in degrees (Default = 0)\n")
    printf("ALBEDO    = albedo (Default from lat,lon 2ppd TES)\n")
    printf("TAUD      = dust visible opacity (Default TAUD= 0.30)\n")
    printf("ELEV      = elevation km (Default from lat,lon 2ppd MOLA)\n")
    printf("SLOAZI    = slope azimuth in degrees east from north (Default = 0)\n")
    printf("DELLS     = ~delta Ls desired (sets DELJUL automatically, Default = 1)\n") 
    printf("DELJUL    = delta julian date to increment by (Default = 1.9083)\n")
    printf("DJUL      = if LKEY=\"T\", starting Ls (Default = 0.1)\n")
	printf("            or start julian date offset from J2000\n")
	printf("TUN8      = output temperature w/ depth (Default = 101), or atm parameters (102)\n")
	printf("LKEY      = use Ls DJUL input rather than Julian date (Default =\"T\")\n")
    printf("JDISK     = start \"season\" to output (Default = 721)\n")
    printf("N5        = number of \"seasons\" to run (Default = 1080)\n")
    printf("N24       = number of outputs per day (Default = 96)\n")
    printf("LKofT     = use temperature dependent properties (Default = \"T\")\n")
	printf("TPREDICT  = use forward prediction of temperatures for speed (Default =\"T\")\n")
	printf("stability = check for model stability (Default = 0)\n\n")
    printf("KRC-ONE like option:\n")
    printf("T            = sets a one-point like mode where a TI is returned\n")
    printf("               for the specified conditions. This can be an array.\n")
    printf("TI_Guess     = For the one-point like mode, if the solution is guessed \n")
    printf("               a smaller lookup table is created. Can be RISKY but is ~x8 faster\n")
    printf("TI_Guess_PCT = Defines the acceptable tolerance on TI compared to TI_Guess, expressed as a fraction\n")
    printf("               If TI is not within TI_Guess_PCT*TI_Guess, a flagged value (-100) is retuned\n")
    printf("\n")
	printf("NOTE: Many advanced features exist and are documented. Use the adv_usage argument for help\n")
	printf("adv_usage = Provide advanced usage options (\"eclipse\",\"output\",\"model_notes\",\"params\",\"generic_porb\",\"porb\")\n")
#Not currently usable--available for testing but not ready for production use
#		printf("ffout     = path to write a far-field file\n")
#		printf("ffin      = path to a far-field file saved from a previous run\n\n")
    printf("\nC.Edwards + S.Piqueux \n")
		return(null)
	}

	if(adv_usage!="none") {
		if(adv_usage!="eclipse" && adv_usage!="output" && adv_usage!="model_notes" && adv_usage!="params" && adv_usage!="generic_porb" && adv_usage!="porb") {
			printf("Invalid advanced usage parameter\n\n")
			return(null)
		}
	}
	#generic porb help
	if(adv_usage=="generic_porb"){
		printf("Use the generic_porb funciton to define custom orbital parameters\n")
		printf("Forces a PORB run on every krc function call\n\n")
		generic_porb(usage=1)
		return(null)
	}

	#porb help
	if(adv_usage=="porb"){
		printf("\nThe krc interface uses the porb function to calculate an orbital transformation matrix\n\n")
		printf("Pre-computed PORB defaults for a select set of bodies are preferentially used for speed\n")
		printf("bodyforce=1 will force a PORB run on every interface run\n\n")
		porb()
		return(null)
	}

	#ourput format help
  if(adv_usage=="output"){ 
		printf("\n")
		printf("The Full KRC mode for this interface outputs a combination of Bin52 files\n")
		printf("and support files that are used to create the structure detailed below:\n\n")
		process_bin52(usage=1)
		printf("\n")
		printf("The One-Point Mode outputs a TI (SI) for an array of input temperatures with the given parameters\n")
		printf("It can output various values that indicate why a TI was not derived for failure cases:\n")
		printf("\t-600: The Temperature provided is lower than the lowest model output. Possible Frost Presence\n")
		printf("\t-500: No value was derived or returned. KRC may have failed to run all together\n")
		printf("\t-400: Negative TI value. This is a non-physical return as a function of the fitting routine\n")
		printf("\t-300: TI value larger than 2200 SI. 2200 SI is the top of the available lookup table and extrapolation is not permitted\n")
		printf("\t-200: Returned TI value doesn't meet proximity criterion (TI_Guess_PCT)\n")
		printf("\t-100: Bad TI_Guess / TI_Guess_PCT combination.  This is most likely a user error\n")
    return(null)
  }
	
	#eclipse help
	if(adv_usage=="eclipse") {
		printf("\nKRC supports Eclipses but requires the following parameters\n")
    printf("PFlux = forces a planetary flux on a orbiting body (Default = \"F\") \n")
		printf("    Needs the following Parameters (Default Provided for common bodies)\n")
		printf("            BT_Avg     : Average Brightness Temperature [K] \n")
		printf("            BT_Min     : Min Brightness Temperature, if diurnal cycle [K] \n")
		printf("            BT_Max     : Max Brightness Temperature [K] \n")
		printf("            Dis_AU     : Distance form Sun in AU \n")
		printf("            Geom_alb   : Geometric Albedo [1]\n")
		printf("            Mut_Period : Mutual Period [?]\n")
		printf("            Orb_Radius : Orbiting Radius [km] \n")
		printf("            Radius     : Radius of the Orbiting body [km] \n")
		printf("            Lon_Hr     : Longitude Hour of the surface point \n")
    printf("    OR: \n")
		printf("            IR         : A 2 x n x 1 array with IR flux (1st col.) vs. LTST (2nd col.) \n")
		printf("            Vis        : A 2 x n x 1 array with Vis flux (1st col.) vs. LTST (2nd col.) \n")
    printf("Eclipse = forces an eclipse (Default = \"F\") \n")
		printf("            Eclipser      : Eclipser name, for Example \"Mars\" or \"Mars,Phobos\" \n")
		printf("            Eclipsed      : Should be the same as \"body\", for Example \"Mars\" or \"Mars,Phobos\" \n")
    printf("            Eclipse_Style : Eclipse Style (1=Rare,2=Daily), default is daily \n")
    printf("            Sun_Dis       : Distance from the Sun in AU \n")
    printf("            Eclipser_Rad  : Eclipser radius [km] \n")
    printf("            CM            : Mutual center-of-mass orbit radius [km] if not from porb \n")
    printf("            Eclipsed_Rad  : Eclipsed radius [km] \n") 
    printf("            Per_Mut       : Mutual orbit period [Days] Assumed same as diurnal PERIOD \n")
    printf("            Bias          : Eclipse Bias \n")
    printf("            Date          : Rare Eclipse: J2000 date, assumed to be on the last \season \n")
    printf("            Ecl_Cent_Hr   : Eclipse central hour [???] \n\n")
		return(null)
	}

  #Advanced model parameters
  if(adv_usage=="model_notes") {
		printf("\nAdditional options that are provided as defaults.  Briefly explains the model time steps\n\n")
    printf("K4OUT = 52.  This interface only supports bin52 output which encapsulates most of the other file formats\n")
    printf("NOTE: Recommended parameter changes are listed in the first section.\n")
    printf("Please use these parameters with caution. They are meant for advanced users.\n\n")
    printf("N1 (the number of layers, Default=29) is calculated in the function krc_evalN1\n")
    printf("\tThis function relies on various parameters including FLAY, RLAY, length of the year \n")
    printf("\tto calculate the minimum number of layers required to reach seasonal skin depth stability\n")
    printf("N2 (the number of calculations per day, Default=288) is calculated in the function krc_evalN2\n")
    printf("\tThis function relies various parameters including FLAY, N24, PERIOD\n")
    printf("\n")
    printf("The default model iterates for 2 years before\n")
    printf("outputting a full year (N5-JDISK) of data at 1/360th year intervals (DELJUL),\n")
    printf("starting at DJUL=0 (in Ls), JDISK=721, DELJUL=1.9083\n")
    printf("from 24.0/N24 to 24 by 24.0/N24 (15 minutes with N24=96).\n\n")
    printf("First layer is set at FLAY=0.18 skin depths.\n")
    printf("Each successive layer is increased by a factor of RLAY=1.2.\n\n")
    printf("ALBEDO and TAUD can be dynamic if input as \n")
    printf("2 x n x 1 arrays. Ls = column 1 and ALBEDO/TAUD = column 2\n\n")
    return(null)
  }

	#display all the parameters
  if(adv_usage=="params") {
    printf("\nThese values are from the standard KRC input file. Defaults defined in the general help\n")
    printf("or those calculated in the interface are used in place of the master.inp file values.\n\n")
    printf("See the helplist distributed with KRC for variable meanings and default values.\n\n")

	}

  #handle the verbosity settings
  if(HasValue(v)==0) {
    v=0
  } else {
    v=1
  }

  #setup ancillary data and Resampling defaults
  if(HasValue(anc)==0)        anc=0
  if(HasValue(ls)==0)         ls=-32768
  if(HasValue(hour)==0)       hour=-32768
  if(HasValue(stability)==0)  stability=0  
  if(HasValue(body)==0)       body="Mars"
  if(HasValue(LKofT)==0)      LKofT="T"


	#automatically determine the body type from the user input
  if(type(body)=="STRUCT") {
    bodytype="generic"
  } else {
    if(type(strsplit(body,delim=",",v=0))=="UNDEFINED") {
      bodytype="planet"
    } else {
      bodytype=strsplit(body,delim=",")[,1]
      if(bodytype!="comet" && bodytype!="minor") {
        bodytype="satellite"
			} else {
				body=strsplit(body,delim=",")[,2]
      }
    }
  }

  if(HasValue(bodyforce)==0)                bodyforce=0
  if(HasValue(PhotoFunc)==0)                PhotoFunc=0  #Default photometric function is Lambertian
  if(HasValue(LVFT)==0)                     LVFT="F"
  if(HasValue(ffout)==0)                    ffout=""
  if(HasValue(ffin)==0)                     ffin=""
	if(bodytype!="generic") {
	  if((body=="Mars")&&(HasValue(PTOTAL)==0)) PTOTAL=545.
	}
  if(HasValue(lon) == 0)                    lon=0  

	#check for double precision KRC or not
	if(fexists($DV_KRC_HOME+"/src/krcd")) {
		krcprog="krcd"
	} else {
		krcprog="krc"
	}

	#process the input file
	if(adv_usage=="params") {
  	master=krc_process_input($DV_KRC_HOME+"/run/master.inp",usage=1)
		return(null)	
	} else {
  	master=krc_process_input($DV_KRC_HOME+"/run/master.inp",usage=0)
	}


##########################################################################################
#finished with the input section
##########################################################################################
	if(HasValue(KEEP)==0) KEEP="F"
	if((HasValue(Eclipse)==1)&&((lat - int(lat)) < 0.00501)){
		lat = int(lat) + 0.00501
	}
	if((HasValue(Eclipse)==1)&&((lat - int(lat)) > (1. - 0.00501))){
		lat = 1 + int(lat) - 0.00501
	}

	#get the good porb stuff
	verbose=0

	#if we have a satellite, we need to return the planetary flux values and the satellite values
	if(bodytype=="satellite") {
		porb=porb(strsplit(body + ", ")[,1,1],strsplit(body + ", ")[,2,1],type="planet",force=bodyforce)
		porb_Planet=porb(strsplit(body + ", ")[,1,1],strsplit(body + ", ")[,1,1],type="planet",force=bodyforce)

		if(HasValue(Lon_Hr)==0)     Lon_Hr=12.
		if(HasValue(BT_Avg)!=0)     porb_Planet.planet_flux.BT_Avg=BT_Avg
		if(HasValue(BT_Max)!=0)     porb_Planet.planet_flux.BT_Max=BT_Avg
		if(HasValue(BT_Min)!=0)     porb_Planet.planet_flux.BT_Min=BT_Avg
		if(HasValue(Geom_alb)!=0)   porb_Planet.planet_flux.Geom_alb=Geom_alb
		if(HasValue(Radius)!=0)     porb_Planet.planet_flux.Radius=Radius
		if(HasValue(Dis_AU)!=0)     porb_Planet.planet_flux.Dis_AU=Dis_AU
		if(HasValue(Dis_AU)!=0)     porb.planet_flux.Dis_AU=Dis_AU
		if(HasValue(Mut_Period)!=0) porb.planet_flux.Mut_Period=Mut_Period
		if(HasValue(Orb_Radius)!=0) porb.planet_flux.Orb_Radius=Orb_Radius
		if(HasValue(PFlux)==0)      PFlux="F"

		#run the planetary_flux_table if an array is provided
		if((PFlux == "T")&&(HasValue(IR) == 1)){
 			printf("Customized Planetary Flux")
			Planetary_Flux=krc_planetary_flux_table(IR,Vis,Lon_Hr)
		}
 
		#run the planetary_flux_table if an array is not provided
		if((PFlux == "T")&&(HasValue(IR) != 1)){
			printf("Default Planetary Flux")
			Planetary_Flux=krc_planetary_flux_porb(porb,porb_Planet,Lon_Hr)
		}

	#if we're dealing with a minor, comet, planet, or generic porb case then run porb like normal
	} else if (bodytype=="planet" || bodytype=="comet" || bodytype=="minor" || bodytype=="generic") {
		porb=porb(body,type=bodytype,force=bodyforce)

	#if its none of these things then we have a typo or something
	} else { 
		printf("%s bodytype not supported\n",bodytype)
		printf("KRC is aborting\n\n")
		verbose=3
		return(null)
	}
	
	if(type(porb)=="STRUCT") {  
    if(HasValue(ARC2_G0)==0)  ARC2_G0=porb.krc.ARC2_G0

		#Handle the PORB DELJUL/DELLS Case
    if(HasValue(DELJUL)==0 && HasValue(DELLS)==0) {
		  DELJUL=porb.krc.DELJUL
		} else if(HasValue(DELJUL==0) && HasValue(DELLS)) {
			DELJUL=porb.krc.PERIOD/360.*DELLS
		} else if(HasValue(DELJUL) && HasValue(DELLS)==0) {
			DELJUL=DELJUL
		} else {
			printf("\n")
		}

    if(HasValue(DUSTA)==0)    DUSTA=porb.krc.DUSTA
    if(HasValue(GRAV)==0)     GRAV=porb.krc.GRAV
    if(HasValue(N24)==0)      N24=porb.krc.N24
    if(HasValue(PERIOD)==0)   PERIOD=porb.krc.PERIOD
    if(HasValue(PTOTAL)==0)   PTOTAL=porb.krc.PTOTAL
    if(HasValue(TAURAT)==0)   TAURAT=porb.krc.TAURAT

  #If running porb has failed, abort
	} else {                   
		printf("\nPORB Error encountered...\n")
		printf("KRC is aborting\n\n")
		verbose=3
		return(null)
	}
	verbose=3

##########################################################################################
	
	#this is a bit kludgy right now
	#will update "other parameters" file and porb function in the future
	if(LVFT=="T") { 
		if(bodytype!="generic") {
			gas_properties=krc_cond_gas(body)	
			gas_properties_keys=get_struct_key(gas_properties)
			for(i=1;i<=length(gas_properties_keys);i+=1) {
				add_struct(porb.krc,get_struct(gas_properties,gas_properties_keys[,i]),name=gas_properties_keys[,i])
			}
		}
	} else {
		if(bodytype!="generic") {
			if(body=="Mars") {
				porb.krc.KPREF=1
			}
		}
	}

	#porb default values
	porbkeys=get_struct_key(porb.krc)
	for(i=1;i<=length(porb.krc);i+=1) {			
		if(eval("HasValue("+porbkeys[,i]+")")==0) {
			if(HasValue(DELLS) && porbkeys[,i]=="DELJUL") {
				if(v==1) printf("Skipping %s from PORB because DELLS is set\n",porbkeys[,i])
			} else {
				if(v==1) printf("Setting %s from PORB\n",porbkeys[,i])
				eval(sprintf("%s=porb.krc.%s",porbkeys[,i],porbkeys[,i]))
			}
		}
	}
	
	#replace the master.input file orbital elements matrix
	#with the appropriate one from porb
	master.inp.part6=porb.rot

	#print a warning for the usage of depth
	if(HasValue(DEPTH)) {
		printf("\nWARNING: DEPTH is a special davinci variable that controls\n")
		printf("how many structure elements are shown\n")
		printf("Make sure you reset to DEPTH=2 if unexpect results occur\n\n")
	}	

	if(HasValue(IC2)) {
		if(IC2!=999 && IC2<3) {
			printf("IC2 must be either 999 or >=3\n")
			printf("The first layer is atmosphere and you can't change the material properties at the first surface layer\n")
			printf("Please reset IC2 and try again\n\n")
			return(null)
		}
	}

  #split the output of krc_process_input()
  inp=master.inp
  key=master.key

  #Get elevation, albedo and ti from maps if the user didn't specify
  #Construct latitude and elevation line, as they are handled differently than everything else
  if (HasValue(lat) == 0) lat = 0
  if (HasValue(lon) == 0) lon = 0
	if(lat>90 || lat<-90) {
		printf("\nERROR\n")
		printf("Please enter a valid latitude range (-90:90 degrees)\n\n")
		return(null)
	}
	if(lon>360 || lon<0) {
		printf("\nERROR\n")
		printf("Please enter a valid longitude range (0:360 degrees)\n\n")
		return(null)
	}
  xy=geo_trans(lat,360-lon,2)

	#make TUN8 the name for the TUN_Flx15 which enables the 101 (all temps with depth output)
	if(HasValue(TUN8)==0) {
#		TUN_Flx15=TUN8=101
 		TUN_Flx15=TUN8=0                                                                  #By Default, temperature with depth is not provided
	}

    if(type(TUN8)=="STRING"){
      if(TUN8=="F"){
        TUN8=0
      } else {  
        TUN8=101
      }  
    }
	TUN_Flx15=TUN8

  #Get elevation, albedo and ti from maps if the user didn't specify
  #Construct latitude and elevation line, as they are handled differently than everything else
  if (HasValue(lat) == 0) lat = 0
  if (HasValue(lon) == 0) lon = 0
  xy=geo_trans(lat,360-lon,2)

	#Sets Default propeties if they dont exist (note used to be a separate function materials_krc)
	#suggest moving back to a separate function at somepoint in the future
	##########################################################################################
	#KRC can accepts an upper and lower material
	#set the default materials
	#upper is basalt with inertia from TES and a porosity of 0.4 by default
	#lower is basalt with inertia from TES and a porosoty of 0.4 by default 
	
	#One Layer By Default
	if(HasValue(thick)==0) thick=0                                                        
	if(bodytype!="generic") {
		if(body=="Jupiter,Europa"){
		  if(HasValue(INERTIA)==0)   INERTIA=100.
		  if((HasValue(COND)==1)&&(HasValue(DENSITY)==1)&&(HasValue(SPEC_HEAT)==1)) INERTIA=sqrt(COND*DENSITY*SPEC_HEAT)
		  if((HasValue(COND)==1)&&((HasValue(DENSITY)==0)||(HasValue(SPEC_HEAT)==0))) INERTIA=sqrt(COND*1.E6)               #CASE ADDED TO AVOID BAD INERTIA(from Map)/COND(from USer) Combo
		  if(HasValue(Mat1)==0)      Mat1="H2O"                                             #Forces Europa to be made of H2O ice
		  if(HasValue(Mat2)==0)      Mat2="H2O"                                             #Forces Europa to be made of H2O ice  
		  if(HasValue(T_user)==0)    T_user=100.                                            #Temperature where properties are defined
		  if(HasValue(TI_CO)==0)     TI_CO=1200.                                            #fines vs bulk cut off (thermal inertia)
		  if(HasValue(PTOTAL)==0)    PTOTAL=0.
		  if(HasValue(INERTIA2)==0)  INERTIA2=INERTIA
		  if(HasValue(Por1)==0)      Por1=0.4
		  if(HasValue(Por2)==0)      Por2=0.4
		  if(HasValue(ALBEDO)==0)    ALBEDO=0.67
		  if(HasValue(ELEV)==0)      ELEV=0.
		  if(HasValue(TFROST)==0.)   TFROST=0.
		  if(PTOTAL<1.)              TAUD=0.                                              #Forces the opacity to be 0. if no atmophere (a string like "N/Abreaks the interface)
		}
	}
	if(bodytype!="generic") {
		if(body=="Mars"){
		  if(HasValue(INERTIA)==0)   INERTIA=read($DV_SCRIPT_FILES+"/krc_support/ti_map2ppd_v4.vicar")[xy[1],xy[2]]
		  if((HasValue(COND)==1)&&(HasValue(DENSITY)==1)&&(HasValue(SPEC_HEAT)==1)) INERTIA=sqrt(COND*DENSITY*SPEC_HEAT)
		  if((HasValue(COND)==1)&&((HasValue(DENSITY)==0)||(HasValue(SPEC_HEAT)==0))) INERTIA=sqrt(COND*1.E6)               #CASE ADDED TO AVOID BAD INERTIA(from Map)/COND(from USer) Combo
		  if(HasValue(Mat1)==0)      Mat1="basalt"
		  if(HasValue(Mat2)==0)      Mat2="basalt"
		  if(HasValue(T_user)==0)    T_user=220.                                          #Temperature where properties are defined
		  if(HasValue(TI_CO)==0)     TI_CO=1200.                                          #fines vs bulk cut off (thermal inertia)
		  if(HasValue(PTOTAL)==0)    PTOTAL=545.
		  if(HasValue(INERTIA2)==0)  INERTIA2=INERTIA
		  if(HasValue(Por1)==0)      Por1=0.4
		  if(HasValue(Por2)==0)      Por2=0.4
		  if(HasValue(ALBEDO)==0)    ALBEDO=read($DV_SCRIPT_FILES+"/krc_support/albedo_2ppd.vicar")[xy[1],xy[2]]
		  if(HasValue(ELEV)==0)      ELEV=read($DV_SCRIPT_FILES+"/krc_support/mola_2ppd.vicar")[xy[1],xy[2]]/1000.
		  if(PTOTAL<1.)              TAUD=0.                                              #Forces the opacity to be 0. if Mars without atmophere (a string like "N/A" breaks the interface) 
		}
	}
	if(bodytype!="planet") {
	  if(HasValue(INERTIA)==0)   INERTIA=100.
	  if((HasValue(COND)==1)&&(HasValue(DENSITY)==1)&&(HasValue(SPEC_HEAT)==1)) INERTIA=sqrt(COND*DENSITY*SPEC_HEAT)
	  if((HasValue(COND)==1)&&((HasValue(DENSITY)==0)||(HasValue(SPEC_HEAT)==0))) INERTIA=sqrt(COND*1.E6)               #CASE ADDED TO AVOID BAD INERTIA(from Map)/COND(from USer) Combo
	  if(HasValue(Mat1)==0)      Mat1="basalt"
	  if(HasValue(Mat2)==0)      Mat2="basalt"
	  if(HasValue(T_user)==0)    T_user=220.                                            #Temperature where properties are defined
	  if(HasValue(TI_CO)==0)     TI_CO=1200.                                            #fines vs bulk cut off (thermal inertia)
	  if(HasValue(PTOTAL)==0)    PTOTAL=0.
	  if(HasValue(INERTIA2)==0)  INERTIA2=INERTIA
	  if(HasValue(Por1)==0)      Por1=0.4
	  if(HasValue(Por2)==0)      Por2=0.4
	  if(HasValue(ALBEDO)==0)    ALBEDO=0.67
	  if(HasValue(ELEV)==0)      ELEV=0.
	  if(HasValue(TFROST)==0.)   TFROST=0.
	  if(PTOTAL<1.)              TAUD=0.                                                  #Forces the opacity to be 0. if no atmophere (a string like "N/A" breaks the interface)
	}
	
	#set the upper layer material properties
	if(Mat1 == "basalt"){   
	  Density_bulk = 3100.
	  if(HasValue(SphUp0)==0)    SphUp0=609.906
	  if(HasValue(SphUp1)==0)    SphUp1=214.231
	  if(HasValue(SphUp2)==0)    SphUp2=-40.9437
	  if(HasValue(SphUp3)==0)    SphUp3=11.2575
	  if(HasValue(SPEC_HEAT)==0) SPEC_HEAT=SphUp0                                         #Cp(220K)

		if(INERTIA > TI_CO){                                                              #Case of bulky basalt
			if(HasValue(DENSITY)==0)   DENSITY=Density_bulk
			Por1                       = 1.-(DENSITY/Density_bulk)
			if(Por1<0)                 Por1=0
			if(HasValue(COND)==0)      COND=INERTIA^2/(SPEC_HEAT*(1-Por1)*Density_bulk)
			if(HasValue(ConUp0)==0)    ConUp0=COND
			if(HasValue(ConUp1)==0)    ConUp1=-1.51737
			if(HasValue(ConUp2)==0)    ConUp2=0.587176
			if(HasValue(ConUp3)==0)    ConUp3=-0.126695
			if(LKofT == "F"){
				ConUp0                     = COND
				ConUp1                     = ConUp2 = ConUp3 = 0.
          		}

		}    
	}
	if(Mat1 == "H2O"){   
	  Density_bulk = 924.148
	  if(HasValue(SphUp0)==0)    SphUp0=1704.57
	  if(HasValue(SphUp1)==0)    SphUp1=713.339
	  if(HasValue(SphUp2)==0)    SphUp2=110.694
	  if(HasValue(SphUp3)==0)    SphUp3=75.7506
	  if(HasValue(SPEC_HEAT)==0) SPEC_HEAT=SphUp0                                         #Cp(220K)
		if(INERTIA > TI_CO){                                                              #Case of bulky basalt
			if(HasValue(DENSITY)==0)   DENSITY=Density_bulk
			Por1                       = 1.-(DENSITY/Density_bulk)
			if(Por1<0)                 Por1=0
			if(HasValue(COND)==0)      COND=INERTIA^2/(SPEC_HEAT*(1.-Por1)*Density_bulk)
			if(HasValue(ConUp0)==0)    ConUp0=COND
			if(HasValue(ConUp1)==0)    ConUp1=-1.08693  
			if(HasValue(ConUp2)==0)    ConUp2=-0.334381
			if(HasValue(ConUp3)==0)    ConUp3=-1.60453
		 	if(LKofT == "F"){
		  		ConUp0                    = COND
		  		ConUp1                    = ConUp2 = ConUp3 = 0.
			}

		}    
	}

	if((INERTIA <= TI_CO)&&(PTOTAL==0.)){                                                 #T^3 trend for k
		if(HasValue(DENSITY)==0)   DENSITY=(1.-Por1)*Density_bulk
		Por1                       = 1.-(DENSITY/Density_bulk)
		if(Por1<0)                 Por1=0
		if(HasValue(COND)==0)      COND=INERTIA^2/(SPEC_HEAT*(1.-Por1)*Density_bulk)
		T_Table                    = create(1,50,1,start=10.,step=10.,format=float)
		T_Table_KRC                = (T_Table - 220.)*0.01
		k_Table                    = COND*(1+2.7*((T_Table-T_user)/350.)^3)
		FIT                        = fit(y=k_Table,x=T_Table_KRC,"cube",plot=0)
		if(HasValue(ConUp0)==0)    ConUp0=FIT[1]
		if(HasValue(ConUp1)==0)    ConUp1=FIT[2]  
		if(HasValue(ConUp2)==0)    ConUp2=FIT[3]  
		if(HasValue(ConUp3)==0)    ConUp3=FIT[4]
		if(LKofT == "F"){
			ConUp0                     = COND
			ConUp1                     = ConUp2 = ConUp3 = 0.
     		}

	}
	
	if((INERTIA <= TI_CO)&&(PTOTAL!=0.)){
		if(HasValue(DENSITY)==0)   DENSITY=(1.-Por1)*Density_bulk
		Por1                       = 1.-(DENSITY/Density_bulk)
		if(Por1<0)                 Por1=0
		if(HasValue(COND)==0)      COND=INERTIA^2/(SPEC_HEAT*(1-Por1)*Density_bulk)
		T_Table                    = create(1,40,1,start=100.,step=10.,format=float)
		T_Table_KRC                = (T_Table - 220.)*0.01
		k_Table                    = COND*sqrt(T_Table/220.)
		FIT                        = fit(y=k_Table,x=T_Table_KRC,"cube",plot=0)
		if(HasValue(ConUp0)==0)    ConUp0=FIT[1]
		if(HasValue(ConUp1)==0)    ConUp1=FIT[2]  
		if(HasValue(ConUp2)==0)    ConUp2=FIT[3]  
		if(HasValue(ConUp3)==0)    ConUp3=FIT[4]
		if(LKofT == "F"){
			ConUp0                   = COND
			ConUp1                   = ConUp2 = ConUp3 = 0.
     		}

	}

	upper               = {}
	upper.req           = {}
	upper.req.INERTIA   = INERTIA
	upper.req.SphUp0    = SphUp0
	upper.req.SphUp1    = SphUp1  
	upper.req.SphUp2    = SphUp2
	upper.req.SphUp3    = SphUp3
	upper.req.SPEC_HEAT = SPEC_HEAT  
	upper.req.DENSITY   = DENSITY 
	upper.req.ConUp0    = ConUp0 = COND
	upper.req.ConUp1    = ConUp1 
	upper.req.ConUp2    = ConUp2
	upper.req.ConUp3    = ConUp3
	upper.COND          = COND
	upper.composition   = Mat1
	upper.porosity      = Por1
	

	#now populate the KRC input file for the specifc things we just set
	upper_keys=get_struct_key(upper.req) 
	for(i=1;i<=length(upper_keys);i+=1) {
		if(eval(sprintf("HasValue(%s)==0",upper_keys[,i]))) eval(sprintf("%s=%f",upper_keys[,i],upper.req[i]))
	}

	#set the lower layer material properties
	if(Mat2 == "basalt"){   
		Density_bulk = 3100.
		if(HasValue(SpHeat2)==0)   SpHeat2=609.906                                          #Cp(220K)
		if(HasValue(SphLo0)==0)    SphLo0=609.906
		if(HasValue(SphLo1)==0)    SphLo1=214.231
		if(HasValue(SphLo2)==0)    SphLo2=-40.9437
		if(HasValue(SphLo3)==0)    SphLo3=11.2575
		if(INERTIA2 > TI_CO){                                                                     #Case of bulky basalt
			if(HasValue(DENS2)==0)     DENS2=Density_bulk
			Por2                       = 1.-(DENS2/Density_bulk)
			if(Por2<0)                 Por2=0
			if(HasValue(COND2)==0)     COND2=INERTIA2^2/(SpHeat2*(1.-Por2)*Density_bulk)
			if(HasValue(ConLo0)==0)    ConLo0=COND2
			if(HasValue(ConLo1)==0)    ConLo1=-1.51737  
			if(HasValue(ConLo2)==0)    ConLo2=0.587176
			if(HasValue(ConLo3)==0)    ConLo3=-0.126695
	  	}    
	}
	if(Mat2 == "H2O"){   
	  Density_bulk = 924.148
	  if(HasValue(SpHeat2)==0)   SpHeat2=1704.57                                          #Cp(220K)
	  if(HasValue(SphLo0)==0)    SphLo0=1704.57                                           #Cp(220K)
	  if(HasValue(SphLo1)==0)    SphLo1=713.339
	  if(HasValue(SphLo2)==0)    SphLo2=110.694
	  if(HasValue(SphLo3)==0)    SphLo3=75.7506
		if(INERTIA2 > TI_CO){                                                                     #Case of bulky basalt
		  if(HasValue(DENS2)==0)     DENS2=Density_bulk
		  Por2                       = 1.-(DENS2/Density_bulk)
		  if(Por2<0)                 Por2=0
		  if(HasValue(COND2)==0)     COND2=INERTIA2^2/(SpHeat2*(1.-Por2)*Density_bulk)
		  if(HasValue(ConLo0)==0)    ConLo0=COND2
		  if(HasValue(ConLo1)==0)    ConLo1=-1.08693  
		  if(HasValue(ConLo2)==0)    ConLo2=-0.334381 
		  if(HasValue(ConLo3)==0)    ConLo3=-1.60453
	  }    
	}

	if((INERTIA2 <= TI_CO)&&(PTOTAL==0.)){
	  if(HasValue(DENS2)==0)     DENS2=(1.-0.4)*Density_bulk
	  Por2                       = 1.-(DENS2/Density_bulk)
	  if(Por2<0)                 Por2=0
	  if(HasValue(COND2)==0)     COND2=INERTIA2^2/(SpHeat2*(1-Por2)*Density_bulk)
	  k_guess                    = INERTIA2^2/(SpHeat2*Density_bulk*(1.-Por2))
	  T_Table                    = create(1,50,1,start=10.,step=10.,format=float)
	  T_Table_KRC                = (T_Table - 220.)*0.01
	  k_Table                    = COND2*(1+2.7*((T_Table-T_user)/350.)^3)
	  FIT                        = fit(y=k_Table,x=T_Table_KRC,"cube",plot=0)
	  if(HasValue(ConLo0)==0)    ConLo0=FIT[1]
	  if(HasValue(ConLo1)==0)    ConLo1=FIT[2]  
	  if(HasValue(ConLo2)==0)    ConLo2=FIT[3]  
	  if(HasValue(ConLo3)==0)    ConLo3=FIT[4]
	}
	
	if((INERTIA2 <= TI_CO)&&(PTOTAL!=0.)){
	  if(HasValue(DENS2)==0)     DENS2=(1.-0.4)*Density_bulk
	  Por2                       = 1.-(DENS2/Density_bulk)
	  if(Por2<0)                 Por2=0
	  if(HasValue(COND2)==0)     COND2=INERTIA2^2/(SpHeat2*(1-Por2)*Density_bulk)
	  T_Table                    = create(1,40,1,start=100.,step=10.,format=float)
	  T_Table_KRC                = (T_Table - 220.)*0.01
	  k_Table                    = COND2*sqrt(T_Table/220.)
	  FIT                        = fit(y=k_Table,x=T_Table_KRC,"cube",plot=0)
	  if(HasValue(ConLo0)==0)    ConLo0=FIT[1]
	  if(HasValue(ConLo1)==0)    ConLo1=FIT[2]  
	  if(HasValue(ConLo2)==0)    ConLo2=FIT[3]  
	  if(HasValue(ConLo3)==0)    ConLo3=FIT[4]
	}

	lower               = {}
	lower.req           = {}
	lower.req.INERTIA2  = INERTIA2
	lower.req.SphLo0    = SphLo0
	lower.req.SphLo1    = SphLo1  
	lower.req.SphLo2    = SphLo2
	lower.req.SphLo3    = SphLo3
	lower.req.SpHeat2   = SpHeat2  
	lower.req.DENS2     = DENS2
	lower.req.ConLo0    = ConLo0 = COND2
	lower.req.ConLo1    = ConLo1 
	lower.req.ConLo2    = ConLo2
	lower.req.ConLo3    = ConLo3
	lower.req.COND2     = COND2
	lower.composition2  = Mat2
	lower.porosity2     = Por2
	
	#populate the lower keys just set
  lower_keys=get_struct_key(lower.req) 
  for(i=1;i<=length(lower_keys);i+=1) {
    if(eval(sprintf("HasValue(%s)==0",lower_keys[,i]))) eval(sprintf("%s=%f",lower_keys[,i],lower.req[i]))
  }
  
  #Latitude section of the input file
  inp.part4[,2]=sprintf("%7.2f",lat)

  #Elevation section of the input file
  inp.part5[,2]=sprintf("%7.2f",ELEV)

  # Copy files over to temp directories and setup the initial input file
  # use randdir as the zone file name, sequential test
	randdir="krc_"+int(random(1,type=rand))
  if($DV_OS=="mac") {
		base=basename($TMPDIR)
		workdir="/tmp/"+base+"/"+randdir
		syscall("mkdir -p "+workdir)
	} else if ($DV_OS=="linux") {
		workdir=$TMPDIR
	} else {
		printf("Your operating system is not supported for use with krc\n\n")
		return(null)
	}

  #Start construction of parameter change lines for default input files 
  #We now use the input file generator rather than set values
  params=text(0)

  #set the output file type
	#force it to be bin52 as it should capture most other file types
  K4OUT=52

  #Use either DELLS or DELJUL error checking
  if(HasValue(DELLS) && HasValue(DELJUL)) {
    printf("\nPlease do not set both DELLS and DELJUL\n")
    printf("Please unset one variable and try again\n\n")
    return(null)
  }


##########################################################################################
###ONE POINT SIMULATED MODE
##########################################################################################


  #Setup the special case of the onepoint model error checking
  if(HasValue(T)) {
    if(ls==-32768 || hour==-32768) {
      printf("\n'ls' and 'hour' must be set for the T (krc_one) option\n")
      printf("Please set these variables and try again\n\n")
      return(null)
    }
		#disabling temperature with depth for one point mode - unnecessary output
		TUN8=0
		TUN_Flx15=0

		#standard onepoint LS and time of day spacing
    if(HasValue(DELLS)==0) DELLS=8
    if(HasValue(N24)==0) N24=48
  }

  #set up the default operating parameters
  if(HasValue(N4)==0)     N4=1
  if(HasValue(N5)==0)     N5=1080
  if(HasValue(JDISK)==0)  JDISK=721
  if(HasValue(DJUL)==0)   DJUL=0.1
  if(HasValue(LKEY)==0)   LKEY="T"
  if(HasValue(SLOPE)==0)  SLOPE=0
  if(HasValue(SLOAZI)==0) SLOAZI=0
  if(HasValue(JBARE)==0)  JBARE=0
  if(JBARE != 0)          JBARE=JBARE+JDISK                                               #Trick to allow user to define JBARE as a Ls (whereas KRC defines it as a function of JDISK)
  if(HasValue(TAUD)==0)   TAUD=0.30

  #set up default values that are required for smart functions
  #we get them from the standard master.inp but they are changeable at runtime
  if(HasValue(FLAY)==0) FLAY=atof(key.part1.value[,maxpos(key.part1.key=="FLAY")[2]])
  if(HasValue(RLAY)==0) RLAY=atof(key.part1.value[,maxpos(key.part1.key=="RLAY")[2]])
  if(HasValue(TFROST)==0) TFROST=atof(key.part1.value[,maxpos(key.part1.key=="TFROST")[2]])

  #deal with the lower boundary condition
  if(HasValue(lbound)==0) {
		IIB=-1
		TDEEP=180
	} else {
		#Bottom layer set to TDEEP 
		if(lbound[1]==-1){
			IIB=-1
			if(HasValue(TDEEP)==0) TDEEP=lbound[2]
		}
		#All layers set to TDEEP
		if(lbound[1]==-2){
			IIB=-2
			if(HasValue(TDEEP)==0) TDEEP=lbound[2]
		}
		#Insulating bottom layer
		if(lbound[1]==0){
			IIB=0
		}
		#geothermal heatflux 
		if(lbound[1]>0){
			IIB=lbound[1]
		}
	}
	
  #these are values that the user can override, usually defaulted to 
  #the new compile time options
  if(HasValue(MAXN1)==0) MAXN1=1000
  if(HasValue(MAXN2)==0) MAXN2=86400
    
  #handle the DELLS case where we specify the LS delta instead of the DELJUL
  if(HasValue(DELLS)) {

    #set the standard DELLS
    if(HasValue(DELLS)==0) DELLS=1    
    if(DELLS<0.53845) {
      DELLS=0.53845
      printf("\nWARNING: You may not select a DELLS < %.4f as it will compound\n",DELLS)
      printf("time of day and season into the output. Resetting to %.4f\n",DELLS)
    } 

    #this julian date delta 1.9083 is approximately equal to 1 Martian LS  
    #calculate the new approximate DELJUL based on the DELLS increment
    DELJUL=1.9083*DELLS
    
    #calculate N5 & JDISK for 2 year spin up and a full year output
    N5=int(ceil(360./DELLS*3))
    JDISK=int(ceil(360./DELLS*2+1))
  } else {

    #this case makes sure DELLS is always set even if its not specified
    DELLS=DELJUL/1.9083
  } 

  #just a little error handling so we don't break KRC
  if(N5-JDISK>720) {
    printf("ERROR: KRC only supports writing of 720 seasons to a file\n")
    printf("Please correct N5-JDISK to meet this requirement (<=720)\n\n")
    return(null)
  }
  if(N5>2161) {
    printf("ERROR: N5 must be <= 2161 for this version of KRC\n")
    printf("Please correct N5 to meet this requirement\n\n")
    return(null)
  }
	if(DELJUL<PERIOD) {
		DELJUL=PERIOD
		printf("\nWARNING: You may not select a DELJUL < %.4f as it will compound\n",DELJUL)
		printf("time of day and season into the output. Resetting to %.4f\n",DELJUL)
	}

	#This handles if we are using KRCs Temperature Predicting capabilits
	#for increased speed, for LOW DELJULs, the model may not reach stability
	#before the prediction happens
	if(DELJUL<=3*PERIOD) {
		if(HasValue(TPREDICT)==0) TPREDICT="F"
	} 
	if(HasValue(TPREDICT)==0) TPREDICT="T"
	if(TPREDICT=="F") {
		if(HasValue(GGT)==0) GGT=99.
		if(HasValue(N3)==0) N3=1
		if(HasValue(NRSET)==0) NRSET=999
	} else {
		if(HasValue(GGT)==0) GGT=atof(key.part1.value[,maxpos(key.part1.key=="GGT")[2]])
		if(HasValue(N3)==0) N3=atof(key.part2.value[,maxpos(key.part2.key=="N3")[2]])
		if(HasValue(NRSET)==0) NRSET=atof(key.part2.value[,maxpos(key.part2.key=="NRSET")[2]])
	}	

  #calculate N1/N2 so that we optimize run time and model stability  
  #calculate the minumum number of layers required to reach 3 seasonal skin depths

	#note this is actually running when we call the one point mode too...we should probably modify that.
   N1struct=krc_evalN1(RLAY,FLAY,upper.req.INERTIA,upper.req.SPEC_HEAT,upper.req.DENSITY,DELJUL,N5,JDISK,MAXN1,PERIOD,lower.req.INERTIA2,lower.req.SpHeat2,lower.req.DENS2,thick,LKofT)
	#here we dont really honor FLAY-need to decide what happens when the user overwrites FLAY/RLAY
	FLAY=N1struct.req.FLAY
	RLAY=N1struct.req.RLAY
	if(HasValue(IC2)==0)   IC2=N1struct.req.IC2
	if(HasValue(N1)==1)    N1struct.req.N1=N1                                             #SP 2019 05 16: Allows to set N1 in one point mode
	if(HasValue(N1)==0)    N1=N1struct.req.N1 
	                                               
	if(HasValue(LZONE)==0) LZONE=N1struct.req.LZONE

	#use the krc_evalN1 generated zone file which is like the albedo/taud files
	if(LZONE=="T") {
	  #zonefile must be located where KRC runs - forces a soft link to krc
 	  write(N1struct.Zone.inp,workdir+"/zonefile.tab",type=ascii,force=1)	  
	  params=cat(params,sprintf("8 25 0 'zonefile.tab' /"),y)
	  if(v==1) printf("ZONE FILE\n")
	}

  #calculate the minumum number of times per day for krc to run
  if(HasValue(N2)==0) {
  	N2=krc_evalN2(FLAY,INERTIA,upper.req.DENSITY,upper.req.SPEC_HEAT,PERIOD,N24,MAXN2)
  }
  
  #Print the options chosen the nice set of parameters
  #This is messy...and will be for a while
  printf("\nRunning KRC model for ")
	if(bodytype=="planet" || bodytype=="comet" || bodytype=="minor") {
		printf("%s (%s) with:\n\n",body,bodytype)
	} else if(bodytype=="satellite") {
		printf("%s (satellite), around %s (body) with:\n\n",strsplit(body)[,2],strsplit(body)[,1])
	} else {
		printf("generic body with:\n\n")
	}

  printf("Output:\n")
  printf("\tEvery ~%.3f Ls (%.4f JD) for %i seasons starting at %.2f Ls\n",DELLS,DELJUL,N5-JDISK+1,DJUL)
  printf("\tFor %i times per day, every %i local minutes\n",N24,(24*60)/N24)
	if(TPREDICT=="F") {	
		printf("\tRunning model WITH NO temperature prediction\n")
		if(DELJUL<=3*PERIOD) printf("\tbecause DELJUL < %.4f\n",3*PERIOD)
	} else {
		printf("\tRunning model WITH temperature prediction for speed\n")
		if(DELJUL<=3*PERIOD) printf("\tbecause the user forced TPREDICT=\"T\"\n")
	}
  if(IC2!=999) {
    layerstring=sprintf("material properties changed at layer %i",IC2)
  } else {
    layerstring="uniform material properties"
  } 
  printf("\nFor a Surface With:\n")
  printf("\t%i Layers with %s and %i daily model time steps",N1,layerstring,N2)
  if(LKofT=="T") printf("\n\tand T-dependant material properties")
  if(HasValue(IIB)) {
    if(IIB==0) printf("\n\tand an insulating bottom edge condition")
    if(IIB==-1) printf("\n\tand a fixed bottom layer temperature of %.2fK",TDEEP)
    if(IIB==-2) printf("\n\tand all layers starting at the same temperature of %.2fK",TDEEP)
	  if(IIB>0) printf("\n\tand a geothermal heatflux of %.2f mW",IIB)
  }
		if(PhotoFunc==0.) printf("\n\tand a lambertian photometric surface")
		if(PhotoFunc<-1.) printf("\n\tand a Lommel-Seeliger photometric surface")
		if(PhotoFunc>=-1 && PhotoFunc<0) printf("\n\tand Minnaert photometric surface with exponent %.2f",abs(PhotoFunc))
		if(PhotoFunc>0 && PhotoFunc<1) printf("\n\tand Lunar-Like photometric surface with Keihm polynomial %.2f",PhotoFunc)
		if(PTOTAL<=0.1) {
			printf("\n\tfor an airless body")
		}

	if(PTOTAL>0.1) {
  	printf("\n\n")  
		printf("With Atmospheric Parameters:")
		printf("\n\tfor a body with an average global atmospheric pressure of %d Pa",PTOTAL)
		if(LVFT=="T") {
			printf("\n\tand a pressure-dependant condensable atmosphere")
		} else {
			printf("\n\tand a condensable atmosphere with frost Temperature of %.2f K",TFROST)
		}
		if(HasValue(KPREF)) {
			if(KPREF==1) {
				printf("\n\tand a seasonal pressure that follows Viking landers trends")
			} if(KPREF==2) {
				printf("\n\tand a seasonal pressure that depends on the global frost budget")
			}
		}
	}

	printf("\n\n")  
  printf("With Observation Parameters:\n")

  printf("\tLATITUDE: %6.2f\tLONGITUDE: %6.2f\n\tELEVATION: %.3fkm^\tSLOPE/AZIMUTH: %.2f/%.2fdeg\n",lat,lon,ELEV,SLOPE,SLOAZI)
  if(dim(ALBEDO)>1) {
    printf("\tALBEDO: Varies")
  } else {
    printf("\tALBEDO: %.3f^",ALBEDO)
  }
	if(PTOTAL>0.1) {
		if(dim(TAUD)>1) {
	    printf("\tOPACITY: Varies\n")
	  } else {
	    printf("\t\tOPACITY: %.3f\n",TAUD)
	  }
	} else {
		printf("\n")
	}
  if(hour!=-32768) {
    printf("\tHOUR: %.2f",hour)
  } else {
    printf("\tHOUR: All")
  }
  if(ls!=-32768) {
    printf("\t\tLS: %.2f\n\n",ls)
  } else {
    printf("\t\tLS: All\n\n")
  }

  if(HasValue(T)==0) {
    if(IC2!=999) {
 	    printf("Upper Material:\t\t\tLower Material:\n")
	    printf("\tINERTIA: %.2f\t\tINERTIA2: %.2f*\n\tCONDUCTIVITY: %.4f*\tCONDUCTIVITY: %.4f\n",upper.req.INERTIA,lower.req.INERTIA2,upper.COND,lower.req.COND2)
      printf("\tDENSITY: %.2f*\tDENSITY: %.2f*\n\tSPECIFIC HEAT: %.2f\tSPECIFIC HEAT: %.2f\n",upper.req.DENSITY,lower.req.DENS2,upper.req.SPEC_HEAT,lower.req.SpHeat2)

	    printf("\tPOROSITY: %.2f\t\tPOROSITY: %.2f\n\n",upper.porosity,lower.porosity2)

    } else {
 		printf("Upper Material:\n")
 	    printf("\tINERTIA: %.2f\n\tCONDUCTIVITY: %.4f*\n\tDENSITY: %.2f*\n\tSPECIFIC HEAT: %.2f\n\tPOROSITY: %.2f\n",upper.req.INERTIA,upper.COND,upper.req.DENSITY,upper.req.SPEC_HEAT,upper.porosity)
 	  }
    
		printf("\n* = derived value unless overwritten by user\n")
		if(bodytype!="generic") {
			if(body=="Mars") printf("^ = from TES 2ppd map unless overwritten by user\n")
			if(body!="Mars") printf("^ = Prescribed value unless overwritten by user\n")
		}
  } else {
    printf("Running One-Point Simulation Mode\n\n")
  }

  #start constructing the input file
  #set N4 because KRC performs the check of # of elevations/latitudes prior to setting the change cards.
  N4part2posy=maxpos(inp.part2==grep(inp.part2,"N4")[,1])[2]
  N4part2posx=strstr(inp.part2[,N4part2posy],"N4")+1
  inp.part2[N4part2posx-9:N4part2posx,N4part2posy+1]=sprintf("%10s",N4+"")

  #Deal with the upgraded change card options
  #Start with part 3: the boolean values (translate them from T/F to 0/1 using atob)
  for(i=1;i<=length(key.part3.key);i+=1) {
    if(eval(sprintf("HasValue(%s)==1",key.part3.key[,i]))){
      params=cat(params,sprintf("3 %i %i '%s' /",i,atob(eval(key.part3.key[,i])),key.part3.key[,i]),axis=y)
      if(v==1) printf("YES %s=%i\n",key.part3.key[,i],atob(eval(key.part3.key[,i])))
    } else {
      if(v==1)  printf("NO %s\n",key.part3.key[,i])
    }
  }

  #Then part 2: the integer values
  for(i=1;i<=length(key.part2.key);i+=1) {
    if(eval(sprintf("HasValue(%s)==1",key.part2.key[,i])) && key.part2.key[,i]!="N4"){
      verbose=0
      params=cat(params,sprintf("2 %i %i '%s' /",i,eval(key.part2.key[,i]),key.part2.key[,i]),axis=y) #THIS LINE HAS AN ISSUE WHEN SETTING TUN8="T" or "F" #OK but TUN8 should not be "T" or "F"
      verbose=1
      if(v==1) printf("YES %s=%i\n",key.part2.key[,i],eval(key.part2.key[,i]))
    } else {
      if(v==1) printf("NO %s\n",key.part2.key[,i])
    }
  }
  
  #Then part 1: the floating point values
  #Also check for a time varying albedo/taud
  for(i=1;i<=length(key.part1.key);i+=1) {
  
    #check to see if the variable has a value
    if(eval(sprintf("HasValue(%s)==1",key.part1.key[,i]))){
  
      #if ALBEDO is an array, do a special thing
      if (max(dim(ALBEDO))>1 && key.part1.key[,i]=="ALBEDO") {
        var=read_lines($DV_SCRIPT_FILES+"/krc_support/var_header.ascii")
        for(j=1;j<=dim(ALBEDO)[2];j+=1) {
          var=cat(var,sprintf("%.2f\t%.2f",ALBEDO[1,j],ALBEDO[2,j]),axis=y)
        }
        write(var,workdir+"/albfile.tab",type=ascii,force=1)
        params=cat(params,sprintf("8 22 0 '%s/albfile.tab' /", workdir),y)
        if(v==1) printf("ALBEDO Array\n")
  
      #if TAUD is an array, do the same special thing.
      } else if(max(dim(TAUD))>1 && key.part1.key[,i]=="TAUD") {
        var=read_lines($DV_SCRIPT_FILES+"/krc_support/var_header.ascii")
        for(j=1;j<=dim(TAUD)[2];j+=1) {
          var=cat(var,sprintf("%.2f\t%.2f",TAUD[1,j],TAUD[2,j]),axis=y)
        }
        write(var,workdir+"/taufile.tab",type=ascii,force=1)
        params=cat(params,sprintf("8 23 0 '%s/taufile.tab' /", workdir),y)
        if(v==1) printf("TAUD Array\n")
  
      #otherwise, just do the normal thing
      } else {  
				if(eval(key.part1.key[,i])<1 && eval(key.part1.key[,i])>-1) {
	        params=cat(params,sprintf("1 %i %.3E '%s' /",i,eval(key.part1.key[,i]),key.part1.key[,i]),axis=y)
	        if(v==1) printf("YES %s=%.3E\n",key.part1.key[,i],eval(key.part1.key[,i]))
				} else {
		      params=cat(params,sprintf("1 %i %.4f '%s' /",i,eval(key.part1.key[,i]),key.part1.key[,i]),axis=y)
	        if(v==1) printf("YES %s=%.4f\n",key.part1.key[,i],eval(key.part1.key[,i]))
				}
      }
    } else {
    if(v==1) printf("NO %s\n",key.part1.key[,i])
    }
  }

  #set the output file path
  params=cat(params,sprintf("8 5 0 '%s/outdata.bin.%s' /",workdir,K4OUT+""),y) 

	if(ffout!="" && ffin!="" ) {
		printf("Error: Far Field Out and Input may not be set simultaneously\n")
	} else {
		if(ffout!="") {
			if(v==1) printf("Writing Far Field File to %s\n",ffout)
			K4OUT2=-3
			k4out_loc=maxpos(key.part2.key=="K4OUT")[2]
			params=cat(params,sprintf("2 %i %i '%s' /",k4out_loc,K4OUT2,"K4OUT2"),y)
			params=cat(params,sprintf("8 21 0 '%s' /",ffout),y)
			if(KEEP != "T") syscall("rm "+ffout)                                          #KEEP FILES FOR DEBUGS
		}

		if(ffin!="") {
			if(v==1) printf("Reading Far Field File from %s\n",ffin)
			params=cat(params,sprintf("8 3 0 '%s' /",ffin),y)
		}
	}

 #Add Eclipse line here
  if(HasValue(Eclipse)==1){
    Eclipse_line = krc_eclipse(Eclipser=Eclipser,body=body,Ecl_Cent_Hr=Ecl_Cent_Hr,Bias=Bias,Eclipse_Style=Eclipse_Style,Sun_Dis=Sun_Dis,Eclipser_Rad=Eclipser_Rad,CM=CM,Eclipsed_Rad=Eclipsed_Rad,Per_Mut=Per_Mut,Date=Date)
    params       = cat(params,Eclipse_line,axis=y)
  }  

        if(HasValue(PFlux)==1){
		if((PFlux == "T")&&(HasValue(IR) == 1)){
 			printf("Customized Planetary Flux")
			Planetary_Flux=krc_planetary_flux_table(IR,Vis,Lon_Hr)
		}
        }

  #Add planetary Flux line here
  if(HasValue(Planetary_Flux)==1){
    params=cat(params,Planetary_Flux,axis=y)
  }  
 
  #end the run
  params=cat(params,sprintf("0/"),y)
  params=cat(params,sprintf("0/"),y)

  #This is the standard KRC_BIN case
  if(HasValue(T)==0) {
    #Assemble and write the input file to the temporary directory
    input=cat(inp.header,inp.part1,inp.part2,inp.part3,inp.part4,inp.part5,inp.part6,params,axis=y)
    write(input,workdir+"/krc.inp",ascii,force=1)                                     
    
    #run krc on the input file we just generated.
		if($DV_OS=="mac") { 
			cmd="chmod a+rwx "+workdir+"/"+krcprog+" ;"
		} else {
			cmd=""
		}

    if(v>=1){
      system("cd "+workdir+"; ln -s "+$DV_KRC_HOME+"/src/"+krcprog+" .; "+cmd+" ./"+krcprog+" < "+$DV_SCRIPT_FILES+"/krc_support/fake_krc344 2>&1 | tee -a "+workdir+"/krc.log")
      log=read_lines(workdir+"/krc.log")
    } else {
      log=syscall("cd "+workdir+"; ln -s "+$DV_KRC_HOME+"/src/"+krcprog+" .; "+cmd+" ./"+krcprog+" < "+$DV_SCRIPT_FILES+"/krc_support/fake_krc344")
    }

		#make sure krc ran appropriately and created a bin5 file
		if(fexists(workdir+"/outdata.bin."+K4OUT)==0) {
			printf("KRC failed to run for some reason\n")
			printf("Returning the runtime log\n")
			return(log)
		}

    #load the full bin5 struct if the anc data flag is set
    #process the bin52 file...other formats can go here too.
    ret=process_bin52(workdir+"/outdata.bin."+K4OUT,raw=anc,hour=hour,ls=ls,TUN8=TUN8)
  
    #setup the ouput structure
    out={}
    
    #fill in the output data
    out=ret
    out.alb=ALBEDO
    out.elev=ELEV
		out.body=porb.body
		out.anc.porb=porb
		if(bodytype=="generic") out.anc.porb.elements=body

  } else {

    #This case is like the KRC_ONE Option
    #Krc is run multiple times and interpolate T to get TI values
		#value=14;expon=0.65765;steps=35

		if(HasValue(TI_Guess)==0) {
			#set the exponent and starting point
			value=14
			expon=0.6313
			steps=int(40)                                                                     #Might want to reduce that
	
			#create the TI table
			T_table=TI_table=create(steps,1,1,start=0,step=0,format=float)
	    for(i=1;i<=dim(TI_table)[1];i+=1) {
				TI_table[i]=value=round(ceil((value^expon))+value)
	    }
		} else {
      TI_table = cat(TI_Guess*0.55,TI_Guess*0.85,TI_Guess*1.15,TI_Guess*1.45,axis=x)
      T_table  = TI_table * 0.0
      steps    = dim(TI_table)[1]
    }

		#find the position of things that need to change
		#currently this only works for parts 1/2
		removelist=cat("INERTIA","N2","ConUp0","ConUp1","ConUp2","ConUp3","FLAY","RLAY","IC2","N1",axis=y)
		update=pos=index=part_num=clone(0,length(removelist),1,1)

		#loop through the remove list to make sure we delete and index all values that need to be updated
		for(j=1;j<=length(removelist);j+=1) {	
			
			#determine which part each item comes from so we can index it in the future
			part_num[j]=int(sum((key.part1.key==removelist[,j]))+sum(key.part2.key==removelist[,j])*2)
			index[j]=maxpos(eval("key.part"+part_num[j]+".key")==removelist[,j])[2]

			#determine the position of each item in the parameters list and remove it
			if(HasValue(grep(params,removelist[,j]))) {
				pos[j]=maxpos(params==grep(params,removelist[,j])[,1])[2]
				params=cat(params[,:pos[j]-1],params[,pos[j]+1:],axis=y)
			}
		}

    #remove the trailing double zeros
    params=params[,:length(params)-2]

    #loop through all cases and make the table
    for(i=1;i<=steps;i+=1) {
	
			INERTIA = TI_table[i]
					
			if(Mat1 == "basalt"){   
			  Density_bulk = 3100.
			  if(HasValue(SphUp0)==0)    (SphUp0=609.906)
			  if(HasValue(SphUp1)==0)    (SphUp1=214.231)
			  if(HasValue(SphUp2)==0)    (SphUp2=-40.9437)
			  if(HasValue(SphUp3)==0)    (SphUp3=11.2575)
			  if(HasValue(SPEC_HEAT)==0) (SPEC_HEAT=SphUp0)                               #Cp(220K)			  
				if(INERTIA > TI_CO){                                                      #Case of bulky basalt, the k(T) is only a function of the temperature
		  		if(HasValue(DENSITY)==0)   (DENSITY=Density_bulk)
		  		Por1                       = 1.-(DENSITY/Density_bulk)
		  		if(Por1<0)                 (Por1=0)
		  		COND                       = INERTIA^2/(SPEC_HEAT*(1-Por1)*Density_bulk)  
		  		ConUp0                     = COND
		  		ConUp1                     = -1.51737  
		  		ConUp2                     = 0.587176
		  		ConUp3                     = -0.126695
		  		if(LKofT == "F"){
			    ConUp0                     = COND
			    ConUp1                     = ConUp2 = ConUp3 = 0.
                }
				}    
			}
			if(Mat1 == "H2O"){   
			  Density_bulk = 924.148
			  if(HasValue(SphUp0)==0)    (SphUp0=1704.57)
			  if(HasValue(SphUp1)==0)    (SphUp1=713.339)
			  if(HasValue(SphUp2)==0)    (SphUp2=110.694)
			  if(HasValue(SphUp3)==0)    (SphUp3=75.7506)
			  if(HasValue(SPEC_HEAT)==0) (SPEC_HEAT=SphUp0)                               #Cp(220K)
				if(INERTIA > TI_CO){                                                      #Case of bulky water ice, the k(T) is only a function of the temperature #Case of bulky basalt
				  if(HasValue(DENSITY)==0)   (DENSITY=Density_bulk)
				  Por1                       = 1.-(DENSITY/Density_bulk)
				  if(Por1<0)                 (Por1=0)
				  COND                       = INERTIA^2/(SPEC_HEAT*(1.-Por1)*Density_bulk) 
				  ConUp0                     = COND
				  ConUp1                     = -1.08693  
				  ConUp2                     = -0.334381 
				  ConUp3                     = -1.60453
				  if(LKofT == "F"){
			      ConUp0                     = COND
			      ConUp1                     = ConUp2 = ConUp3 = 0.
                  }
				}    
			}
	
			if((INERTIA <= TI_CO)&&(PTOTAL==0.)){                                         #T^3 trend for k for airless bodies (inspired from Hayne et al. 2016)
			  if(HasValue(DENSITY)==0)   (DENSITY=(1.-Por1)*Density_bulk)
			  Por1                       = 1.-(DENSITY/Density_bulk)
			  if(Por1<0)                 (Por1=0)
			  COND                       = INERTIA^2/(SPEC_HEAT*(1.-Por1)*Density_bulk)
			  T_Table                    = create(1,50,1,start=10.,step=10.,format=float)
			  T_Table_KRC                = (T_Table - 220.)*0.01
			  k_Table                    = COND*(1+2.7*((T_Table-T_user)/350.)^3)         #k(T^3) + a function of the density/porosity
			  FIT                        = fit(y=k_Table,x=T_Table_KRC,"cube",plot=0)
			  ConUp0                     = FIT[1]
			  ConUp1                     = FIT[2]
			  ConUp2                     = FIT[3] 
			  ConUp3                     = FIT[4]
			  if(LKofT == "F"){
			  ConUp0                     = COND
			  ConUp1                     = ConUp2 = ConUp3 = 0.
              }
			}
			
			if((INERTIA <= TI_CO)&&(PTOTAL!=0.)){                                         #sqrt(T) trend for k for Mars, kinetic theory of gases (inspired from Piqueux and Christensen09)
			  if(HasValue(DENSITY)==0)   (DENSITY=(1.-Por1)*Density_bulk)
			  Por1                       = 1.-(DENSITY/Density_bulk)
			  if(Por1<0)                 (Por1=0)
			  COND                       = INERTIA^2/(SPEC_HEAT*(1-Por1)*Density_bulk)
			  T_Table                    = create(1,50,1,start=10.,step=10.,format=float)
			  T_Table_KRC                = (T_Table - 220.)*0.01
			  k_Table                    = COND*sqrt(T_Table/220.)                        #k(T^0.5) + a function of the density/porosity
			  FIT                        = fit(y=k_Table,x=T_Table_KRC,"cube",plot=0)
			  ConUp0                     = FIT[1]
			  ConUp1                     = FIT[2]
			  ConUp2                     = FIT[3]  
			  ConUp3                     = FIT[4]
			  if(LKofT == "F"){
			  ConUp0                     = COND
			  ConUp1                     = ConUp2 = ConUp3 = 0.
              }
			}
		
			upper               = {}
			upper.req           = {}
			upper.req.INERTIA   = INERTIA
#			upper.req.SphUp0    = SphUp0     = SPEC_HEAT
			upper.req.SphUp0    = SphUp0
			upper.req.SphUp1    = SphUp1  
			upper.req.SphUp2    = SphUp2
			upper.req.SphUp3    = SphUp3
			upper.req.SPEC_HEAT = SPEC_HEAT  
			upper.req.DENSITY   = DENSITY 
			upper.req.ConUp0    = ConUp0     = COND
			upper.req.ConUp1    = ConUp1 
			upper.req.ConUp2    = ConUp2
			upper.req.ConUp3    = ConUp3
			upper.COND          = COND                                                    #This is NOT upper.req.COND (no .req.)
			upper.composition   = Mat1
			upper.porosity      = Por1
								
			#calculate parameters for optimal model stability 
		  N1struct=krc_evalN1(RLAY,FLAY,upper.req.INERTIA,upper.req.SPEC_HEAT,upper.req.DENSITY,DELJUL,N5,JDISK,MAXN1,PERIOD,INERTIA2,SpHeat2,DENS2,thick,LKofT)    #Missing "LKofT"

			#Force the onepoint mode to have IC2=999				
			N1struct.req.IC2=999
			if(thick!=0) {
				print("\nNOTE: More than one material is not permitted in the \"one point mode\". Ignoring all but the top layer properties\n")
			}

		  N2=float(krc_evalN2(N1struct.req.FLAY,upper.req.INERTIA,upper.req.DENSITY,upper.req.SPEC_HEAT,PERIOD,N24,MAXN2))		  
			if(LKofT=="T") {
				#update FLAY, RLAY, IC2, N1, plus all the T dependant parameters
				vals=cat(TI_table[i],N2,float(upper.req.ConUp0),float(upper.req.ConUp1),float(upper.req.ConUp2),float(upper.req.ConUp3),float(N1struct.req.FLAY),float(N1struct.req.RLAY),float(N1struct.req.IC2),float(N1struct.req.N1),axis=x)
			} else {
				#if LKofT is F, still update N1, FLAY, RLAY, IC2, N2 and TI
#				vals=cat(TI_table[i],N2,N1struct.req.FLAY,N1struct.req.RLAY,float(N1struct.req.IC2),float(N1struct.req.N1),axis=x)
#				vals=cat(TI_table[i],N2,float(upper.req.ConUp0),float(upper.req.ConUp1),float(upper.req.ConUp2),float(upper.req.ConUp3),float(N1struct.req.FLAY),float(N1struct.req.RLAY),float(N1struct.req.IC2),float(N1struct.req.N1),axis=x)
				vals=cat(TI_table[i],N2,0.,0.,0.,0.,float(N1struct.req.FLAY),float(N1struct.req.RLAY),float(N1struct.req.IC2),float(N1struct.req.N1),axis=x)

			}
			#insert the updated change cards dynamically
			tparams=text(0)
			for(j=1;j<=dim(vals)[1];j+=1) {
				if(part_num[j]==1) {
					if(vals[j]<1 && vals[j]>-1)	{
						tparams=cat(tparams,sprintf("1 %i %.3E '%s' /",index[j],vals[j],removelist[,j]),axis=y)
					} else {
						tparams=cat(tparams,sprintf("1 %i %.4f '%s' /",index[j],vals[j],removelist[,j]),axis=y)
					}
				} else if (part_num[j]==2) {
					tparams=cat(tparams,sprintf("2 %i %i '%s' /",index[j],vals[j],removelist[,j]),axis=y)
				}
	      if(v==1) printf("YES %s=%f\n",removelist[,j],vals[j])
			}
			params=cat(params,tparams,"0/",axis=y)
    }
    params=cat(params,"0/",axis=y)

    #Assemble and write the input file to the temporary directory
    input=cat(inp.header,inp.part1,inp.part2,inp.part3,inp.part4,inp.part5,inp.part6,params,axis=y)
    write(input,workdir+"/krc.inp",ascii,force=1)
    
		if($DV_OS=="mac") { 
			cmd="chmod a+rwx "+workdir+"/"+krcprog+" ;"
		} else {
			cmd=""
		}

    #run krc on the input file we just generated.
    if(v>=1) {
      system("cd "+workdir+"; ln -s "+$DV_KRC_HOME+"/src/"+krcprog+" .; "+cmd+" ./"+krcprog+" < "+$DV_SCRIPT_FILES+"/krc_support/fake_krc344 2>&1 | tee -a "+workdir+"/krc.log")
      log=read_lines(workdir+"/krc.log")
    } else {
      log=syscall("cd "+workdir+"; ln -s "+$DV_KRC_HOME+"/src/"+krcprog+" .; "+cmd+" ./"+krcprog+" < "+$DV_SCRIPT_FILES+"/krc_support/fake_krc344")
    }

		#make sure krc ran appropriately and created a bin5 file
		if(fexists(workdir+"/outdata.bin."+K4OUT)==0) {
			printf("KRC failed to run for some reason\n")
			printf("Returning the runtime log\n")
			return(log)
		}

		#get the mulitcase input
    ret=process_bin52(workdir+"/outdata.bin."+K4OUT,raw=0,hour=hour,ls=ls,one=1,TUN8=TUN8)

    #create the temperature lookup table
		cases=grep(get_struct_key(ret),"case")
		ncases=length(cases)
    for(i=1;i<=ncases;i+=1) { 
      T_table[i]=get_struct(ret,cases[,i]).tsurf
    }

		#remove bad values (e.g. 0)
		TI_table=extract(TI_table,T_table)
		T_table=extract(T_table,T_table)
	
		###NEW STUFF HERE#########################################################################
		T_table_frost = T_table
		T_table[where T_table <= (TFROST + 0.5)] = -999.                                  #
		
#write(T_table,"~/Desktop/T_Table.ascii",ascii,force=1)
#write(TI_table,"~/Desktop/TI_Table.ascii",ascii,force=1)
		
		if(max(T_table) > min(T_table + 0.1)){
			POS  = valpos(T_table,T)[1]		
			if(POS > 3){
				T_table[:POS-3,,] = -999.
			}
			
			if(POS < dim(T_table)[1]-3){
				T_table[POS+3:,,] = -999.
			}
			
			Num_Val = int(ccount(T_table,-999)[3,1,1])
			
			
			if(Num_Val >= 3){
			  if(POS <= 3){                                                               #First 3 values
			  	FIT     = fit(y=TI_table[1:Num_Val,1,1],x=T_table[1:Num_Val,1,1],type="cube",ignore=-999.)
				  TI    = FIT[1] + FIT[2]*T + FIT[3]*T^2 + FIT[4]*T^3
				  n_ini = 1
				  n_fin = 3
			  }
			
			  if((POS > 3)&&(POS <= dim(T_table)[1]-2)){                                  #Middle of the LuT values
				  FIT   = fit(y=TI_table[POS-2:POS+2,1,1],x=T_table[POS-2:POS+2,1,1],type="cube",ignore=-999.)
				  TI    = FIT[1] + FIT[2]*T + FIT[3]*T^2 + FIT[4]*T^3
				  n_ini = POS - 2
				  n_fin = POS + 2
			  }
			  
			  if((POS > dim(T_table)[1]-2)){                                              #Last 3 values
				  FIT     = fit(y=TI_table[dim(T_table)[1]-2:,1,1],x=T_table[dim(T_table)[1]-2:,1,1],type="cube",ignore=-999.)
				  TI      = FIT[1] + FIT[2]*T + FIT[3]*T^2 + FIT[4]*T^3
				  n_ini   = dim(T_table)[1]-2
				  n_fin   = dim(T_table)[1]
			  }  
			}
			
			if(Num_Val == 2){
				FIT     = fit(y=TI_table,x=T_table,ignore=-999.,type="linear")
				TI      = FIT[1] + FIT[2]*T
			}
			
			TI_table[where T_table == -999.] = -999.
			if((TI < min(TI_table,ignore=-999.))||(TI > max(TI_table))){                              #If a quadratic is non sensical, return a linear fit TI
				FIT     = fit(y=TI_table,x=T_table,ignore=-999.,type="linear")
				TI      = FIT[1] + FIT[2]*T
			}
		} else {
		  POS     = 0
		  TI      = -600.
		  n_ini   = 1
		  n_fin   = 40
		  T_table = TFROST 
	    }

    TI_Buffer = TI
		
		#check to see if we produced a TI
		if(HasValue(TI) != 1){
			TI = -500.
		}

		#check for negative TI Values
		TI[where TI<0. && TI!=-500.]=-400.
	
		#check for TI outside of lookup table low side
		TI[where TI< min(TI_table,ignore=-999.)]=-600.

		#check for TI outside of lookup table high side
		TI[where TI>2200.]=-300

		#Poor TI Guess
		if((HasValue(TI_Guess_PCT)==1)&&(HasValue(TI_Guess)==1)){
			TI[where (TI < TI_Guess*(1.-TI_Guess_PCT)) || (TI > TI_Guess*(1.+TI_Guess_PCT))]=-200
		}

		if((HasValue(TI_Guess_PCT)==1)&&(HasValue(TI_Guess)!=1)){
			TI = -100.
			TI_Guess = 0.
		}    

    #print the values we interpolate for...this is no longer quite right...SYLVAIN please update with something.
    printf("Fitting for TI values: %.2f to %.2f\n",min(TI_table,ignore=-999),max(TI_table))
    printf("    with temperatures: %.2fK to %.2fK\n",min(T_table,ignore=-999),max(T_table))
    if(HasValue(TI_Guess)==0) 	printf("    with steps from: %i to %i out of %i\n",n_ini,n_fin,ncases)
		if(TI==-300) printf("    without meeting possible TI criterion: %.1f Kieffer \n",TI_Buffer)
		if(HasValue(TI_Guess)) printf("    and a TI guess of: %.1f Kieffer\n",TI_Guess)
		if(HasValue(TI_Guess_PCT)) printf("    and a tolerance on TI of: %.1f Kieffer \n",TI_Guess*TI_Guess_PCT)
		if(HasValue(TI_Guess_PCT)&&(TI<0.)) printf("    without meeting validity criterion: %.1f Kieffer \n",TI_Buffer)		 
		printf("\n")		

#		write(TI_table,"~/Desktop/TI_table.ascii",ascii,force=1)                                  #FLAG_REMOVE
#		write(T_table,"~/Desktop/T_table.ascii",ascii,force=1)                                    #FLAG_REMOVE
	
	  #return some ancellary data
    if(anc==1) {
      out={}
      out.TI=TI
      out.TI_table=TI_table
      out.T_table=T_table
			out.T_table_orig=T_table_orig
      out.T=T
    } else {
  	  #clean up
 			if(KEEP != "T") syscall("rm -rf "+workdir+"/*")                               #KEEP FOR DEBUG
			if($DV_OS=="mac") {
			  if(KEEP != "T") syscall("rmdir "+workdir)
			  if(KEEP != "T") syscall("rm -rf "+workdir+"/*")                             #KEEP FOR DEBUG        
			}      
			return(TI)
    }
  }

  #if the user wants all the ancellary data then generate it
  #this contains the running original input file, change cards, 
  #all small parts, logs, an the print file.
  if(anc==1) {
    out.anc={}
		out.anc.porb=porb
		out.anc.N1struct=N1struct.req.N1                                                  #SP 11/01/2017
		out.anc.upper=upper
		out.anc.lower=lower

    #return the full input file
    out.anc.input=input

    #return the change cards
    out.anc.change_cards=params
    out.anc.values={}
    
    #Parse and clean up the key_value pairs into a single structure
    #This can't be done earlier because the order/count needs to be preserved 
    for(i=1;i<=length(key.part1.key);i+=1) {
      if(eval("HasValue("+key.part1.key[,i]+")==1")) {
        add_struct(out.anc.values,name=key.part1.key[,i],value=eval(key.part1.key[,i]))
      } else {
        add_struct(out.anc.values,name=key.part1.key[,i],value=key.part1.value[,i])
      }
    }
    for(i=1;i<=length(key.part2.key);i+=1) {
      if(eval("HasValue("+key.part2.key[,i]+")==1")) {
        add_struct(out.anc.values,name=key.part2.key[,i],value=eval(key.part2.key[,i]))
      } else {
        add_struct(out.anc.values,name=key.part2.key[,i],value=key.part2.value[,i])
      }
    }
    for(i=1;i<=length(key.part3.key);i+=1) {
      if(eval("HasValue("+key.part3.key[,i]+")==1")) {
        add_struct(out.anc.values,name=key.part3.key[,i],value=eval(key.part3.key[,i]))
      } else {
        add_struct(out.anc.values,name=key.part3.key[,i],value=key.part3.value[,i])
      }
    }
    
    #return other output   
    out.anc.values.latitude=inp.part4
    out.anc.values.elevation=inp.part5
    out.anc.values.orbit=inp.part6
    out.anc.parts=inp
  
    #return the log and print data
    out.anc.log=log

    #keep the raw data too
    if(HasValue(T)!=0) {
			out.anc.raw_data=ret
		}

		#get and return the krc prt
    if(HasValue(prt)==0) {
			prt=read_lines(workdir+"/krc.prt")
		}
    out.anc.prt=prt
	}

  # Clean up the mess that we've created
  if(KEEP != "T") syscall("rm -rf "+workdir+"/*")                                         #KEEP FOR DEBUG
		
	if(stability==1 && HasValue(T)==0) {
		out.stability=stability_flag_krc(out,TFROST)
	}
	
  #return the output
   out.depth           = translate(N1struct.layer.m.depth,from=z,to=y)
   N1struct.layer.tmin = out.layer.tmin
   N1struct.layer.tmax = out.layer.tmax
   out.layer           = N1struct.layer  
  
return(out)
}



define process_bin52(raw,hour,ls,usage,one,TUN8) {
	
	
  if($ARGC == 0 && HasValue(usage)==0) {
    printf("\n")
    printf("Read in bin52 krc file and process to something more manageable\n")
    printf("\t$1 = filename\n\n")
    printf("Optional:\n")
    printf("\thour=return the specified hour (Default = -32768 for all hours)\n")
    printf("\tls=return the specified ls (Default = -32768 for all ls)\n")
    printf("\traw=return the raw data as well (Default = 0)\n")
		printf("\tusage=print the output usage (Default=0)\n")
		printf("\tone=process only the tsurf data for the one point mode\n\n")
    printf("C.Edwards 4/14\n\n")
  }

  if($ARGC == 0 || HasValue(usage)==1) {
    printf("Bin52 output struct is:\n")
    printf("By case#, where elements are:\n")
    printf("\tsurf - surface temperature (K) \t\t\t\t\t\t(Hours X Latitudes or Depth (default) X Seasons)\n")
    printf("\tbol - bolomieter temperature (K) \t\t\t\t\t(Hours X Latitudes X Seasons)\n")
    printf("\ttatm - atmosphere temperature (K) \t\t\t\t\t(Hours X Latitudes X Seasons)\n")
    printf("\tdown_vis - solar wavelength radiant flux (W/m^2)\t\t\t(Hours X Latitudes X Seasons)\n")
    printf("\tdown_ir - infrared downwelling radiant flux (W/m^2)\t\t\t(Hours X Latitudes X Seasons)\n")
    printf("\ttime - corresponding time of day axis (local hour) \t\t\t(Hours X 1 X 1)\n")
    printf("\tls - corresponding season axis (solar longitude)\t\t\t(1 X 1 X Seasons)\n")
    printf("\tlat - corresponding latitude (degrees)\t\t\t\t\t(1 X Latitudes X 1)\n")
    printf("\telev - corresponding elevation for specified latitude (km)\t\t(1 X Latitudes X 1)\n\n")
		printf("\tlayer - structure containing all layer properties\n")	
		printf("\tlayer.thickenss - layer thickness (m & skindepths)\t\t\t(Layers X Type x 1)\n")
		printf("\tlayer.center - center position (m & skindepths)\t\t\t\t(Layers X Type x 1)\n")
		printf("\tlayer.top - top position (m & skindepths)\t\t\t\t(Layers X Type x 1)\n")
		printf("\tlayer.center_mass - layer-center columnar mass (kg/m^2)\t\t\t(Layers X 1 x 1)\n")
		printf("\tlayer.mass_burden - mass burden above bottom layer (kg/m^2)\t\t(Layers X 1 x 1)\n")
		printf("\tlayer.thermal_scales - thermal scales above bottom layer (skindepths)\t(Layers X 1 x 1)\n")
		printf("\tlayer.tmax - maximum daily temperature for every layer (K)\t\t(Layers X Latitudes x Seasons)\n")
		printf("\tlayer.tmin - minimum daily temperature for every layer (K)\t\t(Layers X Latitudes x Seasons)\n\n")
		printf("\tanc - structure containing additional properties\n")	
		printf("\tanc.krccom - KRCcommon input parameters: real=fd, integer=id, and boolean=ld\n")
		printf("\tanc.JDate - Julian Date (J2000)\t\t\t\t\t\t(1 X 1 x Seasons)\n")
		printf("\tanc.ref_pressure - Current surface pressure at elevation 0 (Pascal)\t(1 X 1 x Seasons)\n")
		printf("\tanc.taud - Mean Visible Dust Opacity\t\t\t\t\t(1 X 1 x Seasons)\n")
		printf("\tanc.total_frost - Global average columnar mass of frost (kg/m^2)\t(1 X 1 x Seasons)\n")
		printf("\tanc.avg_heat_flow - Mean Upward heat flow on the last day (W/m^2)\t(1 X Latitudes x Seasons)\n")
		printf("\tanc.frost_alb - Frost albedo at the last time step\t\t\t(1 X Latitudes x Seasons)\n")
		printf("\tanc.frost - predicted frost amount (kg/m^2)\t\t\t\t(1 X Latitudes x Seasons)\n")
		printf("\tanc.tatm_predicted - predicted final atmospheric temperature (K)\t(1 X Latitudes x Seasons)\n")
		printf("\tanc.delta_t_rms - RMS temperature change on the last day (K)\t\t(1 X Latitudes x Seasons)\n")
		printf("\tanc.converge_days - number of days to compute a solution \t\t(1 X Latitudes x Seasons)\n")
    printf("\nIf only one case is present, the output will be composed only of these elements\n")
    printf("If multiple cases are present, the output will be composed of a structure of\n")
    printf("case1, case2, ..., caseN\n")
    printf("\n")
    return(null)
  }

  if(HasValue(raw)==0) raw=0
  if(HasValue(ls)==0) ls=-32768  
  if(HasValue(hour)==0) hour=-32768
	if(HasValue(one)==0) one=0
	if(HasValue(TUN8)==0) TUN8=0
	
  # Read in bin52 file
  data=load_bin5($1)
	header=unpack("a512",$1,count=1).c1[,1]
	vpos=strstr(header,"KRCv")
	Mversion=atoi(header[vpos+4])
	mversion=atoi(header[vpos+6])
	rversion=atoi(header[vpos+8])
	if(Mversion==3) {
		dtype="double"
	} else {
		dtype="float"
	}
  if((Mversion+mversion/10.)<2.3 || (Mversion+mversion/10.)>3.6) {
     printf("Unsupported bin52 file version\n")
     printf("Detected version: %i.%i.%i -- requires >=2.3.2 or <= 3.6 \n",Mversion,mversion,rversion)
     return(null)
   }

	#output structure
	out={}

  #multiple case options....
  for(k=1;k<=dim(data[1][1])[3];k+=1) {

		#temporary working structure.
    tmp={}
		anc={}

		#extra 4 items tacked on to the front of the prefix that set the header size
		#number of output seasons
		#Number of 8?-byte words in KRCCOM
		NWKRC=int(data[1][1][1,1,k])

		#1-based index of the dimension with extra values -- not really clear what this one is
		IDX=int(data[2][1][1,1,k])

		#Number of those extra - this is the the number of "extra" seasons
		NDX=int(data[3][1][1,1,k])

		#Number of output seasons
		NSOUT=int(data[4][1][1,1,k])

		#full prefix size
		prefixsize=NWKRC+NSOUT*5+IDX
		prefix=create(1,1,dim(data[1][1])[1]*length(data)*7*NDX,start=0,step=0,format=dtype,org=bsq)
		count=1

		#loop through over, 1) seasons, 2) lats, 3) items, 4) hours to turn them into a single dimensioned array
		for(j=1;j<=NDX;j+=1) {
			for(m=1;m<=dim(data[1][1])[1];m+=1) {
				for(l=1;l<=7;l+=1) {	
					for(i=1;i<=length(data);i+=1) {					
						#printf("count=%i,i=%i,l=%i,m=%i,j=%i,k=%i\n",count,i,l,m,j,k)
						prefix[,,count]=data[i][l][m,j,k]
						count+=1
					}
				}
			}
		}

		if(Mversion==3) {
			#get the parameters needed to calculate the layer type stuff
			#extract the float, integer, logicals parts
			skip=512+((k-1)*dim(data[1][1])[2]*dim(data[1][1])[1]*7*length(data)*8)

			#extract krccom
			#x8*4  = first 4 values that describe prefix
			#r8*96 = 64 real values in the input file modified by the changecards + 32 calculated values
			#r8*37 = MAXN4 (37) lat values
			#r8*37 = MAXN3 (37) elevation values
			#u4*40 = 40 integer parameters - first 25 input/last 15 calculated
			#u4*20 = 20 boolean parameters in the input file modified by the changecards
			#a80 = 80 character title
			#a24 = 24 character runtime 
			anc.krccom=unpack("x8*4r8*96r8*37r8*37u4*40u4*20a80a24",$1,skip=skip,count=1,col_names=cat("fd","lats","elevs","id","ld","title","runtime",axis=y))

		} else if (Mversion==2) {
			skip=512+((k-1)*dim(data[1][1])[2]*dim(data[1][1])[1]*7*length(data)*4)
			#extract krccom
			#x8*4  = first 4 values that describe prefix
			#r8*96 = 64 real values in the input file modified by the changecards + 32 calculated values
			#u4*40 = 40 integer parameters - first 25 input/last 15 calculated
			#u4*20 = 20 boolean parameters in the input file modified by the changecards
			#a80 = 80 character title
			#a20 = 20 character runtime 
			#r8*37 = MAXN4 (37) lat values
			#r8*37 = MAXN3 (37) elevation values
			anc.krccom=unpack("x4*4r4*96u4*40u4*20a80a20r4*37r4*37",$1,skip=skip,count=1,col_names=cat("fd","id","ld","title","runtime","lats","elevs",axis=y))
		}

		#get the parameters needed to calculate the layer type stuff.
		N1=int(anc.krccom.id[1])
		N24=int(anc.krccom.id[6])

		if(one==0) {
			N2=int(anc.krccom.id[2])
			IC2=int(anc.krccom.id[8])
			INERTIA=anc.krccom.fd[3]
			COND2=anc.krccom.fd[4]
			DENS2=anc.krccom.fd[5]
			PERIOD=anc.krccom.fd[6]
			SPHT=anc.krccom.fd[7]
			DENS=anc.krccom.fd[8]
			SPHT2=anc.krccom.fd[16]
			RLAY=anc.krccom.fd[33]
			FLAY=anc.krccom.fd[34]
			CONVF=anc.krccom.fd[35]
			LOCAL=anc.krccom.ld[15]
	
			#calculate some useful things
			COND=INERTIA^2/(DENS*SPHT)
			INERTIA2=sqrt(COND2*DENS2*SPHT2)
			PERSEC=PERIOD*86400
			DIFFU=COND/(DENS*SPHT)
			DIFF2=COND2/(DENS2*SPHT2)
			SCAL1=sqrt(DIFFU*PERSEC/3.141592741)
			SCAL2=sqrt(DIFF2*PERSEC/3.141592741)
	
			#set the diffusivity
			DIFF=clone(DIFFU,z=N1)
			if(IC2>1 && IC2<N1) {
				DIFF[,,IC2:]=DIFF2
			}
	
			#figure out layer progression in local units
			yy=FLAY*RLAY^create(1,1,N1,start=0,step=1,format=float)
	
			#calculate the layer thickness in meters
			if(LOCAL==1) {
				TLAY=yy*sqrt(DIFF*PERSEC/3.141592741)		
			} else {
				TLAY=yy*SQRT(DIFF[,,1]*PERSEC/3.141592741)
			}
	
			#calculate the depth to the center in meters
			CDEPTHS=create(1,1,N1,start=0,step=0,format=dtype)
			CDEPTHS[,,1]=-TLAY[,,1]/2
			for(i=2;i<=N1;i+=1) {
				CDEPTHS[,,i]=CDEPTHS[,,i-1]+(TLAY[,,i]+TLAY[,,i-1])/2.
			}
	
			#calculate the various layer properties.
			scale=SCAL1
			Q6=rhop=rhop=sumd=burd=0.
			layerprops=create(7,1,N1,format=dtype,start=0,step=0)
			for(i=1;i<=N1;i+=1) {
				if(i==1) {
					rho=DENS
				}
				if (i==IC2) {
					rho=DENS2
					scale=SCAL2
				}
				Q2=TLAY[,,i]/SCAL1
				Q4=CDEPTHS[,,i]/SCAL1
				if(i>1) {
					Q6=Q6+0.5*(TLAY[,,i-1]*rhop+TLAY[,,i]*rho)
					sumd=sumd+Q2
					burd=burd+TLAY[,,i]*rho
				}
				rhop=rho
				layerprops[,,i]=cat(format(Q2,type=dtype),format(TLAY[,,i],type=dtype),format(Q4,type=dtype),format(CDEPTHS[,,i],type=dtype),format(Q6,type=dtype),format(burd,type=dtype),format(sumd,type=dtype),axis=x)
			}
			
			#fill out the layer properties
			layer={}
			layer.thickness=translate(cat(layerprops[2],layerprops[1],axis=y),x,z)[2:]
			layer.center=translate(cat(layerprops[4],layerprops[3],axis=y),x,z)[2:]
			layer.top=layer.center-(layer.thickness*float(0.5))
			layer.center_mass=translate(layerprops[5],x,z)[2:]
			layer.mass_burden=translate(layerprops[6],x,z)[2:]
			layer.thermal_scales=translate(layerprops[7],x,z)[2:]
		}

		#figure out how many elements KRCCOM+extra items are
		prefix=prefix[,,NWKRC+IDX+1:]
		NumLayers=int(min(N1//N24-2))                                                    #SP TEST ISSUE WITH PASSING THE NUMBER OF LAYERS N1

		#create the time axis
 		time=create(length(data),1,1,start=24./length(data),step=24./length(data),format=float)

		#extract all the various parameters in the prefix of each case
		J2000=double(2451545.0)
		datals=prefix[,,NSOUT+1:NSOUT*2]

		if(one==0) {
#Maybe something like this to get the JDate for the time of day
			anc.JDate=double(prefix[,,:NSOUT])+J2000
			anc.ref_pressure=prefix[,,(NSOUT)*2+1:NSOUT*3]
			anc.taud=prefix[,,(NSOUT)*3+1:NSOUT*4]
			anc.total_frost=prefix[,,(NSOUT)*4+1:NSOUT*5]
		}
		
	  #reset the hour and ls to max/min values to prevent bogus numbers (e.g. -1)
 		if(ls !=-32768 && (ls>360 || ls<0)) {
    	printf("\nls (%f) is out of data range (0-360), aborting\n\n",ls)
			return(null)			
		}

 		if(hour !=-32768 && (hour>24 || hour<0)) {
    	printf("\nhour (%f) is out of data range (0-24), aborting\n\n",ls)
			return(null)			
		}

    #create the output data (hours X latitudes X seasons)
		if(one==0) {
	    tmp.down_vis=tmp.down_ir=tmp.tatm=tmp.tbol=tmp.tsurf=create(length(data),dim(data[1][1])[1],NSOUT,start=0,step=0,format=dtype)
	
			#create another output data arrray (1 X latitudes X seasons)
	    anc.converge_days=anc.delta_t_rms=anc.tatm_predict=anc.frost=anc.frost_alb=anc.avg_heat_flow=create(1,dim(data[1][1])[1],NSOUT,start=0,step=0,format=dtype)
  
		#create yet another output data array (layer X latitudes X seasons)
			layer.tmin=layer.tmax=create(NumLayers-1,dim(data[1][1])[1],NSOUT,start=0,step=0,format=dtype)
		} else {
			tmp.tsurf=create(length(data),dim(data[1][1])[1],NSOUT,start=0,step=0,format=dtype)
		}

		#the data actually starts at NDX+1
		start=NDX+1
	  
    #extract the specific data for each parameter
    for (i=1;i<=length(data);i+=1) {
      for(j=1;j<=dim(data[1][1])[1];j+=1) {

        tmp.tsurf[i,j]=translate(data[i][1][j,start:,k],y,z)
				if(one==0) {
	        tmp.tbol[i,j]=translate(data[i][2][j,start:,k],y,z)
	        tmp.tatm[i,j]=translate(data[i][3][j,start:,k],y,z)
	        tmp.down_vis[i,j]=translate(data[i][4][j,start:,k],y,z)
	        tmp.down_ir[i,j]=translate(data[i][5][j,start:,k],y,z)
						
					#extract the 6 and 7 items.
					#these are packed with various things...which is why there is so much code
					if(i==1) {
						anc.converge_days[,j]=translate(data[i][6][j,start:,k],y,z)
						anc.frost[,j]=translate(data[i][7][j,start:,k],y,z)
					} else if(i==2) {
						anc.delta_t_rms[,j]=translate(data[i][6][j,start:,k],y,z)	
						anc.frost_alb[,j]=translate(data[i][7][j,start:,k],y,z)	
					} else if(i==3) {
						anc.tatm_predict[,j]=translate(data[i][6][j,start:,k],y,z)
						anc.avg_heat_flow[,j]=translate(data[i][7][j,start:,k],y,z)		
					} else {
						if(i-3<NumLayers) {
							layer.tmin[i-3,j]=translate(data[i][6][j,start:,k],y,z)
							layer.tmax[i-3,j]=translate(data[i][7][j,start:,k],y,z)
						}
					}
				}
      }
    }

		#set the time output structure
	  tmp.time=time
	
		if(TUN8!=0) {
			#8 6 character header bytes that define the file size
			dir=dirname($1)
			header=unpack("a6*8",dir+"/fort.77",count=1)
			cols=atoi(header.c1_1)-3
			times=atoi(header.c1_2)
			seasons=atoi(header.c1_4)
	
			if(TUN8==101) {
				#13 characters that define x, y, z
				#N-cols 8 characters that are all of the layers or atmospheric parameters
				TUN8_out=unpack(sprintf("a13a8*%i",cols),dir+"/fort.77",skip=48)

				#make an output-layer array
				col_array=create(cols,length(TUN8_out[2]),1,start=0,step=0,format=float)

				#turn it into a float
				for(i=2;i<=cols+1;i+=1) {
					col_array[i-1]=atof(TUN8_out[i])
				}

				#resize it so that its an xyz array and the right orientation.
				resize(col_array,cols,times,seasons)
				col_array=translate(col_array,y,x)

				#this is the case for temperature with depth
				tmp.tsurf=cat(tmp.tsurf,double(col_array),axis=y)
				tmp.depth=translate(cat(layer.top[1,2],layer.center[1:,2],axis=x),x,y)
			
			#atmospheric parameter atmospheric parameters
			} else if (TUN8==102) {
				#14 characters that define x, y, z
				#N-cols 8 characters that are all of the layers or atmospheric parameters
				TUN8_out=unpack(sprintf("a14a8*%i",cols),dir+"/fort.77",skip=48)

				#make an output-layer array
				col_array=create(cols,length(TUN8_out[2]),1,start=0,step=0,format=float)

				#turn it into a float
				for(i=2;i<=cols+1;i+=1) {
					col_array[i-1]=atof(TUN8_out[i])
				}

				#resize it so that its an xyz array and the right orientation.
				resize(col_array,cols,times,seasons)
				col_array=translate(col_array,y,x)

				atmparams={}
				atmparams.col_insol=col_array[,1]
				atmparams.diffuse_flux=col_array[,2]
				atmparams.atm_kinetic_T=col_array[,3]
				atmparams.apparent_zenith_sky_T=col_array[,4]				
				atmparams.hemispheric_sky_T=col_array[,5]

				anc.atm_extras=atmparams
	
			} else {
				printf("Invalid TUN8 type: 101 or 102 are permitted\n")
			}	
		}

    #Generate the output structure
    tmp.ls=datals
		if(one==0) {
			#add the elevations and latitutdes to the output structure
			tmp.lat=translate(anc.krccom.lats[:dim(data[1][1])[1]],x,y)
			tmp.elev=translate(anc.krccom.elevs[:dim(data[1][1])[1]],x,y)
			remove_struct(anc.krccom,"lats")
			remove_struct(anc.krccom,"elevs")

			tmp.layer=layer
			tmp.anc=anc
		}
	
    #resample all the elements to the  specified hour
    if(hour!=-32768) {
			if(one==0) {
				hourresamp=cat("tmp.down_ir","tmp.down_vis","tmp.tatm","tmp.tbol","tmp.tsurf","tmp.time",axis=y)
			} else {
				hourresamp=text(1)
				hourresamp[,1]="tmp.tsurf"
			}
			
			for(i=1;i<=length(hourresamp);i+=1) {
				#extract the data into a temporary array
				command=sprintf("resamptemp=%s\n",hourresamp[,i])
				eval(command)
				
				#get the data dimension
				resampdim=dim(resamptemp)[1]

				#buffer the various arrays appropriately...note tmp.time must be handeled differently
				timetemp=format(cat(time[resampdim]-24.,time,axis=x),format=dtype)

				if(hourresamp[,i]=="tmp.time") {
					resamptemp=timetemp
				} else {
					resamptemp=cat(resamptemp[resampdim],resamptemp,axis=x)
				}

				command=sprintf("%s=format(translate(resample(translate(resamptemp,x,z),translate(timetemp,x,z),clone(hour,z=2)).data[,,1],z,x),format=dtype)",hourresamp[,i])
				eval(command)
			}
    }
    
    #resample all the elements to the specified ls
    if(ls!=-32768) {
			if(one==0) {
				lsresamp=cat("tmp.down_ir","tmp.down_vis","tmp.tatm","tmp.tbol","tmp.tsurf","tmp.ls","tmp.layer.tmin","tmp.layer.tmax",axis=y)
				lsresamp=cat(lsresamp,"tmp.anc."+get_struct_key(tmp.anc)[,2:],axis=y)
			} else {
				lsresamp=text(1)
				lsresamp[,1]="tmp.tsurf"
			}

			for(i=1;i<=length(lsresamp);i+=1) {

				#extract the data into a temporary array
				command=sprintf("resamptemp=%s\n",lsresamp[,i])
				eval(command)
				
				#get the data dimension
				resampdim=dim(resamptemp)[3]

				#buffer the various arrays appropriately...note tmp.ls must be handeled differently
				datalstemp=format(cat(datals[,,resampdim]-360,datals,datals[,,1]+360,axis=z),format=dtype)

				if(lsresamp[,i]=="tmp.ls") {
					resamptemp=datalstemp
				} else {
					resamptemp=cat(resamptemp[,,resampdim],resamptemp,resamptemp[,,1],axis=z)
				}
						
				#execute the resample command with the buffered data so that we can interpolate from 0 to 360 without extrapolation
				command=sprintf("%s=format(resample(resamptemp,datalstemp,clone(ls,z=2)).data[,,1],format=dtype)",lsresamp[,i])
				eval(command)
			}
    }

    if(dim(data[1][1])[3] == 1) {
      out=tmp
    } else {
      add_struct(obj=out,val=tmp,name="case"+k)
    }
  }

  if(raw!=0) {
    out.raw=data
  }

	out.version=sprintf("v%i.%i.%i",Mversion,mversion,rversion)

	printf("\n")
  return(out)
}



define krc_process_input(usage,updatekrcfunc) {
  
  if($ARGC==0) {
    printf("Parse and return the input structure from a krc input file\n")
    printf("$1=path to the input file (generally master.inp)\n\n")
    printf("c.edwards\n\n")
    return(null)
  }

  if(HasValue(usage)==0) usage=0

  #This is the input file handling code. 
  #This assumes the user just provided the base krc directory
  #in the folowing section we will parse out the master.inp file
  #and generate a list of key/value pairs for which we can add
  #a bunch of change cards.
  master=read_lines($1)
  
  inp={}
  #first 2 lines of the input file
  start1=maxpos(master==grep(master,"ALBEDO")[,1])[2]
  
  #hard to tell if this header will always be the same
  inp.header=master[,:start1-1]
  
  #floating point variables (#1 in change cards) from the input file
  end1=maxpos(master==grep(master,"N1")[,1])[2]-1
  inp.part1=master[,start1:end1]
  
  key={}
  if(usage==1){
    printf("\nReal Value Parameters (Values from default input file)\n")
    printf("####################################################################################\n")
  }
  key.part1=krc_get_key_value(inp.part1, print=usage)
  
  #integer variables (#2 in change cards) from the input file
  start2=end1+1
  end2=maxpos(master==grep(master,"LP1")[,1])[2]-1
  inp.part2=master[,start2:end2]
  
  if(usage==1){
    printf("Integer Value Parameters (Values from default input file)\n")
    printf("####################################################################################\n")
  } 
  key.part2=krc_get_key_value(inp.part2, print=usage)
  
  #boolean variables (#3 in change cards) from the input file
  start3=end2+1
  end3=maxpos(master==grep(master,"Latitudes")[,1])[2]-1
  inp.part3=master[,start3:end3]
  
  if(usage==1){
    printf("Boolean Parameters (Values from default input file)\n")
    printf("####################################################################################\n")
  }
  key.part3=krc_get_key_value(inp.part3, print=usage)

  #latitudes from the input file (with dummy values)
  start4=end3+1
  end4=maxpos(master==grep(master,"Elevations")[,1])[2]-1
  inp.part4=cat(master[,start4],sprintf("%7.2f",-32768),axis=y)

  #elevation section of the input file (with dummy values)
  start5=end4+1
  end5=maxpos(master==grep(master,"=RUNTIME")[,1])[2]-1
  inp.part5=cat(master[,start5],sprintf("%7.2f",-32768),axis=y)
  
  #crazy orbital parameters from the input file
  start6=end5+1
  end6=start6+6
  inp.part6=master[,start6:end6]

  out={}
  out.inp=inp
  out.key=key
	
	if(HasValue(updatekrcfunc)==1) {
		keys=cat(key.part1.key,key.part2.key,key.part3.key,axis=y)

		#change this line for updating krc parameter keys
		lib_version=read_lines($DV_KRC_HOME+"/../dvrc/krc2.dvrc")

		tmp=grep(lib_version,"define krc\\(")
		tmp=strsub(tmp,"define krc\\(","")
		tmp=strsub(tmp,"\\) ","")
		tmp=tmp[:length(tmp[,1])-1,1]
		tmp=strsplit(tmp,delim=",")
		albpos=maxpos(tmp=="ALBEDO")[2]
		pastkeys=tmp[,albpos:]

		pastkeys=sort(pastkeys)
		korder=keys
		keys=sort(keys)
		
		pastkeystruc={}
		keystruc={}
	
		for(i=1;i<=length(pastkeys);i+=1) {
			add_struct(pastkeystruc,name=pastkeys[,i],val=0)
		}

		for(i=1;i<=length(keys);i+=1) {
			add_struct(keystruc,name=keys[,i],val=0)
		}

		for(i=1;i<=length(pastkeys);i+=1) {
			for(j=1;j<=length(keys);j+=1) {
				if(pastkeys[,i]==keys[,j]) {
					remove_struct(pastkeystruc,pastkeys[,i])
				}
			}
		}

		for(i=1;i<=length(keys);i+=1) {
			for(j=1;j<=length(pastkeys);j+=1) {
				if(keys[,i]==pastkeys[,j]) {
					remove_struct(keystruc,keys[,i])
				}
			}
		}

		printf("\nKRC Input File Report:\n")
		printf("Current Keys\n")
		if(length(keystruc)!=0) {
			tkeys=get_struct_key(keystruc)
			for(i=1;i<=length(keystruc);i+=1) {
				printf("ERROR:%s\n",tkeys[,i])
			}
		} else {
			printf("FOUND NO MISSING/ADDED KEYS\n")
		}

		printf("\nExisting Keys\n")
		if(length(pastkeystruc)!=0) {
			tkeys=get_struct_key(pastkeystruc)
			for(i=1;i<=length(pastkeystruc);i+=1) {
				printf("ERROR:%s\n",tkeys[,i])
			}
		} else {
			printf("FOUND NO MISSING/ADDED KEYS\n")
		}

		printf("\n\n")

		out=""
		for(i=1;i<=length(korder);i+=1) {
			if(i==1) {
				out=sprintf("%s",korder[,i])
			} else {
				out=cat(out,sprintf(",%s",korder[,i]),axis=x)
			}
		}
	}
		
  return(out)
}



define krc_get_key_value(print) {

  if($ARGC==0) {
    printf("\n\nGet a set of keyword and value pairs from the KRC input file\n")
    printf("$1=column spaced text array\n")
    printf("print = print the results cleanly\n")
    printf("c.edwards\n\n")
    reutrn(null)
  }

  if(HasValue(print)==0) {
    print=0
  }

  #take the input of a column spaced text array
  master=$1
  part_key=text(0)
  part_val=text(0)

  #split the string by a space
  master=strsplit(master,delim=" ")

  #parse the giant strsplit struct/text array to extract the keywords
  for(i=1;i<=length(master);i+=2) {
    for(j=1;j<=length(master[i]);j+=1) {
      if(master[i][,j]!="") {
        if(master[i][1,j]=="[") {
          master[i][,j]=master[i][2:,j]
        }
        part_key=cat(part_key,master[i][,j],axis=y)
      }
    } 

    #search the keywords for their respective value pairs
    for(j=1;j<=length(master[i+1]);j+=1) {
      if(master[i+1][,j]!="") {
        part_val=cat(part_val,master[i+1][,j],axis=y)
      }
    }
  }

  #print the keyword data for krc() help
  if(print==1) {
    for(i=1;i<=length(part_key);i+=1) {
     #printf("%s,",part_key[,i])
     printf("%-9s%-13s",part_key[,i],"= "+part_val[,i])
     #printf("%-9s",part_key[,i])
     if(i%4==0 && i!=length(part_key)) {
       printf("\n")
     }
    }
  printf("\n\n")
  }
  return({key=part_key,value=part_val})
}



define krc_evalN1(){

  if($ARGC == 0){
    printf (" Calculates the minimum number of layers required given the number of years the model runs \n")
    printf (" Calculates the content of ZoneX.tab \n")
    printf (" Return an Array \n")
    printf (" $1  = RLAY, Layer thickness ratio \n")
    printf (" $2  = FLAY, First layer thickness (in skin depths) \n")
    printf (" $3  = INERTIA, Surface material thermal inertia \n")                        #Top Inertia Value
    printf (" $4  = SPEC_HEAT, Surface material specific heat \n")
    printf (" $5  = DENSITY, surface material density \n")
    printf (" $6  = DELJUL, delta julian date to increment by (Default = 1.9083 \n")
    printf (" $7  = N5, number of \"seasons\" to run (Default = 1080) \n")
    printf (" $8  = JDISK, start \"season\" to output (Default = 721) \n")
    printf (" $9  = MAXN1, Maximum number of layers KRC can accept \n")
    printf (" $10 = PERIOD, Length of solar day in days (of 86400 seconds) \n")
    printf (" $11 = INERTIA2, bottom material thermal inertia \n")                        #Depth Inertia Value
    printf (" $12 = SpHeat2, bottom material specific heat \n")
    printf (" $13 = DENS2, bottom material density \n")
    printf (" $14 = THICK, Top Material Thickness in m or H parameter if < 0 \n")         #if THICK > 0. => 2 material regolith, THICK is the top material thickness
                                                                                          #if THICK < 0. => Exponential trend, THICK is the H parameter (see Hayne)
                                                                                          #if THICK = 0. => Homogeneous material
    printf (" $15 = LKofT, temperature-dependence \n")
    printf ("s.piqueux 5/4/17\n\n")
    return(null)
  }

  RLAY          = float($1)
  FLAY          = float($2)
  INERTIA       = float($3)
  SPEC_HEAT     = Cp1        = float($4)
  DENSITY       = DENS1      = float($5)
  DELJUL        = float($6)
  N5            = int($7)
  JDISK         = int($8)
  MAXN1         = N1         = int($9)
  PERIOD        = float($10)
  INERTIA2      = float($11)
  SPEC_HEAT2    = Cp2        = float($12)
  DENSITY2      = DENS2      = float($13)
  THICK         = float($14)
  LKofT         = $15
  Min_Num_Layer = 25
  Res           = 10

if(sum(dim(THICK))==3){                                                                   #Not a Table provided
    ###Calculate Default Mesh Properties
        if(THICK==0){
          INERTIA2   = INERTIA
          SPEC_HEAT2 = SPEC_HEAT
          DENSITY2   = DENSITY
        }

    #Number of Seconds in 1 Year  
    PY = 3600*24*DELJUL*((N5-JDISK)+1)
    #Length of the solar day in seconds
    PD = PERIOD*86400
     
    #Seasonal Skin Depth in meters
    SSD1_m    = (INERTIA /(DENSITY *SPEC_HEAT ))*sqrt(PY/3.14159)
    SSD2_m    = (INERTIA2/(DENSITY2*SPEC_HEAT2))*sqrt(PY/3.14159)
    SSD_max_m = max(cat(SSD1_m,SSD2_m,axis=x))
     
    #Diurnal Skin Depth in meters
    DSD1_m = (INERTIA /(DENSITY *SPEC_HEAT ))*sqrt(PD/3.14159)
    DSD2_m = (INERTIA2/(DENSITY2*SPEC_HEAT2))*sqrt(PD/3.14159)
              
    #Calculate the number of years the model runs
    NSKIN = N5/(N5-JDISK+1)
 
    #We want as many seasonal skin depths of soil as there are years
    #Calculate The total Depth required, assuming 1 material, homogeneous, driven by highest INERTIA
    DEPTH_m = NSKIN * max(cat(SSD1_m,SSD2_m,axis=x))
    if(DEPTH_m > 25.){                                                                    #Force N1 to be smaller than 25. meters to avoid very deep models
        DEPTH_m  = 25.
    }

    if(THICK == 0.){                                                                      ###CASE 1: NO LAYEREING
      LZONE      = "F"
      FLAY2      = FLAY
      IC2        = 999.
    }

    if(THICK > 0.){                                                                       ###CASE 2: LAYERING
      LZONE      = "F"   
    }

    if((THICK <= (FLAY * DSD1_m * RLAY))&&(THICK > 0.)){                                  ###CASE 2a: top mesh element is smaller than default low TI element thickness
      FLAY2      = THICK/(DSD1_m*RLAY)                                            
      IC2        = 3
      LZONE      = "F"   
    }

    if((THICK > (FLAY * DSD1_m * RLAY))&&(RLAY > 1.)){                                    ###CASE 2b: top material thickness is larger than FLAY * DSD1 * RLAY, calculate number of elements
      LZONE      = "F"   
      IC2        = int(logb(RLAY,1-THICK*(1-RLAY)/(DSD1_m*FLAY*RLAY))) + 4                #Not sure why + 4
      FLAY_Step  = (FLAY - FLAY*0.01)/(Res - 1)
      FLAY_Table = create(Res+1,1,1,start=FLAY*0.01,step=FLAY_Step,format=double)
      Mesh       = create(Res+1,IC2-2,1,start=0.,format=double,step=0.)                   #Double Check IC2-2 (was used to be n)
      Mesh[,1,1] = FLAY_Table
      Bot_Thick  = create(Res+1,1,1,start=0.,format=double,step=0.)                       #
        for(i=2;i<=dim(Mesh)[2];i+=1){
          Mesh[,i,1] = Mesh[,i-1,1]*RLAY                                                  #Mesh Element thickness in skin depth
        }
      Bot_Thick  = sum(Mesh,axis=y)*DSD1_m                                                #Bottom thickness in m
      FIT        = fit(x=Bot_Thick-THICK,y=FLAY_Table,type="linear",plot=0)
      FLAY2      = FIT[1]
    }

    if((THICK > (FLAY * DSD1_m * RLAY))&&(RLAY == 1.)){                                   ###CASE 2c: RLAY = 1, top material thickness is larger than than FLAY * DSD1 * RLAY
      IC2        = int(THICK/(FLAY*DSD1_m*RLAY)) + 3                                      #IC   number of top elements + 1 (because of virtual layer) + 1 (indicates beginning of bot material)
      FLAY2      = (THICK/DSD1_m)/(IC2 - 2)                                               #Double check using .prt file ####################################################################################
    }    

    if(HasValue(FLAY2) == 0){                                                             #Could Happen when THICK < 0.
      FLAY2 = FLAY
    }
    if(HasValue(IC2) == 0){                                                               #Could Happen when THICK < 0.
      IC2 = 999
    }  


#
#GENERATE PROPERTIES WITH DEPTH; REPLICATES .prt FILE
#  
LAYER                = create(1,1,N1,start=1,format=int)                                  #[1], layer number (1 is virtual)
THICKNESS_D_Scale    = create(1,1,N1,start=FLAY2/RLAY,format=double)                      #[1], mesh element thickness in diurnal skin depth  
CENTER_DEPTH_D_Scale = create(1,1,N1,start=-0.5 * THICKNESS_D_Scale ,format=double)       #[1], mesh element center depth, in diurnal skin depth
THICKNESS_m          = create(1,1,N1,start=THICKNESS_D_Scale * DSD1_m ,format=double)     #[m], mesh element thickness in meter
CENTER_DEPTH_m       = create(1,1,N1,start=CENTER_DEPTH_D_Scale * DSD1_m,format=double)   #[m], mesh element center depth, in m
Conductiv            = create(1,1,N1,start=INERTIA^2/(SPEC_HEAT*DENSITY),format=double)   #[W/m-K]
Density              = create(1,1,N1,start=DENSITY,format=double)                         #[kg/m^3]
Sp_Heat              = create(1,1,N1,start=SPEC_HEAT,format=double)                       #[J/kg]
Total_mass           = create(1,1,N1,start=0.,format=double)                              #[kg/m^2]
Z_T                  = create(1,1,N1,start=0.,format=double)                              #[m], depth where KRC reports the temperatures
Z_T_D                = create(1,1,N1,start=0.,format=double)                              #[1], depth where KRC reports the temperatures, in local DSD
SCALES               = create(1,1,N1,start=0.,format=double)                              #[m], Scales, i.e. diurnal skin depth
  for(i=2;i<=N1;i+=1){
    if(LAYER[1,1,i] < IC2){
      DSD  = DSD1_m
      DENS = DENSITY
      Cp   = SPEC_HEAT
      I    = INERTIA
    } else {
      DSD  = DSD2_m
      DENS = DENSITY2
      Cp   = SPEC_HEAT2
      I    = INERTIA2
    }                  
    LAYER[1,1,i]                = LAYER[1,1,i-1] + 1
    THICKNESS_D_Scale[1,1,i]    = THICKNESS_D_Scale[1,1,i-1]*RLAY
    CENTER_DEPTH_D_Scale[1,1,i] = CENTER_DEPTH_D_Scale[1,1,i-1] + 0.5 * (THICKNESS_D_Scale[1,1,i] + THICKNESS_D_Scale[1,1,i-1])
    THICKNESS_m[1,1,i]          = THICKNESS_D_Scale[1,1,i]*DSD
    CENTER_DEPTH_m[1,1,i]       = CENTER_DEPTH_m[1,1,i-1] + 0.5 * (THICKNESS_m[1,1,i] + THICKNESS_m[1,1,i-1])
    Conductiv[1,1,i]            = I^2/(DENS*Cp)
    Density[1,1,i]              = DENS           
    Sp_Heat[1,1,i]              = Cp              
    Total_mass[1,1,i]           = Total_mass[1,1,i-1] + Density[1,1,i] * THICKNESS_m[1,1,i]
    SCALES[1,1,i]               = DSD
    Z_T[1,1,i]                  = CENTER_DEPTH_m[1,1,i]                                   #1: Surface T; 2: middle of 2nd layer etc.
    Z_T_D[1,1,i]                = CENTER_DEPTH_D_Scale[1,1,i]                             #1: Surface T; 2: middle of 2nd layer etc.
    
      if(((CENTER_DEPTH_m[1,1,i-1]>DEPTH_m)&&(i>=Min_Num_Layer))||(i>=MAXN1)){
        N1                      = i
        LAYER                   = LAYER[1,1,:i]
        THICKNESS_D_Scale       = THICKNESS_D_Scale[1,1,:i]
        CENTER_DEPTH_D_Scale    = CENTER_DEPTH_D_Scale[1,1,:i]
        THICKNESS_m             = THICKNESS_m[1,1,:i]
        CENTER_DEPTH_m          = CENTER_DEPTH_m[1,1,:i]
        Conductiv               = Conductiv[1,1,:i]
        Density                 = Density[1,1,:i]
        Sp_Heat                 = Sp_Heat[1,1,:i]
        Total_mass              = Total_mass[1,1,:i]
        SCALES                  = SCALES[1,1,:i]
        Z_T                     = Z_T[1,1,:i]
        Z_T_D                   = Z_T_D[1,1,:i]
      }                                                                                   #Crop tables deeper than N1                  
  }                                                                                       #for loop building table

if(THICK < 0.){                                                                           #CASE 3: H parameter
  IC2                  = 999
  LZONE                = "T"
  FLAY2                = 1.05 #FLAY
  DSD                  = DSD1_m
  DENS                 = DENSITY
  Cp                   = SPEC_HEAT
  I                    = INERTIA
  LAYER                = create(1,1,N1,start=1,format=int)                                #[1], layer number (1 is virtual)
  THICKNESS_D_Scale    = create(1,1,N1,start=FLAY2/RLAY,format=double)                    #[1], mesh element thickness in diurnal skin depth  
  CENTER_DEPTH_D_Scale = create(1,1,N1,start=-0.5 * THICKNESS_D_Scale ,format=double)     #[1], mesh element center depth, in diurnal skin depth
  THICKNESS_m          = create(1,1,N1,start=THICKNESS_D_Scale * DSD1_m ,format=double)   #[m], mesh element thickness in meter
  CENTER_DEPTH_m       = create(1,1,N1,start=CENTER_DEPTH_D_Scale * DSD1_m,format=double) #[m], mesh element center depth, in m
  Conductiv            = create(1,1,N1,start=INERTIA^2/(SPEC_HEAT*DENSITY),format=double) #[W/m-K]
  Density              = create(1,1,N1,start=DENSITY,format=double)                       #[kg/m^3]
  Sp_Heat              = create(1,1,N1,start=SPEC_HEAT,format=double)                     #[J/kg]
  Total_mass           = create(1,1,N1,start=0.,format=double)                            #[kg/m^2]
  Z_T                  = create(1,1,N1,start=0.,format=double)                            #[m], depth where KRC reports the temperatures
  SCALES               = create(1,1,N1,start=0.,format=double)                            #[m], Scales, i.e. diurnal skin depth
  Z_T                  = create(1,1,N1,start=0.,format=double)                            #[m], depth where KRC reports the temperatures
  Z_T_D                = create(1,1,N1,start=0.,format=double)                            #[1], depth where KRC reports the temperatures, in local DSD

    for(i=2;i<=N1;i+=1){
      LAYER[1,1,i]                = LAYER[1,1,i-1] + 1
      THICKNESS_D_Scale[1,1,i]    = THICKNESS_D_Scale[1,1,i-1]*RLAY
      CENTER_DEPTH_D_Scale[1,1,i] = CENTER_DEPTH_D_Scale[1,1,i-1] + 0.5 * (THICKNESS_D_Scale[1,1,i] + THICKNESS_D_Scale[1,1,i-1])
      THICKNESS_m[1,1,i]          = THICKNESS_D_Scale[1,1,i]*DSD
      CENTER_DEPTH_m[1,1,i]       = CENTER_DEPTH_m[1,1,i-1] + 0.5 * (THICKNESS_m[1,1,i] + THICKNESS_m[1,1,i-1])
      Conductiv[1,1,i]            = I^2/(DENS*Cp)
      Density[1,1,i]              = DENS           
      Sp_Heat[1,1,i]              = Cp              
      Total_mass[1,1,i]           = Total_mass[1,1,i-1] + Density[1,1,i] * THICKNESS_m[1,1,i]
      SCALES[1,1,i]               = DSD
      Z_T[1,1,i]                  = CENTER_DEPTH_m[1,1,i]                                 #[m], depth where KRC reports the temperatures
      Z_T_D[1,1,i]                = CENTER_DEPTH_D_Scale[1,1,i]                           #1: Surface T; 2: middle of 2nd layer etc.
     
        if(((CENTER_DEPTH_m[1,1,i-1]>DEPTH_m)&&(i>=Min_Num_Layer))||(i>=MAXN1)){
          N1                      = i
          LAYER                   = LAYER[1,1,:i]
          THICKNESS_D_Scale       = THICKNESS_D_Scale[1,1,:i]
          CENTER_DEPTH_D_Scale    = CENTER_DEPTH_D_Scale[1,1,:i]
          THICKNESS_m             = THICKNESS_m[1,1,:i]
          CENTER_DEPTH_m          = CENTER_DEPTH_m[1,1,:i]
          Conductiv               = Conductiv[1,1,:i]
          Density                 = Density[1,1,:i]
          Sp_Heat                 = Sp_Heat[1,1,:i]
          Total_mass              = Total_mass[1,1,:i]
          SCALES                  = SCALES[1,1,:i]
          Z_T                     = Z_T[1,1,:i]
          Z_T_D                   = Z_T_D[1,1,:i]
        }                                                                                 #Crop tables deeper than N1                  
    }                                                                                     #for loop building table

  H                    = THICK
  COND1                = INERTIA^2/(DENSITY*SPEC_HEAT)
  COND2                = INERTIA2^2/(DENSITY2*SPEC_HEAT2)
  Col_1                = translate(THICKNESS_m,from=z,to=y)                               #Keep Default Meshing; thickness of each layer in m
  Col_2                = translate(DENS2 - (DENS2 - DENS1)*exp(Z_T/H),from=z,to=y)        #Density
  Col_3                = translate(COND2 - (COND2 - COND1)*exp(Z_T/H),from=z,to=y)        #Conductivity
  Col_4                = translate(Cp2 - (Cp2 - Cp1)*exp(Z_T/H),from=z,to=y)              #Specific Heat            
  col_dim              = dim(Col_1)[2]-1                                                  #when a table file is created (H parameter), there is no virtual layer necessary
  Col_1                = Col_1[,:col_dim]
  Col_2                = Col_2[,:col_dim]
  Col_3                = Col_3[,:col_dim]
  Col_4                = Col_4[,:col_dim]    
    if(LKofT == "T"){                                                                     #If Temperature-dependent properties, change top 2 zones
      Col_3[1,1,1]     = -1.                                                              #In this model, only the top 2 mesh elements are T_dep
      Col_3[1,2,1]     = -1.
      Col_4[1,1,1]     = 3.                                                              
      Col_4[1,2,1]     = 4.
    }
}                                                                                         #Zone file


#process the output structure if thick is not an array
out                            = {}
out.req                        = {}
out.layer                      = {}
out.req.FLAY                   = float(FLAY2)                                             #New FLAY
out.req.RLAY                   = float(RLAY)                                              #RLAY
out.req.N1                     = int(N1)                                                  #New N1
out.req.IC2                    = IC2
out.req.LZONE                  = LZONE
out.Depth                      = DEPTH_m                                                  #Regolith thickness required, in m
out.thick                      = THICK                                                    #Top material thickness, [m]
out.thermal_scales             = SCALES                                                   #Material diurnal skin depth (Scale)

out.layer.Num                  = LAYER                                                    #[1] Layer Number
out.layer.mass_burden          = Total_mass                                               #[kg/m^2], surface to bottom of the mesh element
out.layer.Cond                 = Conductiv                                                #[J/s/m/K], Mesh element conductivity
out.layer.Density              = Density                                                  #[kg/m^3], Mesh element density
out.layer.Cp                   = Sp_Heat                                                  #[J/kg/K], Mesh element specific heat

out.layer.m                    = {}                                                       #Mesh Properties, in meters
out.layer.Scale                = {}                                                       #Mesh Properties, in local skin depths

out.layer.m.thickness          = THICKNESS_m                                              #[m] Mesh element thickness 
out.layer.m.center_depth       = CENTER_DEPTH_m                                           #[m] Depth at the center of the mesh element
out.layer.m.depth              = Z_T                                                      #[m] Depth at the center of the mesh element EXCEPT 1st is surface (0m)

out.layer.Scale.thickness      = THICKNESS_D_Scale                                        #[1] Mesh element thickness, in local DSD
out.layer.Scale.center_depth   = CENTER_DEPTH_D_Scale                                     #[m] Depth at the center of the mesh element, in local DSD
out.layer.Scale.depth          = Z_T                                                      #[m] Depth at the center of the mesh element EXCEPT 1st is surface (0m)
out.layer.Scale.DSD1           = DSD1_m                                                   #Top material Diurnal Skin Depth, in m
out.layer.Scale.DSD2           = DSD2_m                                                   #Lower material Diurnal Skin Depth, in m
out.layer.Scale.SSD1           = SSD1_m                                                   #Top material Seasonal Skin Depth, in m
out.layer.Scale.SSD2           = SSD2_m                                                   #Lower material Seasonal Skin Depth, in m


if(THICK<0) {
  out.H          = -H                                                                     #Flags an exponential configuration
  out.Zone       = {}
  out.Zone.Col_1 = Col_1                                                                  #Mesh (or Zone) Element Thickness [m]
  out.Zone.Col_2 = Col_2                                                                  #Mesh (or Zone) Element Density [kg/m^3]
  out.Zone.Col_3 = Col_3                                                                  #Pointer for Column 4, or conducticity [j/kg/K/s]
  out.Zone.Col_4 = Col_4                                                                  #Thermal Conductivity and Specific heat from Materials 1    and 2
  out.Zone.inp   = text()
  out.Zone.inp   = cat(out.Zone.inp,"C_END",axis=y)
    for(i=1;i<=dim(Col_1)[2];i+=1) {
      out.Zone.inp = cat(out.Zone.inp,sprintf("%.4f %.1f %.4f %.1f",Col_1[,i],Col_2[,i],Col_3[,i],Col_4[,i]),axis=y)
    }
  out.Zone.inp   = cat(out.Zone.inp,"0 0 0 0",axis=y)
}
}
 
if(dim(THICK)[1]==4 && dim(THICK)[2]>=3 && dim(THICK)[3]==1) {                            #CASE 4: Table file provided
  out                            = {}
  out                            = {}
  out.req                        = {}
  out.layer                      = {}
  out.layer.m                    = {}
  out.layer.m.depth              = -999.                                                  #There is no way to predict the meshing from the zones; assign -999.
  out.req.FLAY                   = float(FLAY)                                            #New FLAY
  out.req.RLAY                   = float(RLAY)                                            #RLAY
  out.req.N1                     = 50                                                     #Very hard to predict how many layers are needed when zones are present; assigns 50
  out.req.IC2                    = 999
  out.req.LZONE                  = "T"
  out.input_array                = THICK
  out.Zone                       = {}
  out.Zone.inp                   = text()
  out.Zone.inp                   = cat(out.Zone.inp,"C_END",axis=y)
    for(i=1;i<=dim(THICK)[2];i+=1) {
      out.Zone.inp = cat(out.Zone.inp,sprintf("%.4f %.1f %.4f %.1f",THICK[1,i],THICK[2,i],THICK[3,i],THICK[4,i]),axis=y)
    }
  out.Zone.inp                   = cat(out.Zone.inp,"0 0 0 0",axis=y)   
}

return(out)
}

define krc_evalN2(){
  if($ARGC == 0){
    printf (" Calculates the minimum number of times per day to consider for N2 \n")
    printf (" Returns an integer\n\n")
    printf (" $1 = FLAY, First layer thickness (in skin depths) \n")
    printf (" $2 = INERTIA, Thermal inertia of the top material at 220K \n")
    printf (" $3 = DENSITY, Density of the top material \n")
    printf (" $4 = SPEC_HEAT, Specific heat of the top material \n")
    printf (" $5 = PERIOD, Length of solar day in days (of 86400 seconds) \n")
    printf (" $6 = N24, # 'hours' per day stored, should be divisir of  N2 (lim MAXNH) \n")
    printf (" $7 = MAXN2, maximum # of 'hours' per day \n")
    printf ("s.piqueux 8/9/13\n\n")
    return(null)
  }

  FLAY = float($1)
  INERTIA = float($2)
  DENSITY = float($3)
  SPEC_HEAT = float($4)
  PERIOD = float($5)
  N24 = float($6)
  MAXN2 = float($7)

  #Number of seconds in a Martian day
  PD = PERIOD*86400

  #Diurnal Skin Depth in meters
  DSD = (INERTIA/(DENSITY*SPEC_HEAT))*sqrt(PD/3.14159)

  #First Layer Thickness in meters
  FLAYM = FLAY*DSD

  #The minimum time step cannot be larger than DEL_T Kieffer 2013 Section 103
  ###DEL_T MAY NEED TO BE MORE CONSERVATIVE IF WE FIND THAT THE STABILITY IS NOT GARANTEED
  DEL_T = 0.8*(FLAYM^2*DENSITY^2*SPEC_HEAT^2)/(2*INERTIA^2)

  #Minimum number of time steps in a day
  Num_time_step = int(PD/DEL_T)+1
  
  #Minimum number of time step in a day, adjusted for N24
  if (N24 > Num_time_step) N2 = N24

  #Minimum number of time step in a day, adjusted for N24
  if (N24 <= Num_time_step) N2 = (int(Num_time_step/N24)+1)*N24

  #Makes sure that N2 is smaller than MAXN2
  if (N2 > MAXN2) N2 = MAXN2

  return(N2)
}



define stability_flag_krc(){
	if($ARGC == 0){
		printf (" Flags suspicious output surface temperatures \n")
		printf (" Returns an integer, 0 noting suspicious detected; 1 possible issue \n")
		printf (" $1 = davinci output file for a krc run \n")
		printf (" $2 : TFROST \n")
		printf ("s.piqueux 8/8/13\n\n")
		return(null)
	}
	
	Data = $1
	TFROST = $2
	
	FLAG = {}
	FLAG.TFROST = 0.
	FLAG.BUMP = 0.
	FLAG.BREAK= 0.
	FLAG.SLOPE= 0.
	
	T = Data.data.tsurf[1,1,]
	
	#FIRST FLAG: TEMPERATURES BELOW FROST POINT
	if(min(T) < TFROST) FLAG.TFROST = 1.
	
	#2ND FLAG: TEMPERATURE BUMPS NOT ASSOCIATED WITH TFROST
	for(i=2;i<=dim(T)[3]-2;i+=1){
		#+-+-
		if((T[1,1,i]>T[1,1,i-1])&&(T[1,1,i]>T[1,1,i+1])&&(T[1,1,i+1]<T[1,1,i+2])) FLAG.BUMP= 1.

		#-+-+
		if((FLAG.BUMP==0.)&&(T[1,1,i]<T[1,1,i-1])&&(T[1,1,i]<T[1,1,i+1])&&(T[1,1,i+1]>T[1,1,i+2])) FLAG.BUMP= 1.

		#Slope Breaks
		Slope_1 = T[1,1,i]-T[1,1,i-1]
		Slope_2 = T[1,1,i+1]-T[1,1,i]
		Slope_3 = T[1,1,i+2]-T[1,1,i+1]
		if((Slope_1>Slope_2)&&(Slope_2<Slope_3)) FLAG.SLOPE = 1.
		if((FLAG.SLOPE==0.)&&(Slope_1<Slope_2)&&(Slope_2>Slope_3)) FLAG.SLOPE = 1.
	}
	
	return(FLAG)
}



define porb(type,epoch,anc,v,force) {

	if(HasValue($1)) {
		if(type($1)=="STRING") {
			if($1=="updatedefaults") { 
				update="updatedefaults"
			} else {
				update="dontupdate"
			}
		} else {
			update="dontupdate"
		}
	}

	if($ARGC==0 || HasValue(type)==0) {
		printf("\nRun PORB to calculate an appropriate rotation matrix for use in krc\n")
		printf("\ntype=\"planet\"\n")
		printf("\t$1=body - planetary body\n")
		printf("\t$2=spin axis - moon or planetary body (Optional, Default = body)\n")
		printf("\tepoch=fraction of the century for start date (Default = 0.10 -> 2010)\n")
		printf("\ntype=\"minor\"\n")
		printf("\t$1=body name or id\n")
		printf("\ntype=\"comet\"\n")
		printf("\t$1=body name or id\n\n")
		printf("\ntype=\"generic\"\n")
		printf("\t$1=generic_porb generated structure\n\n")
		printf("force=force running of PORB (default=0)\n")
		printf("c.edwards 6/25/15\n")
		return(null)
	}

	if(HasValue(anc)==0) anc=0
	if(HasValue(v)==0) v=0
	if(HasValue(force)==0) force=0
	
	if(update!="updatedefaults") {
		#setup the output
		out={}
		out.krc={}

		#if we are dealing with a planet or a moon
		if(type=="planet") {
			body=$1
	
			#if its a moon then $2 is set, otherwise set it to the main body
			if($ARGC==2) {
				spin=$2
				rec=0
			} else {
				spin=body
				rec=1
			}
			
			#check to see if we've already run this in a standard case
			testfile=$DV_SCRIPT_FILES+"/krc_support/porb_defaults/"+body+"_"+spin+".porb.hdf"
			if(fexists(testfile) && force!=1) {
				printf("Found Default File: $DV_SCRIPT_FILES/krc_support/porb_defaults/%s\n",basename(testfile))
				return(read(testfile))
			}

			if(force==1) {
				printf("Forcing PORB run\n")
			}

			#set the epoch to deal with in fractions of a century
			if(HasValue(epoch)==0) {
				epoch=0.10
			}
		
			#setup the working directory
			workdir=$TMPDIR+"/porb"
			syscall("mkdir -p "+workdir)
		
			#hugh supplies thes files tailored to KRC input...maybe we should re-do them
			standish=read_lines($DV_KRC_HOME+"/run/standish.tab")
			spinaxis=read_lines($DV_KRC_HOME+"/run/spinaxis.tab")
			otherparams=load_csv($DV_SCRIPT_FILES+"/krc_support/planetary_params3.csv",header=1,sep=',')

			#look for the comment line
			standish_END=maxpos(standish[:length("C_END")]=="C_END")[2]
	
			#find the appropriate body lines
			if(sum(standish[:length(body),standish_END:]==body)!=1) {
				printf("Error: Did not find %s in the available planets\n",body)
				return(null)
			} else {
				bodypos=maxpos(standish[:length(body),standish_END:]==body)[2]+standish_END-1
				bodylines=cat("C_END",standish[,bodypos:bodypos+1],axis=y)
			}
		
			#look for the comment line
			spin_END=maxpos(spinaxis[:length("C_END")]=="C_END")[2]
	
			#find the appropriate spin axis lines
			if(sum(spinaxis[:length(spin),spin_END:]==spin)!=1) {
				printf("Error: Did not find %s in the spin axis file\n",spin)
				return(null)
			} else {
				spinpos=maxpos(spinaxis[:length(spin),spin_END:]==spin)[2]+spin_END-1
				spinlines=cat("C_END",spinaxis[,spinpos],axis=y)
			}

			#get some other planetary parameters
			parampos=maxpos(otherparams.name==spin)[2]
			rot_per=otherparams.orbit_period[,parampos]
			period=otherparams.sideral_period[,parampos]*365.25636
			out.krc.GRAV=otherparams.gravity[,parampos]

			#set the amospheric conditions
			out.krc.PTOTAL=otherparams.ptotal[,parampos]
			out.krc.ARC2_G0=otherparams.arc2_pho[,parampos]
			out.krc.DUSTA=otherparams.dusta[,parampos]
			out.krc.TAURAT=otherparams.taurat[,parampos]

			#set the standard planetary flux values
			out.planet_flux={}
			out.planet_flux.BT_Min=otherparams.bt_min[,parampos]
			out.planet_flux.BT_Max=otherparams.bt_max[,parampos]
			out.planet_flux.BT_Avg=otherparams.bt_avg[,parampos]
			out.planet_flux.Radius=otherparams.radius[,parampos]
			out.planet_flux.Geom_alb=otherparams.geom_alb[,parampos]
			out.planet_flux.Dis_AU=otherparams.dis_au[,parampos]
			out.planet_flux.Orb_Radius=otherparams.orb_radius[,parampos]
			out.planet_flux.Mut_Period=otherparams.mut_period[,parampos]

			#write out the temporary files
			name=body+"_"+spin
			write(bodylines,workdir+"/standish.tab",ascii,force=1)
			write(spinlines,workdir+"/spinaxis.tab",ascii,force=1)
			operations=cat("T","1","1","1",""+epoch,"0",spin,"2","2","2",name+".mat","0",axis=y)
			write(operations,workdir+"/porb_"+name+".run",ascii,force=1)
			out.body=spin		

		if(anc==1) {
			input={}
			input.bodylines=read_lines(workdir+"/standish.tab")
			input.spinlines=read_lines(workdir+"/spinaxis.tab")
		}

		} else if(type=="minor") {
	
			body=$1
	
			#do this so we can run faster..using pre definied values
			testfile=$DV_SCRIPT_FILES+"/krc_support/porb_defaults/"+body+".porb.hdf"
			if(fexists(testfile) && force!=1) {
				printf("Found Default File: %s\n",testfile)
				return(read(testfile))
			}
			if(force==1) {
				printf("Forcing PORB run\n")
			}

			#read in the reference structure
			verbose=0
			ref=read($DV_SCRIPT_FILES+"/krc_support/small_bodies.hdf")
			verbose=3	
	
			#setup a working directory
			workdir=$TMPDIR+"/porb"
			syscall("mkdir -p "+workdir)
	
			if(type(body)=="STRING") {
        names=""
        names=grep(ref.name,body)
        if(names=="") {
          printf("Could not find body: %s in named asteroids\n",body)
          return(-1)
        } else if(length(names)>1) {
          printf("\nFound more than one body matching the	name\n")
  	  	  printf("Select a body	from the list below\n")
          for(i=1;i<=length(names);i+=1) {
            printf("\t%s\n",names[,i])
    	  	}
	    	  return(-1)
				}

	      pos=maxpos(ref.name==names[,1])[2]

			} else if(type(body)=="int") {
				pos=0	
				pos=maxpos(ref.id==body)[2]
				if(pos==0) {
					printf("Could not find body: %i in named asteroids\n",body)
					return(-1)
				}
			}
	
			#assemble the minor bodies input file
			lines=text(14)
			lines[,1]="C_END"
			lines[,2]="--------  1"
			if(type(body)=="int") {
				lines[,3]=ref.id[,pos]+" / body name"
			} else {
				lines[,3]=ref.name[,pos]+" / body name"
			}
			lines[,4]=ref.jd[,pos]+" / epoch in JD"
			lines[,5]=ref.a[,pos]+" / a - semi-major axis in AU"
			lines[,6]=ref.e[,pos]+" / e - eccentricity"
			lines[,7]=ref.i[,pos]+" / i - inclination of orbit"
			lines[,8]=ref.node[,pos]+" / omega - longitude of ascending node"
			lines[,9]=ref.peri[,pos]+" / peri - augment of perihelion"
			lines[,10]=ref.m[,pos]+" / m - mean anomoly at epoch"
			lines[,11]=ref.polera[,pos]+" / PoleRA - polar right ascension"
			lines[,12]=ref.poledec[,pos]+" / PoleDec - polar declination"
			lines[,13]=ref.merid[,pos]+" / merid - meridian"
			lines[,14]=ref.rot_per[,pos]+" / rot_per - sideral rotation period"
			name=body
			
			#write out the temoporary files
			write(lines,workdir+"/minor.tab",ascii,force=1)
			operations=cat("T","1","3","1","0","2","2","2",name+".mat","0",axis=y)
			write(operations,workdir+"/porb_"+name+".run",ascii,force=1)
	
			#extract the period and rotation period for calclating various parameters for krc()
			rot_per=ref.rot_per[,pos]
			period=ref.period[,pos]

			out.body=body
			#turn off the atmosphere because they're airless
			out.krc.PTOTAL=0.1
		
			#turn off frost (for now)
			out.krc.TFROST=0.0	

			#set TAUD=0
			out.krc.TAUD=0.0

			if(anc==1) {
				input=lines
			}

		} else if(type=="generic") {
	
			ref=$1

			#setup a working directory
			workdir=$TMPDIR+"/porb"
			syscall("mkdir -p "+workdir)
		
			#assemble the minor bodies input file
			lines=text(14)
			lines[,1]="C_END"
			lines[,2]="--------  1"
			lines[,3]=ref.name[,pos]+" / body name"
			lines[,4]=ref.epoch[,pos]+" / epoch in JD"
			lines[,5]=ref.a[,pos]+" / a - semi-major axis in AU"
			lines[,6]=ref.e[,pos]+" / e - eccentricity"
			lines[,7]=ref.i[,pos]+" / i - inclination of orbit"
			lines[,8]=ref.node[,pos]+" / omega - longitude of ascending node"
			lines[,9]=ref.peri[,pos]+" / peri - augment of perihelion"
			lines[,10]=ref.m[,pos]+" / m - mean anomoly at epoch"
			lines[,11]=ref.polera[,pos]+" / PoleRA - polar right ascension"
			lines[,12]=ref.poledec[,pos]+" / PoleDec - polar declination"
			lines[,13]=ref.merid[,pos]+" / merid - meridian"
			lines[,14]=ref.rot_per[,pos]+" / rot_per - sideral rotation period"
			name=ref.name
			
			#write out the temoporary files
			write(lines,workdir+"/minor.tab",ascii,force=1)
			operations=cat("T","1","3","1","0","2","2","2",name+".mat","0",axis=y)
			write(operations,workdir+"/porb_"+name+".run",ascii,force=1)
	
			#extract the period and rotation period for calclating various parameters for krc()
			rot_per=ref.rot_per[,pos]
			period=ref.period[,pos]

			out.body=name
			#turn off the atmosphere because they're airless
			out.krc.PTOTAL=0.1
		
			#turn off frost (for now)
			out.krc.TFROST=0.0	

			#set TAUD=0
			out.krc.TAUD=0.0

			if(anc==1) {
				input=lines
			}

		} else if (type=="comet") {
	
			body=$1
	
			#do this so we can run faster..using pre definied values
			testfile=$DV_SCRIPT_FILES+"/krc_support/porb_defaults/"+body+".porb.hdf"
			if(fexists(testfile) && force!=1) {
				printf("Found Default File: %s\n",testfile)
				return(read(testfile))
			}
			if(force==1) {
				printf("Forcing PORB run\n")
			}

			#read in the reference structure
			verbose=0
			ref=read($DV_SCRIPT_FILES+"/krc_support/comets.hdf")
			verbose=3	
	
			#setup a working directory
			workdir=$TMPDIR+"/porb"
			syscall("mkdir -p "+workdir)
	
			if(type(body)=="STRING") {
				names=""
				names=grep(ref.name,body)
				if(names=="") {
					printf("Could not find body: %s in named comets\n",body)
					return(-1)
				} else if(length(names)>1) {
					printf("\nFound more than one body matching the name\n")
					printf("Select a body from the list below\n")
					for(i=1;i<=length(names);i+=1) {
						printf("\t%s\n",names[,i])
					}
					return(-1)
				}

				pos=maxpos(ref.name==names[,1])[2]

			} else if(type(body)=="int") {
				pos=0
				pos=maxpos(ref.id==body)[2]
				if(pos==0) {
					printf("Could not find body: %i in named comets\n",body)
					return(-1)
				}
			}
	
			#assemble the comets input file
			lines=text(11)
			lines[,1]="C_END"
			lines[,2]=""
			if(type(body)=="int") {
				lines[,3]=ref.id[,pos]+" / body name"
			} else {
				lines[,3]=ref.name[,pos]+" / body name"
			}
			lines[,4]=ref.year[,pos]+" "+ref.month[,pos]+" "+ref.day[,pos]+" / tper - time of perihelion"
			lines[,5]=ref.peri[,pos]+" / peri - augment of perihelion"
			lines[,6]=ref.node[,pos]+" / omega - longitude of ascending node"
			lines[,7]=ref.i[,pos]+" / i - inclination of orbit"
			lines[,8]=ref.q[,pos]+" / q - perihelion distance"
			lines[,9]=ref.e[,pos]+" / e - eccentricity"
			lines[,10]=ref.polera[,pos]+" "+ ref.poledec[,pos]+" / PoleRA/DEC - polar right ascension/declination"
			if(ref.rot_per[,pos]==0) {
				ref.rot_per[,pos] =24.
			}
			lines[,11]=ref.rot_per[,pos]+" / rot_per - sideral rotation period"
			name=body
			
			#write out the temoporary files
			write(lines,workdir+"/comet.tab",ascii,force=1)
			operations=cat("T","1","5","1","0","2","2","2",name+".mat","0",axis=y)
			write(operations,workdir+"/porb_"+name+".run",ascii,force=1)
	
			#extract the period and rotation period for calclating various parameters for krc()
			rot_per=ref.rot_per[,pos]
			period=ref.period[,pos]

			out.body=body
			#turn off the atmosphere because they're airless
			out.krc.PTOTAL=0.1
		
			#turn off frost (for now)
			out.krc.TFROST=0.0	

			#set TAUD=0
			out.krc.TAUD=0.0
		
      if(anc==1) {
        input=lines
      } 

		} else {
			printf("Please enter a supported type\n")
			printf("planet, minor, comet\n\n")
			return(-1)
		}
	
		#run porb
		if(v>=1) {
	 		system("cd "+workdir+"; "+$DV_KRC_HOME+"/src/porbmn < "+workdir+"/porb_"+name+".run | tee -a "+workdir+"/krc.log")
			log=read_lines(workdir+"/krc.log")
		} else {
			log=syscall("cd "+workdir+"; "+$DV_KRC_HOME+"/src/porbmn < "+workdir+"/porb_"+name+".run")
	  }
	
		#read in the porb ouput
		rot=read_lines(workdir+"/"+name+".mat")
	
		#fill out the output structure
		out.rot=rot
		out.rot_per=rot_per
		out.period=period
		
		#we do this for every 15 earth minutes or a minimum 96 times a day 
		out.krc.N24=int(floor((rot_per*4)/96)*96)
		if(out.krc.N24<96) out.krc.N24=96
		
		#ratio of body day to earth day
		out.krc.PERIOD=rot_per/24.
		
		#deljul is in days/degree of Ls (ish)
		out.krc.DELJUL=period/360.

		#return the log if requested
		if(anc==1) {
			out.log=log
			out.input=input
		}
			
		#clean up
		syscall("rm -r "+workdir+"/*")
		return(out)
	} else {
		
		#this is the case to make the defaults files
		outdir=$PWD+"/porb_defaults"
		syscall("mkdir "+outdir)

		#choose our defaults from each list
		planet_list=cat("Mercury_Mercury","Venus_Venus","Earth_Earth","Mars_Mars","Jupiter_Jupiter","Saturn_Saturn","Uranus_Uranus","Neptune_Neptune","Pluto_Pluto","Mars_Phobos","Mars_Deimos","Jupiter_Europa","Jupiter_Ganymede","Jupiter_Io","Jupiter_Callisto",axis=y)
		minor_list=cat("Bennu","Ceres","Vesta","Pallas","Juno","Itokawa","Annefrank","Lutetia","Steins","Braille","Mathilde","Gaspra",axis=y)
		comet_list=cat("Halley","Tempel_1","Tempel_2","Wild_2","22P-Kopff","Giacobini-Zinner","19P-Borrelly","103P-Hartley","Churyumov-Gerasimenko",axis=y)	

		#run the planet/moon cases
		for(i=1;i<=length(planet_list);i+=1) {
			item=strsplit(planet_list[,i],delim="_")
			printf("Running Planet: %s - %s\n",item[,1],item[,2])
			out=porb(item[,1],item[,2],type="planet",force=1)
			write(out,outdir+"/"+item[,1]+"_"+item[,2]+".porb.hdf",hdf,force=1)
		}
		
		#run the minor bodies cases
		for(i=1;i<=length(minor_list);i+=1) {
			printf("Running Minor Body: %s\n",minor_list[,i])
			out=porb(minor_list[,i],type="minor",force=1)
			write(out,outdir+"/"+minor_list[,i]+".porb.hdf",hdf,force=1)
		}

		#run the comets cases
		for(i=1;i<=length(comet_list);i+=1) {
			printf("Running Comet: %s\n",comet_list[,i])
			out=porb(comet_list[,i],type="comet",force=1)
			write(out,outdir+"/"+comet_list[,i]+".porb.hdf",hdf,force=1)
		}
	}
}



define atob() {

  if($ARGC==0)  {
    printf("\nConvert a STRING/TEXT BOOLEAN to 0/1 integers\n")
    printf("$1=a STRING or TEXT array\n\n")
    printf("NOTE: This function explicitly matches \"T\" only.  Everything else is false\n\n")
    return(null)
  }

  if(type($1)!="STRING" && type($1)!="TEXT") {
    printf("$1 is not a STRING or TEXT array\n\n")
    return(null)
  }

  data=$1
  out=atoi(data)
  out[where data=="T"]=1

  return(out)
}


define generic_porb(name,epoch,e,a,w,i,node,peri,m,rot_per,polera,poledec,merid,usage,period) {

	if(HasValue(usage)==1) {
		printf("\nGenerate a generic PORB structure for use with the davinci porb function\n")
		printf("This is formatted in the minor body style for porb and permits the following values described below\n\n")
		printf("\tname = body name (Default=\"None\") will be truncated to 24 characters\n")
		printf("\tepoch = epoch in Julian Date (Default = 2451545.0, year 2000)\n")
		printf("\ta = Semi-Major Axis in AU (Default=1)\n")
		printf("\te = Eccentricity (Default=0)\n")
		printf("\ti = Inclination of mean orbit to ecliptic in degrees  (Default=0)\n")
		printf("\tnode = Longitude of the asceding node in degrees (Default=0)\n")
		printf("\tperi = Argument of perihelion in degrees (Default=0)\n")
		printf("\tm = Mean Anomoly at epoch in degrees (Default=0)\n")
		printf("\tpolera = Right Ascention of the pole in degrees (Default=0)\n")
		printf("\tpoledec = Declination of the pole in degrees (Default=0)\n")
		printf("\tmerid = prime meridian at epoch in degrees (Default=0\n")
		printf("\trot_per = siderial rotation period in hours (Default=23.9345)\n")
		printf("\tperiod = siderial orbital period in days (Default=365.256)\n")
		printf("\nc.edwards 4/27/17\n\n")
		return(null)
	}

	#fill in all the values w/defaults 
	output={}
	if(HasValue(name)==0) {
		output.name="None"
	} else {
		output.name=name[:24]
	}
	if(HasValue(epoch)==0) {
		output.epoch=2451545.00
	} else {
		output.epoch=epoch
	}
	if(HasValue(a)==0) {
		output.a=1.0
	} else {
		output.a=a
	}
	if(HasValue(e)==0) {
		output.e=0.0
	} else {
		output.e=e
	}
	if(HasValue(i)==0) {
		output.i=0.0
	} else {
		output.i=i
	}
	if(HasValue(node)==0) {
		output.node=0.0
	} else {
		output.node=node
	}
	if(HasValue(peri)==0) {
		output.peri=0.0
	} else {
		output.peri=peri
	}
	if(HasValue(m)==0) {
		output.m=0.0
	} else {
		output.m=m
	}
	if(HasValue(polera)==0) {
		output.polera=0.0
	} else {
		output.polera=polera
	}
	if(HasValue(poledec)==0) {
		output.poledec=0.0
	} else {
		output.poledec=poledec
	}
	if(HasValue(merid)==0) {
		output.merid=0.0
	} else {
		output.merid=merid
	}
	if(HasValue(rot_per)==0) {
		output.rot_per=23.9345
	} else {
		output.rot_per=rot_per
	}
	if(HasValue(period)==0) {
		output.period=365.256
	} else {
		output.period=period
	}
	return(output)
}



define krc_cond_gas(){

	if($ARGC == 0){
    printf (" Uses the adequate Clausius Clapeyron Coefficients to predict the frost point \n")
    printf (" Feeds KRC with SatPrA, SatPrB, FANON, AMW \n")
    printf (" $1: Body \n")
    printf (" Currently Supported: \"Mars\" or \"Pluto\" or \"Titan\" \n")
 	}

	Body   = $1
	
	if(Body == "Mars"){              
  	SatPrB = 3182.48
	  SatPrA = 27.9546
	  AMW    = 43.54                 #Sylvain's own calculation
    FANON  = 0.040               #Paul R. Mahaffy, Science 2013 (SAM)
		KPREF  = 1
	}

	if(Body == "Pluto"){
  	SatPrB = 9.2338
	  SatPrA = -724.9720
	  AMW   = 27.
	  FANON = 0.1
		KPREF = 0
	}

 	if(Body == "Titan"){
  	SatPrB = 9.2338
	  SatPrA = -724.9720
 		AMW   = 28.8
   	FANON = 0.016
		KPREF = 0
	} 

	if(Body != "Mars" && Body != "Titan" && Body != "Pluto") {
	  printf("Only Mars, Pluto, and Titan currently support Condensable Gas defaults\n")
		return(-999.)
	} else {
		out        = {}
		out.SatPrA = SatPrA
		out.SatPrB = SatPrB
		out.AMW    = AMW
		out.FANON  = FANON
		out.KPREF  = KPREF
		return(out)
	}
}



define krc_eclipse(Eclipser,Ecl_Cent_Hr,Bias,Eclipse_Style,Sun_Dis,Eclipser_Rad,CM,Eclipsed_Rad,Per_Mut,Date,body){

/*
if($ARGC == 0){
    printf (" Generates the change card for planetary eclipses in KRC \n")
    printf (" Input from porb and from user \n")
    printf (" $1:  Eclipser name, for Example \"Mars\" or \"Mars,Phobos\" \n")
    printf (" $2:  Eclipse central hour [???] \n")
    printf (" $3:  Eclipse Bias \n")
    printf (" $4:  Eclipse Style \n")
    printf (" Eclipse_Style=Eclipse Style (1=Rare,2=Daily), default is daily \n")
    printf (" Sun_Dis=Distance from the Sun in AU \n")
    printf (" Eclipser_Rad=Eclipser radius [km] \n")
    printf (" CM=Mutual center-of-mass orbit radius [km] if not from porb \n")
    printf (" Eclipsed_Rad=Eclipsed radius [km] \n")
    printf (" Per_Mut=Mutual orbit period [Days] Assumed same as diurnal PERIOD \n")
    printf (" Date=Rare Eclipse: J2000 date, assumed to be on the last season \n") 
	}
*/
    DIM_Eclipsed = strstr(body,",")
    if(DIM_Eclipsed==0) body=body+","+body
    Eclipsed     = delim(body,",",1) + "_" + delim(body,",",2)

	Eclipser_porb = load($DV_SCRIPT_FILES + "/krc_support/porb_defaults/" + Eclipser + ".porb.hdf")
	Eclipsed_porb = load($DV_SCRIPT_FILES + "/krc_support/porb_defaults/" + Eclipsed + ".porb.hdf")

	Sun_Dis      = max(cat(Eclipser_porb.planet_flux.Dis_AU,Eclipsed_porb.planet_flux.Dis_AU,axis=x))         #Distance to sun, AU (used to get Sun angular diameter)
	Eclipser_Rad = Eclipser_porb.planet_flux.Radius                                                           #Occulting body (OB) radius, km 
	CM           = max(cat(Eclipser_porb.planet_flux.Orb_Radius,Eclipsed_porb.planet_flux.Orb_Radius,axis=x)) #Mutual center-of-mass orbit radius, km = M  
	Eclipsed_Rad = Eclipsed_porb.planet_flux.Radius                                                           #Eclipsed body (EB) surface radius, km	        
	Per_Mut      = max(cat(Eclipser_porb.planet_flux.Mut_Period,Eclipsed_porb.planet_flux.Mut_Period,axis=x)) #Mutual orbit period, days ] Assumed same as diurnal PERIOD         
	Date         = Date                                                                                       #This value should make KRC crash	       	      

	line = sprintf("14 %.0i %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f 3 0. 0. / Eclipse",Eclipse_Style,Sun_Dis,Eclipser_Rad,CM,Eclipsed_Rad,Per_Mut,Bias,Date,Ecl_Cent_Hr) 

	return(line) 
}



define krc_planetary_flux_porb(porb,porb_Planet,Lon_Hr){

	if($ARGC == 0){
    printf (" Generates the change card for planetary heat loads in KRC \n")
    printf (" $1: porb for the satellite \n")
    printf (" $2: porb for the main body (planet) \n")
    printf (" $3: Lon_Hr, Longitude Hour of the surface point \n")
	}

	pi             = 3.14159
    #porb=load("/Applications/davinci.app/Contents/Resources/library/script_files/krc_support/porb_defaults/Mars_Phobos.porb.hdf")
	#porb_Planet=load("/Applications/davinci.app/Contents/Resources/library/script_files/krc_support/porb_defaults/Mars_Mars.porb.hdf")
	
	porb           = $1
	porb_Planet    = $2
	Data_Plan      = porb_Planet.planet_flux                                                  #Gets satellites data
	Data_Sat       = porb.planet_flux                                                         #Gets planet data
	Lon_Hr         = $3                                                                       #Longitude Hour

	Radiance       = 5.56E-8 * float(Data_Plan.BT_Avg)^4                                      #Calculates Average Radiance from Planet
	Min_Rad        = 5.56E-8 * float(Data_Plan.BT_Min)^4                                      #Calculates the Min Radiance from Planet
	Max_Rad        = 5.56E-8 * float(Data_Plan.BT_Max)^4                                      #Calculates the Max Radiance from Planet
	Delta_Radiance = 5.56E-8 * (float(Data_Plan.BT_Max)^4 - float(Data_Plan.BT_Min^4))        #Calculates Max - Min Radiance form Planet
	Plan_Ang_Surf  = pi*((360./pi)*atan(Data_Plan.Radius/(2*Data_Sat.Orb_Radius)))^2/3282.80635#Angular Surface of Planet
	IR_Flux        = Radiance * Plan_Ang_Surf/pi                                              #IR Flux from Planet on Satellite
	IR_Half_Amp    = (Radiance - Min_Rad ) * Plan_Ang_Surf * 0.5 / pi                         #1/2 Amplitude
	IR_Phase_Lag   = 0.                                                                       #Will need to Look at that for Eclipses
	Vis_Flux_Peak  = Data_Plan.Geom_alb * 1361./(Data_Plan.Dis_AU^2) * Plan_Ang_Surf          #Peak Visible Flux from Planet
	Vis_Flux       = 0.5 * Vis_Flux_Peak                                                      #Average Visible Flux from the planet
	Vis_Half_Amp   = Vis_Flux                                                                 #Most often 0.
	Vis_Phase_Lag  = 0.                                                                       #Will need to Look at that for Eclipses

	line = sprintf("15 %.2f %.2f %.2f %.2f %.2f %.2f %.2f / Forcing from Planet on Satellite",IR_Flux,IR_Half_Amp,IR_Phase_Lag,Vis_Flux,Vis_Half_Amp,Vis_Phase_Lag,Lon_Hr)  
	return(line)
}



define krc_planetary_flux_table(IR,Vis,Lon_Hr){
#05/17/2018: Fixes issue with average fluxes definition (HHK email of 05/07/2018)

	if($ARGC == 0){
    printf (" Generates the change card for planetary heat loads in KRC \n")
    printf (" $1: IR array vs LTST (2xnx1)\n")
    printf (" $2: Vis array vs LTST (2xnx1)\n")
    printf (" $3: Lon_Hr, Longitude Hour of the surface point \n")
	}

	pi            = 3.14159
	IR_1          = $1
	IR            = IR_1[1,,1]                                                                #IR array, y axis
	LTST_IR       = IR_1[2,,1]                                                                #LTST for the IR array, y axis
	Vis_1         = $2
	Vis           = Vis_1[1,,1]                                                               #Vis array, y axis
	LTST_Vis      = Vis_1[2,,1]                                                               #LTST for the Vis array, y axis
	Lon_Hr        = $3                                                                        #Longitude Hour
	
	Peak_IR       = maxpos(IR,showval=1)
	Min_IR        = minpos(IR,showval=1)
	LTST_IR_Peak  = LTST_IR[1,int(Peak_IR[2,1,1]),1]                                          #int(Peak_IR[2,1,1]) is the index
	Half_Amp_IR   = 0.5*(Peak_IR[4]-Min_IR[4])
	Phase_IR      = 360.*LTST_IR_Peak/24.                                                     #in degree
	IR_KRC        = Min_IR[4] + Half_Amp_IR * (1 + cosd(360.*LTST_IR/24. - Phase_IR))
	#labelxy("LTST","Flux")
	#plot(IR,"IR",Xaxis=LTST_IR,IR_KRC)
	
	
	Peak_Vis       = maxpos(Vis,showval=1)
	Min_Vis        = minpos(Vis,showval=1)
	LTST_Vis_Peak  = LTST_Vis[1,int(Peak_Vis[2,1,1]),1]                                       #int(Peak_IR[2,1,1]) is the index
	Half_Amp_Vis   = 0.5*(Peak_Vis[4]-Min_Vis[4])
	Phase_Vis      = 360.*LTST_Vis_Peak/24.                                                   #in degree
	Vis_KRC        = Min_Vis[4] + Half_Amp_Vis * (1 + cosd(360.*LTST_Vis/24. - Phase_Vis))
	#plot(Vis,"Vis",Xaxis=LTST_Vis,Vis_KRC)
	
	Vis_Flux      = Min_Vis[4]  + Half_Amp_Vis                                                #Average solar Flux
	Vis_Half_Amp  = Half_Amp_Vis                                                              #Visible Half Amplitude
	Vis_Phase_Lag = Phase_Vis                                                                 #Vis Phase Lag in degrees
	IR_Flux       = Min_IR[4]  + Half_Amp_IR                                                  #Average Thermal Emission
	IR_Half_Amp   = Half_Amp_IR                                                               #IR Half Amplitude
	IR_Phase_Lag  = Phase_IR                                                                  #IR Phase Lag in degrees
	
	line = sprintf("15 %.2f %.2f %.2f %.2f %.2f %.2f %.2f / Forcing from Planet on Satellite",IR_Flux,IR_Half_Amp,IR_Phase_Lag,Vis_Flux,Vis_Half_Amp,Vis_Phase_Lag,Lon_Hr) #IR, then Vis    
	return(line)
}
